<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kata on Raúl Padilla Delgado</title>
    <link>https://raulpadilladelgado.github.io/blog/categories/kata/</link>
    <description>Recent content in Kata on Raúl Padilla Delgado</description>
    <generator>Hugo</generator>
    <language>es</language>
    <lastBuildDate>Mon, 06 Jul 2020 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://raulpadilladelgado.github.io/blog/categories/kata/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Kata El juego de la vida</title>
      <link>https://raulpadilladelgado.github.io/blog/p/kata-el-juego-de-la-vida/</link>
      <pubDate>Mon, 06 Jul 2020 00:00:00 +0000</pubDate>
      <guid>https://raulpadilladelgado.github.io/blog/p/kata-el-juego-de-la-vida/</guid>
      <description>&lt;p&gt;Mi implementación para este ejercicio de programación se basa en tener una clase &amp;ldquo;Cell&amp;rdquo;, que tendrá un atributo llamado &amp;ldquo;isAlive&amp;rdquo;(haciendo referencia a si la célula vive o no), y además otra clase llamada &amp;ldquo;World&amp;rdquo; que tiene un diccionario tipo clave(Integer) valor(Cell).&lt;/p&gt;&#xA;&lt;p&gt;En la clase &amp;ldquo;World&amp;rdquo; existe un método que cambia &amp;ldquo;de generación&amp;rdquo;, que comprueba que las células muertas que tengan exactamente tres células vecinas vivas(tres posiciones seguidas del diccionario con valor &amp;ldquo;isAlive&amp;rdquo; a true) revivan. Además, comprueba también que una célula viva que tenga dos o tres vecinos, siga con vida, en cambio, la célula que tenga menos de dos o más de tres vecinos, debe morir por &amp;ldquo;sobrepoblación o soledad&amp;rdquo;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kata template engine</title>
      <link>https://raulpadilladelgado.github.io/blog/p/kata-template-engine/</link>
      <pubDate>Tue, 09 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://raulpadilladelgado.github.io/blog/p/kata-template-engine/</guid>
      <description>&lt;p&gt;Recientemente, he realizado una kata en Java, que consistía en implementar un parseador de plantillas.&lt;/p&gt;&#xA;&lt;p&gt;Existe un método que recibe como parámetros la plantilla (String) a parsear, y un diccionario (Map) con todas las claves que vamos a sustituir en la cadena anterior. Es éste método el encargado de cambiar cada variable en la cadena por cada variable en el diccionario.&lt;/p&gt;&#xA;&lt;p&gt;Para el desarrollo del ejercicio, seguí la metodología de TDD, por lo que primero expuse una serie de casos en los que se definen como se debería comportar éste parseador testando la salida que devuelve con lo que esperamos, y poco a poco, realizando un test y el código justo y necesario para cada caso, fui viendo como llevar casos muy específicos hasta casos muy generales, llegando hasta la iteración sólo en el momento necesario, para no tener a una solución muy complicada desde el principio por intentar precipitarse en generalizar cuando solo necesitamos cubrir un caso específico.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kata Word Wrap</title>
      <link>https://raulpadilladelgado.github.io/blog/p/kata-word-wrap/</link>
      <pubDate>Fri, 17 Apr 2020 00:00:00 +0000</pubDate>
      <guid>https://raulpadilladelgado.github.io/blog/p/kata-word-wrap/</guid>
      <description>&lt;p&gt;Recientemente he estado realizando una kata que consistía en partir una palabra (salto de línea) acorde a un ancho de columna, algo así como el funcionamiento de los editores de texto cuando se establece el ajuste de línea. La idea consistía en ajustar la palabras, y a su vez tantas veces el resto de ésta palabra como para que la longitud del texto en cada línea no supere el ancho de columna. Un ejercicio que da mucho que pensar y del cual pude experimentar como ir buscando poco a poco un patrón que se repite en el código para llevarlo hacía un bucle o una recursividad que haga lo que necesitamos para partir la palabra cuantas veces se necesite, y que controlamos en todo momento su funcionamiento sin necesidad de depurar y asegurando que va cumpliendo los test que proponemos.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
