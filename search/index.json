[{"content":"Introducci√≥n T√≠picamente, cuando estamos desarrollando c√≥digo, hacemos mucho uso de la terminal para ejecutar distintos comandos que nos permiten, por ejemplo, comprobar que nuestros test pasan, descargar dependencias, arrancar la aplicaci√≥n en local\u0026hellip; Estos comandos suelen ser largos y nos puede resultar dif√≠cil recordarlos o simplemente tenemos que ejecutar varios porque encadenan una funci√≥n que queremos realizar sobre nuestro c√≥digo.\nEs aqu√≠ donde nos preguntamos si exist√≠a alguna herramienta que nos simplificara esta tarea y que fuera f√°cil de implementar y usar. La primera que se nos ocurri√≥ debido a su popularidad fue Makefile. Indagando un poco m√°s sobre qu√© es esta tecnolog√≠a y para qu√© fue creada, llegamos a la conclusi√≥n de que su prop√≥sito principal es describir las dependencias entre los archivos fuente de un proyecto y las reglas para compilarlos, as√≠ como generar ejecutables. Esta definici√≥n no cuadraba mucho con el tipo de herramienta que est√°bamos buscando, por lo que decidimos descartarla.\nTras el punto anterior, seguimos con nuestra investigaci√≥n y consultamos a compa√±eros. Varios nos recomendaron una herramienta llamada Task que por ahora supl√≠a todas nuestras necesidades.\n¬øQu√© es Task? La herramienta se describe a s√≠ misma como un runner de tareas o una herramienta de construcci√≥n que busca ser m√°s simple y f√°cil de usar que GNU Make. Como principales ventajas frente a la herramienta con la que se comparan, tenemos que:\nEs una herramienta multiplataforma. Make funciona completamente en las m√°quinas Unix, pero en Windows hay que hacer alg√∫n cambalache como usar Cygwin o WSL para poder usarlo. Para Task, con la instalaci√≥n ya es totalmente compatible con tu sistema operativo. Tiene una sintaxis m√°s simple. Por lo tanto, es m√°s sencillo entenderlo y aplicarlo que Make. Adem√°s, los IDE modernos, como IntelliJ o Visual Studio Code, tienen soporte para sugerirte qu√© sintaxis puedes usar con su debida documentaci√≥n embebida. Tiene muchas m√°s funcionalidades. Como comentamos anteriormente, Make no se pens√≥ como un runner de tareas, por lo que entendemos que no se buscaba tener tantas funcionalidades como tiene Task a la hora de encadenar tareas, definir sus descripciones, entre otras. Task por defecto buscar√° en tu proyecto un archivo llamado Taskfile.yml que podr√≠a tener una estructura como esta:\nversion: \u0026#39;3\u0026#39; tasks: hello: cmds: - echo \u0026#39;Hello World from Task!\u0026#39; silent: true Algo a remarcar es que no busca un Taskfile.yml en la ruta ra√≠z de tu proyecto, aunque t√≠picamente el archivo se suela ubicar ah√≠. En su lugar, es capaz de buscar recursivamente por las carpetas de tu proyecto por ese archivo. Gracias a esto no te tienes que preocupar de en qu√© localizaci√≥n de tu proyecto te encuentras para lanzar una tarea con Task.\nEjemplo Les mostramos un breve ejemplo propio sobre como se puede usar la herramienta:\nversion: \u0026#39;3\u0026#39; silent: true tasks: test: desc: \u0026#34;üß™ Run tests\u0026#34; cmds: - flutter test build: desc: \u0026#34;üî® Build application executable\u0026#34; preconditions: - sh: ls {{ .TASKFILE_DIR }} msg: \u0026#34;{{.PRECONDITION_MESSAGE}}\u0026#34; cmds: - task: my-plugin:generate - task: build-to-macos build-to-macos: internal: true platforms: [ darwin ] cmds: - flutter build macos --release default: cmds: - task -l vars: PRECONDITION_MESSAGE: ü§∑‚Äç‚ôÄÔ∏èYou need to have a valid Taskfile in your myplugin project MY_PLUGIN_DIR: ../my-plugin TASKFILE_DIR: \u0026#34;{{ .MY_PLUGIN_DIR }}/Taskfile.yml\u0026#34; includes: my-plugin: taskfile: \u0026#34;{{ .MY_PLUGIN_DIR }}\u0026#34; dir: \u0026#34;{{ .MY_PLUGIN_DIR }}\u0026#34; internal: true optional: true La tarea build construye el ejecutable de una aplicaci√≥n y se apoya en una tarea de otro Taskfile, estableciendo una precondici√≥n que verifica que exista el fichero, y luego utiliza una tarea interna que solo se ejecuta en caso de que tu sistema operativo sea MacOS.\nComo se puede ver, se extraen variables para simplificar y reducir la cantidad de texto literal, ya sea rutas u otros textos complejos.\nLa tarea default es un truco que hemos hecho para que simplemente con ejecutar el comando task sin ning√∫n argumento, te liste las tareas disponibles, lo que normalmente tendr√≠as que hacer ejecutando task -l. Esta seria su salida:\n‚ùØ task task: Available tasks for this project: * build: üî® Build application executable * test: üß™ Run tests Por defecto, cuando ejecutamos task -l se usa una ordenaci√≥n alfanum√©rica, por lo que si quieres que se muestren por orden de tu preferencia podr√≠as cambiar la tarea default para que use el comando task -l -sort none. Esto provoca que a la hora de mostrarlos sigan el mismo orden que definiste en el Taskfile.\nNuestra experiencia En apenas unas pocas horas logramos implementarlo en un proyecto real. Una de las primeras cosas que notamos fue su gran escalabilidad. Con Task, puedes cubrir el espectro completo de las tareas, desde las m√°s simples, como definir un alias para un comando largo, hasta las m√°s complejas, como encadenar diversas operaciones y ejecutarlas seg√∫n tu sistema operativo.\nUn elemento muy simple, pero que nos resulta muy √∫til, es la posibilidad de ejecutar un comando que muestra todas las tareas configuradas junto con su descripci√≥n. Esto agrega una capa de organizaci√≥n y claridad a nuestro flujo de trabajo que simplemente no estaba presente antes.\nEn el uso que hemos dado a la herramienta, hay varias caracter√≠sticas poderosas que queremos destacar:\nTaskfile te permite especificar que ciertas tareas se ejecuten en un directorio en particular. Esto es extremadamente √∫til para mantener separadas las tareas y los contextos en los que se ejecutan. Las precondiciones, que verifican si la tarea necesita ser ejecutada o no, han resultado ser una herramienta valiosa para prevenir la redundancia y optimizar el tiempo de trabajo. La habilidad de conectar m√∫ltiples Taskfiles es otra funci√≥n que hemos explotado bastante. Puedes importar un Taskfile dentro de otro y usar sus tareas, lo que facilita enormemente la reutilizaci√≥n de c√≥digo y la organizaci√≥n. Nos ha sido muy √∫til tener tareas que se definen como internas, que no se ejecutan desde fuera, sino que son llamadas por otras tareas que s√≠ son p√∫blicas. Esta funcionalidad facilita la extracci√≥n de m√©todos, de la misma manera que lo har√≠as en un lenguaje de programaci√≥n. La opci√≥n de definir varios alias para la misma tarea es otra funci√≥n que hemos disfrutado. Cada persona puede invocar la tarea con el nombre de su elecci√≥n, lo que ayuda a la personalizaci√≥n y la comodidad del usuario. Finalmente, la gesti√≥n de errores en Task es s√≥lida y eficiente, permiti√©ndonos identificar y solucionar problemas con mayor rapidez. En resumen, nuestra experiencia con Taskfile ha sido muy positiva. Ha mejorado nuestra eficiencia, organizaci√≥n, y nos ha proporcionado un conjunto de herramientas poderosas para manejar nuestras tareas de desarrollo. Sin duda, lo recomendamos a otros equipos de desarrollo que busquen una herramienta de gesti√≥n de tareas s√≥lida y flexible.\n","date":"2023-10-16T00:00:00Z","image":"https://raulpadilladelgado.github.io/blog/p/automatizando-tareas-con-task/images/make-vs-task.jpg","permalink":"https://raulpadilladelgado.github.io/blog/p/automatizando-tareas-con-task/","title":"Automatizando tareas con Task"},{"content":"Introducci√≥n Los lenguajes de programaci√≥n y los frameworks evolucionan con el tiempo para ofrecer a los desarrolladores una forma m√°s simple y eficaz de resolver los problemas del mundo real y conseguir una soluci√≥n adecuada seg√∫n el contexto. Por ejemplo, cuando naci√≥ la programaci√≥n orientada a objetos se pudo romper la barrera entre desarrollador y experto de producto plasmando la problem√°tica en objetos de dominio que actuaban como lenguaje com√∫n para ambas partes.\nOtra gran necesidad que surgi√≥ fue la de no utilizar el cl√°sico modelo de programaci√≥n ¬´instrucci√≥n por instrucci√≥n¬ª, donde es necesario que para poder pasar a la siguiente instrucci√≥n, la anterior haya finalizado su prop√≥sito. En su lugar, se busca un planteamiento as√≠ncrono que permita aprovechar al m√°ximo los hilos de ejecuci√≥n de nuestra aplicaci√≥n para brindarle al usuario una experiencia m√°s r√°pida y flexible. Es aqu√≠ donde aparece el concepto de Programaci√≥n Reactiva.\nCabe destacar que se origin√≥ en la d√©cada de 1990 con el concepto de programaci√≥n funcional reactiva. Cient√≠ficos de la computaci√≥n como David Pearce, Conal Elliott y Paul Hudak, trabajaron en el desarrollo de lenguajes y teor√≠as que dieron lugar a la programaci√≥n reactiva tal como la conocemos hoy en d√≠a.\nEn 2003, un grupo de desarrolladores liderados por Anders Hejlsberg en Microsoft, crearon Reactive Extensions (Rx), una biblioteca para programaci√≥n reactiva en .NET. Fue ah√≠ que comenz√≥ a ganar mucha popularidad y fue siendo adoptada en muchos otros lenguajes y frameworks.\n¬øQu√© es la programaci√≥n reactiva? La programaci√≥n reactiva es un paradigma de programaci√≥n que se centra en la gesti√≥n de datos que cambian a lo largo del tiempo. En lugar de tratar los datos como valores est√°ticos, se tratan como flujos de datos que cambian en el tiempo.\nUn programa reactivo se basa en la idea de que los datos pueden ser tratados como un flujo continuo de eventos que se pueden procesar de forma as√≠ncrona. Los programas reactivos pueden manejar grandes cantidades de datos y son adecuados para aplicaciones que necesitan procesar grandes cantidades de informaci√≥n de manera eficiente, como aplicaciones en tiempo real o aplicaciones que manejan mucho tr√°fico de red.\nUn bloque de c√≥digo se subscribe a un flujo de datos continuo definido por otro c√≥digo para comenzar a recibir notificaciones (datos) cuando se producen cambios en los datos. Gracias a esto, nuestro c√≥digo se vuelve as√≠ncrono y no bloqueante, permitiendo que un hilo de ejecuci√≥n no se bloquee por estar ejecutando una instrucci√≥n que depende de recibir una serie de datos y que delegue el trabajo a otro hilo para poder seguir procesando otras instrucciones, y este hilo a su vez no depende de recibir los datos en el momento, si no que es capaz de subscribirse a la entrada de esos datos para ir recibi√©ndolos a medida que est√°n listos.\nAdem√°s de la asincron√≠a, otra gran ventaja que nos brinda este paradigma es la posibilidad de ser m√°s resiliente a los fallos, o diferentes enfoques para evitarlos. Por ejemplo, si tenemos que consumir una gran cantidad de datos desde una fuente pero sabemos que si cargamos todos de golpe nuestro sistema se va a sobrecargar y por tanto dejar√° de funcionar, podemos poner l√≠mites ya sea por lotes en los que consumimos poco a poco todos los datos, o incluso controlando la carga por tiempo, cargando solo durante un tiempo y reanudando despu√©s. Hay muchas posibilidades disponibles para usar seg√∫n sea el problema que tengamos que resolver.\nEjemplo (Spring Boot + Kotlin) El c√≥digo fuente de los siguientes ejemplos lo puedes encontrar alojado en Github visitando el siguiente enlace:\nhttps://github.com/raulpadilladelgado/reactive-springboot\nPublicar API Rest Reactiva Nuestra aplicaci√≥n Spring Boot ser√° reactiva gracias al uso de la librer√≠a spring-boot-starter-webflux, ya que nos permite escribir y leer REST APIs reactivas. Para que podamos relacionar el concepto con algo m√°s tangible vamos a ver un ejemplo de programaci√≥n reactiva usando Spring Boot y Kotlin.\nimport org.springframework.http.MediaType.TEXT_EVENT_STREAM_VALUE import reactor.core.publisher.Flux import reactor.core.publisher.Mono import java.time.Duration.ofSeconds @RestController class SongController { @Autowired private lateinit var songRepository: SongRepository @GetMapping(value = [\u0026#34;/song\u0026#34;], produces = [TEXT_EVENT_STREAM_VALUE]) fun findSongs(): Flux\u0026lt;Song\u0026gt; { return songRepository.findAll().delayElements(ofSeconds(3)) } @PostMapping(value = [\u0026#34;/song\u0026#34;], produces = [TEXT_EVENT_STREAM_VALUE]) fun saveSong(@RequestBody song: Song): Mono\u0026lt;Song\u0026gt; { return songRepository.save(song) } } Para habilitar la programaci√≥n reactiva en el primer endpoint, hemos usado el tipo de retorno Flux de la biblioteca Reactor de Spring. Este tipo representa un flujo de datos asincr√≥nico que puede emitir varios valores a lo largo del tiempo. Adem√°s, hemos especificado que la API debe producir un tipo de contenido text/event-stream, lo que indica que se trata de un flujo de eventos en tiempo real. Para simular que nuestra API est√° tratando de consumir datos desde una fuente que puede tardar m√°s tiempo del deseado, hemos usado delayElements para retrasar un poco el env√≠o de datos desde nuestro endpoint.\nPara que nuestra API sea totalmente reactiva, cabe destacar que hemos usado la librer√≠a R2DBC, m√°s concretamente en su implementaci√≥n para PostgreSQL, la cual nos permite operar con la base de datos de una forma reactiva trabajando con los ya comentados flujos de datos. La ventaja frente a JDBC (librer√≠a m√°s com√∫n para persistencia en el mundillo de Spring Boot) es que los m√©todos que nos ofrece para operar con la base de datos no son bloqueantes y nos facilita la integraci√≥n con nuestra API reactiva ya que trabaja usando los tipos de datos as√≠ncronos como Flux o Mono. Vamos a ver la implementaci√≥n del repositorio:\n... //R2DBC PostgreSQL import org . springframework . data . r2dbc . repository . R2dbcRepository @Repository interface SongRepository : R2dbcRepository\u0026lt;Song, Int\u0026gt; Al extender de ReactiveCrudRepository ya tenemos disponibles una gran cantidad de m√©todos como find, findAll, Save‚Ä¶ (v√©ase el ejemplo en el c√≥digo del controlador m√°s arriba).\nEn el segundo endpoint, hemos usado el tipo Mono, que solo contiene un valor y que usamos para retornar el elemento que guardamos en la base de datos.\nOtro aspecto importante a tener en cuenta es c√≥mo configuramos SpringBoot para que pueda conectarse a nuestra base de datos. Tenemos que especificar qu√© URL tiene que usar R2DBC para conectarse:\nInserta este c√≥digo en tu application.yml o application.properties:\nspring: r2dbc: url: r2dbc:postgresql://postgres:5432/admin username: admin password: password Esta configuraci√≥n ser√° variable dependiendo de como tengas desplegada tu base de datos. En el ejemplo que proporciono, la base de datos se arranca en local junto con la aplicaci√≥n utilizando Docker.\nConsumir API Rest Reactiva Aqu√≠ te presento un ejemplo de c√≥mo consumir de forma reactiva esta API desde una aplicaci√≥n cliente usando la biblioteca Reactor de Spring:\n... import org . springframework . web . reactive . function . client . WebClient import java . time . Duration @RestController class ConsumeSongController { @GetMapping(\u0026#34;/consume\u0026#34;) fun consumeAll() { val response = WebClient.builder() .baseUrl(SONGS_URL) .build() .get() .retrieve() .bodyToFlux(Map::class.java) response.subscribe { song -\u0026gt; println(song) } } @GetMapping(\u0026#34;/consume-only-two\u0026#34;) fun consumeOnlyTwo() { val response = WebClient.builder() .baseUrl(SONGS_URL) .build() .get() .retrieve() .bodyToFlux(Map::class.java) response.take(2).subscribe { song -\u0026gt; println(song) } } @GetMapping(\u0026#34;/consume-for-five-seconds\u0026#34;) fun consumeForFiveSeconds() { val response = WebClient.builder() .baseUrl(SONGS_URL) .build() .get() .retrieve() .bodyToFlux(Map::class.java) response.take(Duration.ofSeconds(5)).subscribe { song -\u0026gt; println(song) } } } private const val SONGS_URL = \u0026#34;http://127.0.0.1:8080/song\u0026#34; Para recibir la respuesta como un flujo de eventos, hemos usado el m√©todo bodyToFlux de la clase WebClient ( librer√≠a reactiva para consumir APIs), que nos permite almacenar los datos a medida que llegan en la variable. Finalmente, hemos suscrito un manejador al flujo de eventos, que simplemente imprime cada evento recibido por consola. Al ejecutar este c√≥digo, la aplicaci√≥n cliente comenzar√° a consumir el flujo de eventos de forma reactiva y se imprimir√° un mensaje por cada evento recibido.\nComo comentamos anteriormente, tenemos muchas posibilidades para evitar la sobrecarga en nuestra aplicaci√≥n especificando cada cuanto tiempo queremos coger datos o cuanta cantidad, etc.\nWebgraf√≠a Jacquot, A. (8 de julio del 2021). Programaci√≥n reactiva con Spring Data R2DBC. Blog de Pictet Technologies: https://medium.com/pictet-technologies-blog/reactive-programming-with-spring-data-r2dbc-ee9f1c24848b\nPaluch, M. (7 de diciembre de 2018). Programaci√≥n Reactiva y Bases de Datos Relacionales. Blog de primavera: https://spring.io/blog/2018/12/07/reactive-programming-and-relational-databases\nVijay, Srj. (10 de junio del 2022). ¬øC√≥mo implementar la programaci√≥n reactiva en Spring Boot?. El desarrollador de la pila completa: https://fullstackdeveloper.guru/2022/06/10/how-to-implement-reactive-programming-in-spring-boot/\n","date":"2023-02-01T00:00:00Z","image":"https://raulpadilladelgado.github.io/blog/p/programaci%C3%B3n-reactiva-que-es-y-como-usarla-en-spring-boot/images/programacion_reactiva.png","permalink":"https://raulpadilladelgado.github.io/blog/p/programaci%C3%B3n-reactiva-que-es-y-como-usarla-en-spring-boot/","title":"Programaci√≥n reactiva, que es y como usarla en Spring Boot"},{"content":"Introducci√≥n Creo que es una realidad imperativa la relevancia de mantener actualizadas las versiones que utilizamos de librer√≠as/dependencias externas en nuestros proyectos. Ya sea porque evitamos brechas de seguridad que se propagan desde ese factor externo hasta nuestro c√≥digo o tambi√©n incluso porque las peque√±as actualizaciones son m√°s f√°ciles de incorporar. Cambiar algunas grandes versiones m√°s adelante, junto con las complicaciones que esto conlleva, puede hacer que sea un aut√©ntico sufrimiento tener que adaptar nuestro c√≥digo a los nuevos mandatos de la dependencia externa, ya que han ocurrido cambios que rompen con lo que actualmente us√°bamos.\nPartiendo de esta premisa, en la que no le estoy abriendo los ojos a nadie, me gustar√≠a compartir una herramienta en la que he trabajado para solventar una necesidad que ten√≠a en el d√≠a a d√≠a con mi equipo de trabajo y que puede ser √∫til para cualquier proyecto que busque una soluci√≥n similar.\nTodos nuestros proyectos est√°n escritos en Java o Kotlin usando como framework Spring Boot y Gradle como herramientas de compilaci√≥n. En Gradle las dependencias se definen con un archivo build.gradle, que puede tener una estructura como la siguiente:\nplugins { id \u0026#39;org.springframework.boot\u0026#39; version \u0026#39;2.7.4\u0026#39; id \u0026#39;io.spring.dependency-management\u0026#39; version \u0026#39;1.0.14.RELEASE\u0026#39; id \u0026#39;java\u0026#39; id \u0026#34;com.github.ben-manes.versions\u0026#34; version \u0026#34;0.43.0\u0026#34; } group = \u0026#39;com.example\u0026#39; version = \u0026#39;0.0.1-SNAPSHOT\u0026#39; sourceCompatibility = \u0026#39;17\u0026#39; repositories { mavenCentral() } dependencies { testImplementation \u0026#39;org.junit.jupiter:junit-jupiter-api:5.8.2\u0026#39; testImplementation \u0026#39;org.junit.jupiter:junit-jupiter-params:5.8.2\u0026#39; testImplementation \u0026#39;org.assertj:assertj-core:3.22.0\u0026#39; testImplementation \u0026#39;org.mockito:mockito-core:4.5.1\u0026#39; testRuntimeOnly \u0026#39;org.junit.jupiter:junit-jupiter-engine:5.8.2\u0026#39; } tasks.named(\u0026#39;test\u0026#39;) { useJUnitPlatform() } Problem√°tica Para mantener nuestras dependencias actualizadas recurrimos a un plugin que tanto por consola como en un fichero de texto plano nos muestra las nuevas versiones a las que podemos actualizar las nuestras. Dicho plugin lo hemos visto en el anterior bloque de c√≥digo id \u0026quot;com.github.ben-manes.versions\u0026quot; version \u0026quot;0.43.0\u0026quot; y este nos permite ejecutar el comando desde la consola ./gradlew dependencyUpdates.\nEs aqu√≠ donde surge nuestro ¬´problema¬ª, y es que como hemos visto, debemos puntualizar o precisar el lanzamiento de dicho comando en local para saber si tenemos que actualizar algo y a qu√© versi√≥n en concreto, por lo que depende de la buena memoria de los developers a la hora de lanzar esto peri√≥dicamente y realizar los cambios pertinentes. Es entonces cuando se me ocurre que quiz√° esto se pueda automatizar aprovechando el CI/CD, por lo que me puse a buscar soluciones ya existentes. Para mi asombro, fue realmente simple encontrarlas en el marketplace de Github Actions para este prop√≥sito, pero no terminaban de convencerme. Resulta que todo lo que encontr√© eran soluciones en las que autom√°ticamente se abr√≠a una Pull Request en el proyecto con las dependencias actualizadas para que los developers puedan mergearla, e incluso otras soluciones eran auto-mergeable ¬øSuena bien verdad? Ahora bien, plante√°ndome la situaci√≥n en profundidad descubr√≠ que esto no terminaba de ajustarse a nuestra forma de trabajo, ya que implicar√≠a una revisi√≥n constante, estar pendiente de la secci√≥n de PR en los proyectos, por lo que si contamos con un sistema de microservicios este razonamiento nos supon√≠a que era inviable. En ocasiones, los grandes cambios entre versiones de las dependencias puede conllevar que nuestros test no pasen en verde, lo que requiere de un trabajo extra, as√≠ que tuve que descartar las soluciones auto-mergeable. Mi impresi√≥n era que nos ser√≠a m√°s sencillo y flexible a todos decidir en las Pull Request que har√≠amos con las actualizaciones pendientes que ten√≠amos, teniendo la posibilidad de no actualizar algunas porque har√≠an que algunos test no pasaran en verde o por cualquier otro factor que nos pudiese suponer un bloqueo para sacar la Pull Request adelante en un momento en el que quiz√° no pod√≠amos permitirnos dedicarle demasiado tiempo.\nSoluci√≥n Una vez identificada la problem√°tica, me gustar√≠a contaros la resoluci√≥n a la que llegu√©. B√°sicamente, he desarrollado una Github Action que he publicado en el Marketplace de Github, donde te comenta las PR que abras con las dependencias que necesitas actualizar, o en su defecto con un comentario de que todo est√° actualizado. El c√≥digo fuente de la action lo pod√©is encontrar aqu√≠. Os pongo tambi√©n dos GIF sobre como funciona:\nCuando tienes dependencias que actualizar: Animaci√≥n con dependencias por actualizar Cuando todas tus dependencias est√°n actualizadas: Animaci√≥n con todo actualizado Un poco m√°s de Github Actions Adem√°s de compartir esta herramienta, me gustar√≠a haceros una breve introducci√≥n para animaros a desarrollar vuestra propia Github Action alguna vez. Lo primero de todo es consultar la informaci√≥n m√°s extendida en la documentaci√≥n oficial de Github, sin embargo, tratar√© de resumir lo b√°sico que necesit√© para crear la m√≠a.\nExisten tres formas de crear GitHub Actions:\nUsando Javascript Usando Docker Compuestas En mi caso he optado por crear una acci√≥n que funciona dentro de un contenedor de Docker. El proyecto se compone de:\nUn archivo Dockerfile en el cual se define la imagen sobre la que se ejecutar√° el script bash que declaramos en el entrypoint. Un archivo de metadatos en el que se definen las entradas y salidas de la action as√≠ como otra informaci√≥n relevante para el marketplace de Github. El script de bash en el que se encuentra el core de nuestra action. Conclusi√≥n En un mundo ideal no deber√≠a ser necesario esta ¬´manualidad¬ª de tener que actualizar a mano las dependencias, pero hasta que conozca una soluci√≥n c√≥moda y simple creo que esta forma de recordar que existen actualizaciones pendientes en las PR es una buena forma de no descuidar las dependencias de un proyecto Gradle.\nEspero que este post haya sido claro y preciso, a la vez que √∫til e informativo. ¬°Gracias por dedicar una parte de vuestro tiempo a la lectura de este art√≠culo!\n","date":"2023-01-02T00:00:00Z","image":"https://raulpadilladelgado.github.io/blog/p/comprobar-versiones-de-dependencias-de-gradle-en-las-pull-request/images/ghactionsgradle.png","permalink":"https://raulpadilladelgado.github.io/blog/p/comprobar-versiones-de-dependencias-de-gradle-en-las-pull-request/","title":"Comprobar versiones de dependencias de Gradle en las Pull Request"},{"content":"Introducci√≥n Toda la informaci√≥n que encontrar√°s aqu√≠ est√° basada en el libro de Carlos Bl√© \u0026ldquo;C√≥digo sostenible\u0026rdquo;. En este post hablar√© sobre lo que he aprendido con la lectura de este libro. Ser√°n unas breves nociones lo que destacar√©, por lo que para obtener la mejor experiencia te recomiendo que leas el libro original, te ser√° muy √∫til el detalle con el que se explican los conceptos y los ejemplos usados en esta gu√≠a para realizar c√≥digo limpio y f√°cil de mantener.\n¬øQu√© es c√≥digo sostenible? El c√≥digo debe ser funcionalmente perfecto, debe cumplir todos los criterios especificados, pero adem√°s debe ser f√°cil de entender, mantener y escalar.\nSi tu c√≥digo no es sostenible ser√° una principal fuente de fracaso en tu empresa, ya que con el tiempo ser√° cada vez m√°s dif√≠cil de modificar.\nY no confundamos que sostenible va relacionado con futurista, ya que precisamente intentar realizar c√≥digo que cubra los escenarios de hoy, pero tambi√©n los de ma√±ana, complica mucho el trabajo que tenemos que hacer y en la mayor√≠a de ocasiones nos induce a que no podamos tener un c√≥digo sostenible.\nEn resumen, el c√≥digo es sostenible cuando es simple y conciso, y est√° respaldado por test autom√°ticos.\n¬øC√≥mo consigo un c√≥digo sostenible? Como vimos en el punto anterior, tenemos que lograr un c√≥digo sencillo y concreto. Para entender c√≥mo logramos esto, veamos qu√© est√° en nuestra mano.\nNo caigas en la reutilizaci√≥n de c√≥digo excesiva sin control que, por ejemplo, intenta hacer que una misma funci√≥n sirva para todo, ya que esto har√° que uses menos abstracciones. Las abstracciones son la sem√°ntica de tu aplicaci√≥n. Cada vez que extraes un objeto o una funci√≥n y le das un nombre est√°s a√±adiendo una abstracci√≥n que define la misi√≥n de esa parte del c√≥digo. El c√≥digo es mucho m√°s sencillo de entender cuando es rico en el uso de lenguaje humano. Es por eso que debemos cuidar los nombres que le asignamos a las variables, m√©todos y clases, ya que determinar√°n la dificultad para entender tu c√≥digo. Buscamos nombres coherentes con el contexto, pronunciables, que denoten claramente su comportamiento.\nComo bien indica el concepto anterior, crear abstracciones aporta sem√°ntica a nuestra aplicaci√≥n y denota la intenci√≥n de lo que programamos, podemos destacar tambi√©n evitar caer en primitive obsession, la cual nos habla de evitar el uso excesivo de tipos primitivos (como String, Integer\u0026hellip;) y en su lugar favorecer nuestros tipos propios, que ser√≠an esas clases que envuelven a los primitivos y les da una misi√≥n y un sentido, ya que tendr√°n un contexto basado en el nombre de la clase y el comportamiento (m√©todos) estar√° guiado por el mismo contexto. La utilizaci√≥n de tipos propios ayuda a que podamos desarrollar esa nueva feature m√°s r√°pido, porque con su utilizaci√≥n conseguimos un c√≥digo f√°cil de comprender e intuitivo.\nEl c√≥digo que usa correctamente los tipos propios habla el lenguaje del negocio para el que se est√° desarrollando la aplicaci√≥n, es decir, un lenguaje com√∫n para todos en la empresa, y favorecer√° la comunicaci√≥n entre desarrolladores y otros cargos de negocio. Por supuesto evita los modelos an√©micos, que ser√≠an aquellos objetos que no tienen datos o que los tienen, pero no los utilizan directamente porque exponen getters y setters y dejan que los dem√°s artefactos decidan qu√© debe hacer. En su lugar, p√≠dele al objeto que es el que tiene la responsabilidad de resolver ese problema que haga lo que quieres hacer, favorece el principio Tell don\u0026rsquo;t ask.\nPara tener un c√≥digo simple, un buen ejemplo a seguir ser√≠an las cuatro reglas del dise√±o simple definidas por Kent Beck:\nPasar los test Revelar la intenci√≥n No contener duplicidad (no repetir la implementaci√≥n de un concepto) Tener el menor n√∫mero de elementos posible (no hacer m√°s de lo necesario) Procura dise√±ar software con alta cohesi√≥n y bajo acoplamiento, es decir, busca crear artefactos independientes, que no dependan de otros para funcionar. Siempre existir√° un m√≠nimo de acoplamiento, ya que hay que conectar las distintas piezas de nuestro c√≥digo, pero evitar el acoplamiento excesivo har√° escalable nuestro c√≥digo. Implementar una arquitectura hexagonal puede ser muy beneficioso para que el dominio de nuestra aplicaci√≥n no tenga dependencias externas. La ley de demeter tambi√©n puede ser aplicada para evitar el acoplamiento. Para dise√±ar aplicaciones con alta cohesi√≥n y bajo acoplamiento es recomendable conocer los principios SOLID. Tambi√©n deber√≠amos limitar la visibilidad de m√©todos y clases, deber√≠amos ser conscientes de que aquello que marcamos como p√∫blico, solo deber√≠a ser lo realmente necesario.\nEl c√≥digo atractivo nos llama y nos resulta placentero a la hora de leerlo. Indentaciones bien realizadas, saltos de l√≠neas justos, mismo nivel de abstracci√≥n del c√≥digo dentro de un mismo bloque, y m√°s, son ejemplos de lo que podemos hacer para que nuestro c√≥digo se vea bonito y anime a interpretarlo. Usar cl√°usulas guarda es tan beneficioso para el rendimiento como para el aspecto visual, ya que denota claramente la intenci√≥n de un m√©todo para forzar la detenci√≥n de su ejecuci√≥n y devolver algo cuando se da alguna condici√≥n.\nEvita las sorpresas, piensa detenidamente cada decisi√≥n de dise√±o que tomes, ya que tendr√° un impacto en la persona que interprete despu√©s tu c√≥digo, que podr√≠as ser t√∫ mismo. Ten constructores que solo construyen, es decir, que no ejecuten ninguna l√≥gica compleja m√°s all√° de crear una instancia de la clase, si necesitas hacer validaciones del√©galas a m√©todos de factor√≠a y cierra la visibilidad del constructor. Favorece las funciones puras, aquellas que siempre retornan el mismo resultado para la misma entrada. Favorece el uso de las funciones propias de lenguaje, que en el caso de lenguajes modernos o de los m√°s veteranos, pero que suelen traer mejoras con cada actualizaci√≥n, muchas veces incluyen funcionalidades que facilitan la vida del programador y reducen la cantidad de trabajo que tiene que realizar para resolver un problema, al mismo tiempo que reducen la probabilidad de introducir un error, ya que evitan la complejidad accidental incluida por el programador. Si trabajas con lenguajes modernos aprovecha todas sus ventajas y no caigas en viejos principios divulgados por limitaciones del lenguaje o porque simplemente responden a un contexto del software en una √©poca donde lo correcto era eso, pero como en todo, siempre hay una forma de mejorar y surgen nuevos principios y patrones. Por ejemplo, hoy en d√≠a no se recomiendan que las funciones solo deban tener un √∫nico return. En realidad, si sabemos que nuestra funci√≥n ya tiene un valor para retornar y esperamos hasta el final de la ejecuci√≥n para retornarlo, nos estamos arriesgando a que mute su valor por el camino y no tengamos el resultado esperado, adem√°s aumentamos la probabilidad de un bug sin necesidad, ya que se ejecutan m√°s l√≠neas para obtener el mismo resultado. En su lugar, utilizar un return temprano ser√° mucho m√°s claro para los que lean el c√≥digo y ser√° m√°s seguro, un concepto que se conoce como cl√°usula guarda. Como este hay muchos otros principios que no aplican para el desarrollo de software m√°s habitual, solo es cuesti√≥n de detectarlos y aplicar la l√≥gica, y como no, nuestros conocimientos de c√≥digo sostenible, para evitarlos y tener un c√≥digo m√°s f√°cil de interpretar y de manejar.\nAunque tengamos una buena bater√≠a de test es necesario tener tambi√©n un buen manejo y prevenci√≥n de errores, algo que ocurre cuando tenemos en cuenta las posibles excepciones de nuestra aplicaci√≥n y las manejas de una forma inteligente, notific√°ndolas en un log de errores u otros sistemas de monitorizaci√≥n. Cuanto m√°s entiendes el lenguaje de programaci√≥n que est√° usando es m√°s complicado que puedas introducir un error, ya que eres m√°s consciente de cada cosa que realizas y qu√© riesgos puede tener. Utilizar un IDE para programar es lo mejor que puedes hacer, te resaltan zonas donde puedes mejorar el c√≥digo o zonas donde puede haber riesgo de error, adem√°s te autocompletan c√≥digo o lo sugieren para esos momentos en los que no tienes claro algo o simplemente te sirve para aumentar tu productividad. Para poder decir que tenemos una buena bater√≠a de test es necesario que pensemos en multitud de casos, todos los que se nos puedan ocurrir, para poder cubrir todos los escenarios posibles y que tengamos un c√≥digo resiliente. Para evitar el uso de excepciones a lo loco, tenemos disponibles lenguajes null safe como Kotlin, pero si t√∫ necesitas Java, por ejemplo, siempre tienes herramientas para usar en lugar de las excepciones, como los tipos Either y Try o el patr√≥n notificaci√≥n. Capt√∫ralas y envu√©lvelas en las tuyas propias para poder proporcionar informaci√≥n extendida y dar m√°s contexto de por qu√© se pudo dar ese error. Nunca a√±adas un \u0026rsquo;throws\u0026rsquo; a la firma de tus m√©todos, es ignorar totalmente la excepci√≥n y no tiene sentido.\nCuando queremos c√≥digo sostenible no todo es c√≥digo, ya que hay que cuidar otros aspectos que mejoran la calidad de nuestro trabajo, como puede ser la posibilidad de replicar los entornos productivos en uno local para poder solucionar r√°pidamente los bugs, hacer pairing para resolverlos, o incluso como forma de trabajo est√°ndar, por el hecho de que dos cabezas pueden pensar una soluci√≥n mejor y estudiar los riesgos minuciosamente.\nConclusi√≥n Hacer c√≥digo sostenible no es una tarea compleja, pero tampoco es f√°cil, es el fruto del cuidado diario de nuestro c√≥digo tomando buenas decisiones en cada momento, huyendo de la complejidad y la sorpresa. Por experiencia propia, lo realmente complicado es no seguir las gu√≠as de c√≥digo sostenible y tener que mantener ese c√≥digo, es un quebradero de cabeza m√°s grande que invertir nuestros esfuerzos en la aplicaci√≥n de c√≥digo sostenible. En definitiva, la f√≥rmula perfecta para que un c√≥digo sea mantenible, legible y escalable pasa por tener test suficientes y de calidad que cubran el c√≥digo productivo, y que tanto los test como el c√≥digo productivo sigan estos consejos que hemos aprendido con la lectura del libro y de este post.\n","date":"2022-07-07T00:00:00Z","image":"https://raulpadilladelgado.github.io/blog/p/c%C3%B3digo-sostenible/images/codigo-sostenible.png","permalink":"https://raulpadilladelgado.github.io/blog/p/c%C3%B3digo-sostenible/","title":"C√≥digo sostenible"},{"content":"Introducci√≥n Consumer driven contract testing es un tipo de prueba que nos garantiza que un proveedor cumple lo acordado con un consumidor. Por ejemplo, en una API usar√≠amos este tipo de pruebas para asegurar que el proveedor recibe una petici√≥n y devuelve la respuesta esperada.\nCuando dos artefactos se comunican entre s√≠, t√≠picamente lo suelen hacer mediante un mensaje, el cual tiene un formato determinado. Ese formato hace que el consumidor dependa del productor para poder funcionar correctamente, ya que su c√≥digo se ajusta a un determinado formato de mensaje. Ese ¬´acuerdo¬ª entre ambas partes es lo que se denomina ¬´contrato¬ª. Es entonces gracias a contract testing cuando podemos testear esa integraci√≥n y asegurarnos que el mensaje que se env√≠a de un artefacto a otro tiene el formato acordado para que la integraci√≥n entre ambos funcione a la perfecci√≥n.\nPero m√°s all√° de ser una herramienta para testear la integraci√≥n entre varios artefactos, tambi√©n lo podemos usar en el contexto de un √∫nico artefacto. V√©ase el caso de asegurar que una API cumple el formato acordado en su documentaci√≥n, pero en este caso sin hacer el enfoque en un tipo de consumidor concreto.\nHablamos de una herramienta que nos permite testear cualquier tipo de integraci√≥n de software, pero que ha tenido su auge en los √∫ltimos a√±os para HTTP e intercambio de mensajes entre microservicios.\nTipos de contrato Contrato expl√≠cito Cuando hablamos de un contrato expl√≠cito hacemos referencia al hecho de que el consumidor defina durante la ejecucci√≥n de sus test un archivo con la estructura del contrato que espera que se cumpla. Es entonces cuando dicho archivo se valida contra el que genera el proveedor, que lo crea de la misma forma, tras haber ejecutado sus propios test.\nLa clave de este tipo de contrato es que ambas partes hagan los test necesarios para asegurar que se cumple el contrato.\nDado que tanto proveedor como consumidor son de nuestro dominio, cuando queramos cambiar el contrato entre ambos, propagaremos el cambio cambiando el contrato en el proveedor y propagando el cambio en el consumidor para que ambos se equiparen con la nueva versi√≥n.\nContrato impl√≠cito El contrato impl√≠cito es muy similar al expl√≠cito, con la diferencia de que en este caso el proveedor no puede acoplarse al ciclo de test entre consumidor y proveedor. El caso m√°s t√≠pico de como puede ocurrir esto es el caso de una API p√∫blica. Podemos consumirla, pero ese proveedor como es ajeno y probablemente de soporte para otros muchos servicios no podemos hacer que cumpla un contrato expl√≠cito.\nEn su lugar, el archivo que genera nuestro consumidor mediante la ejecucci√≥n de los test esperando que se cumpla un contrato determinado se valida contra la salida de un de doble de test que simula ser el proveedor real. En este caso es importante que configuremos alg√∫n tipo de alerta que nos avisa cuando el proveedor real cambia su salida para que nosotros la actualicemos en nuestro proveedor falso. Recalcar que en este caso el falso proveedor se encuentra integrado dentro del mismo artefacto donde est√° el consumidor. El punto negativo de este m√©todo es que cuando el proveedor cambie el mensaje que publica, har√° que nuestro c√≥digo falle hasta que nuestra bater√≠a de test se lancen y se vuelva a comprobar que se cumple el contrato, algo que no se estar√≠a cumpliendo y por lo tanto tendr√≠amos que actualizar el contrato que espera nuestro consumidor.\nVentajas de Consumer Driven Contract Testing ¬øQu√© ganamos con el uso de una herramienta como esta? Pues evitamos que tener que hacer test end to end muy costosos para verificar que la integraci√≥n entre nuestros microservicios funciona correctamente. Nos ahorra mantener el entorno de ejecucci√≥n que levantamos para los test end to end. Recibimos feedback m√°s r√°pido.\nComo √∫nico problema de este tipo de contract testing es que representa un entorno simulado, mientras que un test end to end representa un entorno m√°s real, por lo que depende del caso seg√∫n el tipo de integraci√≥n que estemos intentando testear, puede que nos salga m√°s a cuenta para ir m√°s seguros a producci√≥n los test end to end, pero lo dicho, para una comunicaci√≥n b√°sica entre servicios basada en mensajes o v√≠a API sale muy rentable utilizar consumer driven contract testing.\nHerramientas para su uso Pact es una herramienta de prueba de contratos impulsada por el consumidor que genera contratos expl√≠citos mediante el uso de un doble de prueba que registra las solicitudes y las respuestas esperadas a un contrato que se denomina ¬´pacto¬ª, el \u0026lsquo;contrato\u0026rsquo; del que hablabamos anteriormente.\nDurante la ejecucci√≥n de los test del consumidor se realiza una solicitud al proveedor simulado de Pact que registra en el archivo del contrato junto con su respuesta esperada. Con esto hemos garantizado que desde el lado del consumidor se sigue cumpliendo el contrato. Tras esto, una simulaci√≥n del consumir que nos provee Pact vuelve a ejecutar una solicitud, pero esta vez contra el proveedor real y compara la respuesta actual con la esperada. Si la salida del consumidor simulado es igual a la real se cumple el contrato por parte del proveedor. Entonces, tras haberse cumplido el contrato por ambas partes nos hemos asegurado que nuestros dos servicios, proveedor y consumidor, se comunicar√°n correctamente en el entorno real, v√©ase producci√≥n.\nConsumer Driven Contract Testing + Continuous Integration/Continuous Deployment La guinda en el pastel es que automaticemos el uso de Contract Testing haciendo que se integre en nuestro CI/CD, asegur√°ndonos as√≠ que con cada build se ejecute y que nos permita deployar solo si el contrato se cumple. En el caso de que utilicemos Pact como nuestra herramienta para contract testing ser√° necesario configurar Pact Broker, una aplicaci√≥n para compartir contratos impulsados por el consumidor. Est√° optimizado para su uso con ¬´pactos¬ª (contratos creados por el framework Pact), pero puede utilizarse para cualquier tipo de contrato que pueda serializarse en JSON ¬øY qu√© ganamos usando esto? El Pact Broker permite desacoplar f√°cilmente el ciclo de lanzamiento de Consumer y Provider, unificando en un solo punto los resultado obtenidos y dem√°s informaci√≥n interesante sobre el pacto, como pueda ser documentaci√≥n entre otros detalles. Quiz√°s como √∫nico inconveniente es que Pact Brocker al ser Open Source es self hosting, por lo que otra alternativa puede ser Pactflow, un fork de Pact Broker que ofrece una serie de ventajas sobre su padre que las que podemos destacar que est√° pensada para equipos ofreciendo una mejor interfaz de usuario, almacenamiento a cargo de la aplicaci√≥n, una gran mejora en seguridad en lo que se refiera a inicio de sesi√≥n, y dem√°s features que se pueden seguir destacando.\nPara que puedas realizar o ver un ejemplo pr√°ctico te recomiendo seguir el workshop creado por la propia gente de Pactflow en el que detallan como realizar Consumer Driven Contract Testing e integrarlo con CI/CD. Ver el siguiente enlace: Pactflow Workshop - CI/CD\n","date":"2022-02-24T00:00:00Z","image":"https://raulpadilladelgado.github.io/blog/p/consumer-driven-contract-testing/images/cdct-no-bg.png","permalink":"https://raulpadilladelgado.github.io/blog/p/consumer-driven-contract-testing/","title":"Consumer Driven Contract Testing"},{"content":"Contexto CQRS son las siglas de Command and Query Responsibility Segregation, un patr√≥n que separa las operaciones de lectura y actualizaci√≥n para un almac√©n de datos.¬†La flexibilidad creada por la migraci√≥n a CQRS permite que un sistema evolucione mejor con el tiempo y evita que los comandos de actualizaci√≥n causen conflictos de fusi√≥n a nivel de dominio. Perfecto para aplicar en aplicaciones con gran carga de rendimiento.\nGracias a CQRS somo capaces de desacoplar la l√≥gica de nuestro sistema por acciones, y en los siguientes puntos veremos como trata de realizarlo.\nCommand En CQRS un command no es un comando de CLI aunque la palabra nos lleve a ello\nEn CQRS, un Command representa la intenci√≥n¬†de¬†realizar una operaci√≥n en nuestro sistema que acabe modificando el estado de tal. Mediante un command enviamos informaci√≥n a nuestro sistema para que este sea alterado.\nLos commands son DTO (Data Transfer Object) encargados de pedir modificaciones en el sistema mediante operaciones conocidas como Post, Put, Path, Delete. Un command no devuelve nada, por lo que el body de la respuesta estar√° vac√≠o.\nUn command es inmutable, y la raz√≥n es que si desde un controlador nos pasan un DTO (command) con una determinada informaci√≥n, y no tendr√≠a sentido que alteremos el objeto ya que ser√≠a modificar la tarea que nos han pedido.\nPodemos tener commands s√≠ncronos, para operaciones pocos costosos en tiempo de ejecucci√≥n y commands as√≠ncronos para las muy costosas.\nEl command acaba en un CommandHandler que tratar√° los datos como pueda ser crear Value Objects para poder realizar validaciones y asegurar que el command cumple con los requisitos del dominio, y seguidamente el CommandHandler enviar√≠a estos datos al caso de uso para que se encargue de ir al repositorio para modificar los registros pertinentes.\nQueries Una query en CQRS no es la tradicional query SQL a la que estamos acostumbrados.\nUna Query representa la intenci√≥n de pedir unos datos a nuestro sistema sin que ello acabe alterando el estado de tal.\nLas queries son DTO encargados de pedir informaci√≥n al sistema y que por consiguiente hacen que una respuesta vuelva a nosotros mediante la operaci√≥n conocida como Get.\nLa query acaba en un QueryHandler que tratar√° los datos como pueda ser crear Value Objects para poder realizar validaciones y asegurar que el command cumple con los requisitos del dominio, y seguidamente el QueryHandler enviar√≠a estos datos al caso de uso (servicio de aplicaci√≥n) para que se encarge de ir al repositorio para recuperar el v√≠deo, devolverlo y transformarlo en la respuesta esperada.\nCommands and Queries Bus Estos bus son las interfaces que act√∫an de intermediario entre los commands/queries y los Handler correspondiente. Saben a que Handler tienen que llevar seg√∫n el command o query que est√© llegando.\nSu misi√≥n principal es quitarle la responsabilidad al controlador de tener que saber a que handler tiene que enviar una command o query determinado.\nPara ver que ganamos mediante el uso de los buses vamos a ver la evoluci√≥n de una arquitectura m√°s tradicional a una que utiliza estos buses.\nEtapa 1) Post ‚û° Controller: En este caso realizamos una petici√≥n http tipo post al controlador, y este ser√° el encargado de realizar toda la l√≥gica. Es el caso tradicional m√°s extremo pero iremos iterando para ver las diferencias. En este caso si quisi√©ramos a√±adir otro tipo de punto de entrada a nuestra aplicaci√≥n distinto al controller (http), tendr√≠amos que copiar la l√≥gica de dicho controlador a el nuevo punto de entrada (ejemplo, un comando de terminal).\nEtapa 2) Post ‚û° Controller ‚û° Caso de uso: En este caso realizamos una petici√≥n http tipo post al controlador, y est√© conoce a que caso de uso (un servicio de nuestra aplicaci√≥n) debe dirigirse para que sea ejecutada la l√≥gica. En este caso si quisi√©ramos a√±adir otro tipo de punto de entrada a nuestra aplicaci√≥n distinto al controller (http), tendr√≠amos que apuntar al mismo caso de uso que utilizaba el controller desde el nuevo punto de entrada (ejemplo, un comando de terminal). Gracias a que tenemos la l√≥gica separada del controlador logramos reutilizaci√≥n de c√≥digo.\nEtapa final) Post ‚û° Controller ‚û° Instancia command (DTO) ‚û° CommandBus (interface) ‚û° CommandHandler ‚û° Caso de uso: En este caso realizamos una petici√≥n http tipo post al controlador, el cual instancia un command (DTO) que ser√° enviado al CommandBus, que es una interface de dominio que ser√° posteriormente implementada. El CommandBus sabe seg√∫n que tipo de command est√° recibiendo a que CommandHandler debe destinarse. En este caso si quisieramos a√±adir otro tipo de punto de entrada a nuestra aplicaci√≥n distinto del controller (http), tendr√≠amos instanciar del mismo modo el command deseado, y enviarlo al CommandBus para que este se destine al CommandHandler que toque. Adem√°s de ganar en reutilizaci√≥n de c√≥digo como hac√≠amos en el paso b, tambi√©n estamos desacoplando al controlador de conocer a que caso de uso debe dirigirse, simplemente pedir√° commands al CommandQuery, hacemos que los controladores que son algo que naturalmente son de infraestructura no conozcan como funciona nuestro dominio. Entonces si el d√≠a de ma√±ana queremos cambiar que se debe hacer con un tipo de command determinado, simplemente tendremos que cambiar la l√≥gica en el CommandHandler y as√≠ los N puntos de entrada a la aplicaci√≥n (controladores, comandos de terminal, etc) no necesitar√°n cambiar nada de su comportamiento. Previamente hemos comentado que el CommandBus es una interfaz que debe ser implementada, y esto nos da la posibilidad de crear una implementaci√≥n as√≠ncrona del CommandBus para que las peticiones no tengan que ser resultas en el mismo momento en el que se realizan, si no que se ir√°n procesando y se pasar√° la respuesta cuando est√© disponible.\nüí° En esta comparaci√≥n de dise√±o hemos hablado solo de los Command Bus, pero se aplica exactamente el mismo funcionamiento cuando se trate de una Query y su determinado Query Bus\nCQRS + Event Sourcing CQRS complementa la idea tradicional del Event sourcing de desacoplar nuestro c√≥digo lanzando eventos y que otro m√≥dulos de nuestra aplicaci√≥n se suscriban a tales eventos para interactuar con ellos. Por lo que vamos a ver como se acoplan estos dos patrones de dise√±os y nos brindan los mejor de ambos con el siguiente esquema:\nBefore (Only CQRS) cqrs After (CQRS + Event Sourcing) cqrs and eventsourcing Mitos y otras dudas Cuando estuve aprendiendo que era el CQRS me hice la pregunta de que si iba a necesitar dos bases de datos, una para el modelo de escritura y otro para el de lectura. En parte los contenidos que leia me llevaban a pensar eso, pero si lo pensamos bien, tendr√≠a sentido usar dos bases de datos que se sincronicen entre s√≠ solo si nuestra aplicaci√≥n lo requiere, es decir, que vayamos a tener que manejar un gran volumen de datos, y/o que sepamos que la consulta y modificaci√≥n puedan interferir entre s√≠, pero lo dicho, no es la regla general.\nPara m√°s dudas sobre CQRS dejo un enlace que me ha sido de gran ayuda: https://event-driven.io/en/cqrs_facts_and_myths_explained/\nEjemplo pr√°ctico Navegando por Github me encontr√© un buen ejemplo de la implementaci√≥n de CQRS + Event Sourcing utilizando Java, ver el siguiente enlace:\nJava-CQRS-Introducci√≥n\n","date":"2021-12-03T00:00:00Z","image":"https://raulpadilladelgado.github.io/blog/p/command-query-responsibility-segregation/images/CQRS.png","permalink":"https://raulpadilladelgado.github.io/blog/p/command-query-responsibility-segregation/","title":"Command Query Responsibility Segregation"},{"content":"Introducci√≥n Este post tiene como objetivo mostrar una serie de trucos o tips sobre Java que no son m√°s que nuevan funcionalidades que han ido saliendo con el paso de los a√±os y que hoy recojo aqu√≠ con la intenci√≥n de mostrar las m√°s √∫tiles y ejemplos de uso. Pertenece a una serie de post que siguen el mismo objetivo, puedes buscar en blog los dem√°s post.\nTry with resources Desde Java 7 existe la f√≥rmula try-with-resources que permite vincular el cerrado de recursos a la conclusi√≥n del try, de modo que no se nos olvide hacerlo manualmente.\n// Con finally String line = null; BufferedReader br = new BufferedReader(new FileReader(\u0026#34;myfile\u0026#34;)); try { line = br.readLine(); } catch (Exception e) { e.printStackTrace(); } finally { if (br != null) br.close(); } // Con try-with-resources String line = null; try (BufferedReader br = new BufferedReader(new FileReader(\u0026#34;myfile\u0026#34;))) { line = br.readLine(); } catch (Exception e) { e.printStackTrace(); } Como se puede observar, definimos los recursos que deben ser cerrados autom√°ticamente despu√©s del try y entre par√©ntesis. Podemos incluir varios recursos separ√°ndolos por punto y coma. Al escribirse de esta forma se llamar√° al m√©todo close del BufferedReader al acabar la ejecuci√≥n del bloque, se produzcan errores o no.\nTodos los recursos que se utilicen dentro de un try-with-resources deben implementar la interfaz AutoCloseable, la cual tiene un √∫nico m√©todo close que define c√≥mo se debe cerrar el recurso.\nFechas LocalDateTime, LocalTime, LocalDate, TimePoint LocalDateTime timepoint = LocalDateTime.now(); // Fecha y hora actual LocalDate date = LocalDate.of(2020, Month.JULY, 27); // Obtenemos la fecha indicada LocalTime.of(17, 30); // Obtenemos la hora indicada LocalTime.parse(\u0026#34;17:30:00\u0026#34;); // Otra forma para la hora Month month = timepoint.getMonth(); //Obtener el mes actual int day = timepoint.getDayOfMonth(); //Obtener el n√∫mero de d√≠a de actual // TimePoint es inmutable, as√≠ que cambiar el valor retorna un nuevo objeto y podemos realizar un desarrollo m√°s funcional LocalDateTime happyTwenties = timepoint.withYear(1920) .withMonth(Month.January) .withDayOfMonth(1) .plusWeeks(3); Formateado de fechas Date date = new Date(); // Fecha actual SimpleDateFormat df = new SimpleDateFormat(\u0026#34;dd-MM-yyyy\u0026#34;); String date = df.format(date); //Formato final de la fecha en String Gen√©ricos El t√©rmino ‚ÄúGeneric‚Äù viene a ser como un tipo parametrizado, es un tipo de dato especial del lenguaje que permite centrarnos en el algoritmo sin importar el tipo de dato espec√≠fico que finalmente se utilice en √©l. Muchos algoritmos son los mismos, independientemente del tipo de dato que maneje. Por ejemplo, un algoritmo de ordenaci√≥n.\nSe llaman parametrizados porque el tipo de dato con el que opera la funcionalidad se pasa como par√°metro. Pueden usarse en clases, interfaces y m√©todos, denomin√°ndose clases, interfaces o m√©todos gen√©ricos respectivamente. En Java, la declaraci√≥n de un tipo gen√©rico se hace entre s√≠mbolos \u0026lt;\u0026gt;, pudiendo definir uno o m√°s par√°metros, por ejemplo: , \u0026lt;K, V\u0026gt;. Existe una convenci√≥n a la hora de nombrarlos:\nE ‚Äì Element (usado bastante por Java Collections Framework). K ‚Äì Key (usado en mapas). N ‚Äì Number (para n√∫meros). T ‚Äì Type (representa un tipo, es decir, una clase). V ‚Äì Value (representa el valor, tambi√©n se usa en mapas). S, U, V etc. ‚Äì usado para representar otros tipos Ejemplo de clase gen√©rica\n// GenericClass.java file public class GenericClass\u0026lt;T, K\u0026gt; { private T g1; private K g2; public GenericClass(T g1, K g2) { this.g1 = g1; this.g2 = g2; } public T getGenericOne() { return g1; } public K getGenericTwo() { return g2; } } // Main.java file public class Main{ public static void main(String[] args) throws Exception { GenericClass\u0026lt;Integer, String\u0026gt; clazz = new GenericClass\u0026lt;\u0026gt;(1, \u0026#34;generic\u0026#34;); Integer param1 = clazz.getGenericOne(); String param2 = clazz.getGenericTwo(); System.out.println(String.format(\u0026#34;Param1 %d - Param2 %s\u0026#34;, param1, param2)); } } Ejemplo de m√©todo gen√©rico\n// WhiteBoard.java file public class WhiteBoard { public \u0026lt;T\u0026gt; void draw(T figure ) { ... } } // Main.java file public static void main(String[] args) throws Exception { WhiteBoard board = new WhiteBoard(); Figure circle = new Circle(1.5); board.draw(circle); } Interfaces funcionales En Java, se considera interfaz funcional a toda interfaz que contenga un √∫nico m√©todo abstracto. Es decir, interfaces que tienen m√©todos est√°ticos o por defecto (default) seguir√°n siendo funcionales si solo tienen un √∫nico m√©todo abstracto.\nEjemplo:\n@FunctionalInterface public interface SalaryToPrettyStringMapper { default List\u0026lt;String\u0026gt; map(List\u0026lt;Salary\u0026gt; list) { return list.stream() .map(this::map) .collect(Collectors.toList()); } String map(Salary salary); } La anotaci√≥n @FunctionalInterface denota que es una interfaz funcional, pero es opcional y, aunque no estuviese, la interfaz seguir√≠a siendo funcional. Ser√≠a buena pr√°ctica mantenerla para recordar que se trata de una interfaz funcional (no de una clase abstracta), y que en caso de a√±adir m√°s m√©todos nos lanzar√≠a un error de compilaci√≥n.\nLambdas Las lambdas fueron introducidas a partir de Java 8. No son m√°s que funciones an√≥nimas que nos permiten programar en Java con un estilo m√°s funcional y, en ocasiones, declarativo.\nLa sintaxis de una lambda es la siguiente:\n( tipo1 param1, tipoN paramN) -\u0026gt; { cuerpo de la lambda } El operador flecha (-\u0026gt;), es caracter√≠stico de las lambda y separa los par√°metros del cuerpo de la funci√≥n. No es necesario incluir el tipo ya que este puede ser inferido. El par√©ntesis de los par√°metros puede omitirse cuando s√≥lo existe un par√°metro y no incluimos el tipo. Si no hay par√°metros los par√©ntesis son necesarios.\n(param1, param2) -\u0026gt; { cuerpo } param1 -\u0026gt; { cuerpo } () -\u0026gt; { cuerpo } En el caso del cuerpo, si solo tenemos una sentencia, podremos omitir las llaves y el return, por ejemplo:\nnumero -\u0026gt; String.valueOf(numero) Si tenemos m√°s de una, las llaves ser√°n necesarias:\nnumero -\u0026gt; { String cadena = String.valueOf(numero); return cadena; } ¬øDonde usar las lambdas? Las lambdas se pueden usar en cualquier parte que acepte una interfaz funcional. La lambda tendr√° que corresponder con la firma del m√©todo abstracto de la interfaz funcional.\nSe pueden asignar a variables tipadas:\nPredicate\u0026lt;Integer\u0026gt; isOdd = n -\u0026gt; n % 2 != 0; isOdd.test(2); // false Pueden ser parte del return de un m√©todo:\nprivate Predicate\u0026lt;Integer\u0026gt; isOddPredicate() { return n -\u0026gt; n % 2 != 0; } En llamadas a m√©todos:\nIntStream.range(0, 2) .mapToObj(entero -\u0026gt; String.format(\u0026#34;entero = %s\u0026#34;, entero)) .forEach(cadena -\u0026gt; System.out.println(cadena)); // Salida: // entero = 0 // entero = 1 Referencias a m√©todos Cuando un m√©todo coincida con la firma de una interfaz funcional, podremos usar una referencia al m√©todo en vez de la sintaxis habitual de las lambdas\nIntStream.range(0, 2) .mapToObj(entero -\u0026gt; String.format(\u0026#34;entero = %s\u0026#34;, entero)) .forEach(System.out::println); // \u0026lt;- Referencia a m√©todo Para usar referencias a m√©todos, ponemos (::) justo antes del m√©todo, en vez de un punto, e ignoramos los par√©ntesis. As√≠ pues, estas podr√≠an ser referencias v√°lidas a m√©todos:\nSystem.out::println this::miMetodo super::metodoDeSuper unObjeto::suMetodo Data processing Streams Desde Java 8 podemos hacer uso de estas herramientas para simplificar la forma en la que interactuamos con las colecciones, evitando que tengamos que realizar bucles complejos. Nos permiten hacer operaciones paralelizables, concatenando instrucciones con un estilo declarativo.\nPara utilizarlas sera necesario llamar a stream() o parallelStream(), en funci√≥n de si queremos paralelizar las operaciones o no.\nUn stream simplemente recibe los datos de una colecci√≥n y genera un resultado tras el procesado de las operaciones intermedias. Estas operaciones intermedias devuelven un stream, por lo que ser√° necesario ejecutar una operaci√≥n terminal para que las intermedias se ejecuten y poder obtener un resultado.\nUn ejemplo para verlo m√°s claro:\nList\u0026lt;Other\u0026gt; l2 = l1.stream() .filter(elem -\u0026gt; elem.getAge() \u0026lt; 65) .sorted() // Ordena seg√∫n la implementaci√≥n de Comparable .map(elem -\u0026gt; new Other(elem.getName,() elem.getAge())) .collect(toList()); En el ejemplo anterior hemos visto algunas operaciones intermedias como son filter(), entre otras, y a dem√°s el bloque de instrucciones termina con un collect(), que se trata de una operaci√≥n terminal que nos permite pasarle un par√°metro de tipo Collector, y que en este caso con el toList() conseguimos que se nos devuelva una lista como ten√≠amos al principio.\nLas operaciones intermedias se pueden clasificar en:\nFIltrado B√∫squeda Mapeado Matching Reducci√≥n Iteraci√≥n Los streams pueden ser utilizados para m√°s prop√≥sitos, como pueda ser un array:\nint[] array = {1, 2, 3, 4, 5}; int sum = Arrays.stream(array).sum(); O para convertir un fichero en un stream de l√≠neas:\nlong numberOfLines = Files.lines( Paths.get(\u0026#34;yourFile.txt\u0026#34;), Charset.defaultCharset() ).count(); Tambi√©n se pueden crear Stream a partir de valores usando Stream.of\nOptional A partir de Java 8 tenemos implementado en Java el patr√≥n option. Se basa en indicar que se puede devolver o no el valor esperado obligando a que tengamos contemplados ambos escenarios.\nLa clase Optional en Java nos dispone de constructor, en su lugar usaremos sus m√©todos de factor√≠a est√°ticos para crear los optional. Veamos:\npublic static \u0026lt;T\u0026gt; Optional\u0026lt;T\u0026gt; empty() //Devuelve objeto opcional vac√≠o public static \u0026lt;T\u0026gt; Optional\u0026lt;T\u0026gt; ofNullable(T value) //Devuelve objeto con valor o si es null un objeto vac√≠o public static \u0026lt;T\u0026gt; Optional\u0026lt;T\u0026gt; of(T value) //Devuelve objeto con valor o si es null retorna NullPointerException La clase Optional nos proporciona una serie de m√©todos:\npublic boolean isPresent() //Indica si el objeto tiene o no valor public T get() //Retorna el valor almacenado. Si no hay valor retorna excepci√≥n public Optional\u0026lt;T\u0026gt; filter(Function f) //Comportamiento como con los streams public \u0026lt;U\u0026gt; Optional\u0026lt;U\u0026gt; map(Function f) //Comportamiento como con los streams public \u0026lt;U\u0026gt; Optional\u0026lt;U\u0026gt; flatMap(Function f) //Comportamiento como con los streams public T orElse(T other) //Nos retorna el valor original. Si es nulo, retorna el valor que pasamos por par√°metro public T orElseGet(Function f) //Igual que el anterior pero el par√°metro es una funci√≥n public \u0026lt;X extends Throwable\u0026gt; T orElseThrow(Function f) //Retorna el valor original. Si es nulo, retorna la excepci√≥n que devuelva la funci√≥n pasada como par√°metro ","date":"2021-11-19T00:00:00Z","image":"https://raulpadilladelgado.github.io/blog/p/java-moderno-cap%C3%ADtulo-1/images/java.png","permalink":"https://raulpadilladelgado.github.io/blog/p/java-moderno-cap%C3%ADtulo-1/","title":"Java Moderno (Cap√≠tulo 1)"},{"content":"Introducci√≥n En nuestras aplicaciones Python solemos hacer uso de librer√≠as, y las diferentes versiones de estas pueden llegar a ser un quebradero de cabeza cuando son usadas desde varias aplicaciones. Adem√°s de las librer√≠as, la propia instalaci√≥n de Python tiene un sistema de versionado, por lo que nos ocurre el mismo problema. Una aplicaci√≥n A no funciona con Python 3.8 pero la aplicaci√≥n B lo necesita.\nLa soluci√≥n a este problema es usar un entorno virtual, que es un √°rbol de directorios aut√≥nomo que contiene una instalaci√≥n de Python con una versi√≥n concreta, adem√°s de una serie de paquetes adicionales que queramos instalar.\nDiferentes aplicaciones pueden usar diferentes entornos virtuales. Si una aplicaci√≥n A necesita una versi√≥n 1.0 de un paquete y otra aplicaci√≥n B la versi√≥n 2.0 no tendr√°n conflictos ya que dentro de cada aplicaci√≥n habr√° un entorno virtual (carpeta) que contenga sus propias instalaciones. Por lo que si dentro de una aplicaci√≥n B se quiere usar la versi√≥n m√°s nueva del paquete 3.0, la aplicaci√≥n A seguir√° usando la versi√≥n 1.0 y no se ver√° afectada. No es estrictamente necesario que el entorno virtual (carpeta) est√© dentro del proyecto en cuesti√≥n, pero si suele ser una recomendaci√≥n a la hora de buscar organizaci√≥n y no tener los entornos virtuales desperdigados por el sistema de archivos de nuestra m√°quina.\nAdem√°s de solucionar problemas entre las versiones de distintos proyectos, usar entornos virtuales nos permite poder aislar nuestro sistema (PC) de tener que instalar globalmente todas las dependencias que tiene un proyecto, por lo que cuando borremos el proyecto no tendremos todas esas dependencias instaladas en nuestra m√°quina.\nEntornos virtuales desde terminal Crear entornos virtuales El m√≥dulo de python que permite crear y manejar entornos virtuales se llama venv. Para crear un entorno virtual ejecuta dentro de un directorio:\npython3 -m venv tutorial-env python3: por defecto se instalara dentro del entorno virtual la misma versi√≥n de python que tengamos instalada en el sistema -m: Indicamos que vamos a introducir el nombre de un m√≥dulo de python venv: Es el m√≥dulo de python que nos permite crear y manejar entornos virtuales tutorial-env: Es el nombre que le queramos dar al entorno virtual Una vez creado el entorno virtual procederemos a activarlo, que har√° que nuestra terminal tenga el contexto de ese entorno virtual y acceder√° a los paquetes instalados dentro en lugar de usar la de nuestro sistema.\nEn windows ejecuta:\ntutorial-env\\Scripts\\activate.bat En Unix (Linux) o MacOS ejecuta:\nsource tutorial-env/bin/activate üí° Si usas otra terminal distinta al bash tienes implementaciones distintas del script de activaci√≥n como por ejemplo para csh (activate.csh) o fish (activate.fish)\nActivar el entorno virtual har√° que cambie el prompt de tu terminal para que muetre que entorno virtual se est√° usando.\nraul@DESKTOP:~/env-example$ source tutorial-env/bin/activate (tutorial-env) raul@DESKTOP:~/env-example$ python3 Python 3.8.10 (default, Sep 28 2021, 16:10:42) [GCC 9.3.0] on linux Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; Instalar paquetes dentro del entorno virtual Dentro de nuestro entorno virtual tambi√©n podemos instalar, actualizar y eliminar paquetes usando el ejecutable pip.\nüí° Pip buscar√° los paquetes en la p√°gina¬†https://pypi.org\nPara instalar la √∫ltima versi√≥n de un paquete ejecutaremos:\n(tutorial-env) raul@DESKTOP:~/env-example$ python3 -m pip install novas (tutorial-env) ‚áí nos muestra que el entorno virtual est√° activado. Para realizar la instalaci√≥n de un paquete python dentro del entorno virtual es necesario que lo tengamos activado primero. python3 -m ‚áí Indicamos que vamos a introducir el nombre de un m√≥dulo de python, en este caso pip. install ‚áí Para instalar el paquete novas ‚áí nombre del paquete Y si quisieras instalar una versi√≥n espec√≠fica de un paquete lo podemos realizar concatenando los signos == y la versi√≥n del paquete:\n(tutorial-env) raul@DESKTOP:~/env-example$ python3 -m pip install requests==2.6.0 Para actualizar el paquete ejecutar√≠amos un install a√±adiendo el par√°metro \u0026ndash;upgrade al comando:\n(tutorial-env) raul@DESKTOP:~/env-example$ python3 -m pip install --upgrade requests Para instalar uno o varios paquetes pon sus nombres despu√©s de pip uninstall\nPara mostrar informaci√≥n sobre un paquete en particular pon su nombre despu√©s de pip show\nPara listar todos los paquetes instalados en el entorno virtual podemos ejecutar pip list\nPara listar todos los paquetes instalados y adem√°s guardar la salida del comando en un fichero de texto que tenga un formato preparado para que instalar todas las versiones a la vez desde pip ejecuta:\n(tutorial-env) raul@DESKTOP:~/env-example$ python3 -m pip freeze \u0026gt; requirements.txt (tutorial-env) raul@DESKTOP:~/env-example$ cat requirements.txt novas==3.1.1.3 numpy==1.9.2 requests==2.7.0 freeze ‚áí Similar al list pero expulsa la salida en un formato compatible con la instalaci√≥n masiva de todos los paquetes que contiene requirements.txt ‚áí Redirigir la salida al archivo especificado. El nombre no tiene que ser exactamente el del ejemplo, pero suele ser un est√°ndar usar ese nombre. Ejemplo de diferencias entre list y freeze\nLIST novas (3.1.1.3) numpy (1.9.2) requests (2.7.0) FREEZE novas==3.1.1.3 numpy==1.9.2 requests==2.7.0 El fichero requirements.txt debe ser guardado mediante el control de versiones para que cualquier usuario que se baje el proyecto pueda instalar todas las dependencias necesarias utilizando:\n(tutorial-env) raul@DESKTOP:~/env-example$ python3 -m pip install -r requirements.txt -r ‚áí Indica que las dependencias est√°n especificadas en un archivo que vamos a pasar Entornos virtuales desde IntelliJ IDEA Ultimate o PyCharm Previamente hemos visto como manejar los entornos virtuales desde terminal, pero en alg√∫n momento tendr√≠amos que abrir nuestro proyecto desde un IDE, y en este caso explicar√© como manejar los entornos virtuales dentro de los IDEs de Jetbrains.\nRequisitos:\nSi vas a utilizar IntelliJ (Ultimate) en lugar de PyCharm es necesario que tengas instalado el plugin de Python. Lo puedes instalar desde los ajustes del IDE (Ctrl + Alt + S) Se recomienda instalar el plugin ‚ÄúRequirements‚Äù para poder manejar de una forma m√°s c√≥moda y m√°s asistida los requirimientos dentro del proyecto Crear un entorno virtual Para crear un entorno virtual desde el IDE abriremos los ajustes de la estructura del proyecto (Ctrl + Shift + Alt + S) y a√±adiremos un nuevo SDK de Python\nBase interpreter: En caso de que no tengamos Python instalado en nuestra m√°quina el IDE nos ofrecer√° descargar una versi√≥n. Si ya lo tenemos instalado lo autodetectar√°, pero tambi√©n podemos indicar una ruta donde est√© Python instalado.\nInherit global site-packages: Nos incluir√° dentro del entorno virtual todos los paquetes que tengamos instalados. Se recomienda deshabilitar si globalmente tenemos muchas dependencias que no sean de necesidad para el proyecto. Corresponde con el par√°metro -system-site-packages de virtualenv.\nMake available to all projects: El IDE guardar√° el entorno virtual para que pueda ser usado en otro proyectos. Act√≠valo si sabes que las dependencias de tu proyecto ser√°n las mismas en alg√∫n otro proyecto.\nUsar un entorno virtual existente Para usar un entorno virtual existente desde el IDE abriremos los ajustes de la estructura del proyecto (Ctrl + Shift + Alt + S) y a√±adiremos un SDK de Python\nInterpreter: Indicaremos la ruta donde est√° instalado Python dentro del entorno virtual\nMake available to all projects: El IDE guardar√° el entorno virtual para que pueda ser usado en otro proyectos. Act√≠valo si sabes que las dependencias de tu proyecto ser√°n las mismas en alg√∫n otro proyecto.\nIncluir las dependencias del archivo requirements Con el plugin ‚ÄúRequirements‚Äù instalado en pasos anteriores podremos instalar los paquetes necesarios dentro del archivo requirements.txt\nPara sincronizar las dependencias que est√°n instaladas en el entorno virtual y lo que tenemos definido en el archivo requirements.txt en la barra superior del IDE pulsamos sobre ‚ÄúTools‚Äù y elegimos la opci√≥n ‚ÄúSync Python Requirements‚Ä¶‚Äù\nUntitled 7 Entornos virtuales en proyectos versionados Un entorno virtual no se versiona junto con el proyecto, recordemos que esa carpeta tiene multitud de instalaciones de paquetes de Python y que estar√≠amos a√±adiendo una carpeta de mucho peso en el sistema de versionado. El proceso que debemos seguir para recrear el entorno virtual cuando nos bajamos un proyecto de Python es:\nCrear un entorno virtual nuevo Instalar las dependencias que est√°n especificadas en el archivo requierements.txt del proyecto ","date":"2021-11-13T00:00:00Z","image":"https://raulpadilladelgado.github.io/blog/p/entornos-virtuales-en-python/images/cabecerapythonvirtualenv.jpg","permalink":"https://raulpadilladelgado.github.io/blog/p/entornos-virtuales-en-python/","title":"Entornos virtuales en Python"},{"content":"Introducci√≥n SSH o Secure Shell Protocol, es un protocolo de comunicaci√≥n as√≠ como pueda serlo los muy conocidos HTTP, HTTPS o FTP.\nEn el caso de SSH nos permite la comunicaci√≥n entre dispositivos dentro de la red, as√≠ como controlar o modificar ordenadores remotos.\n¬øQue ofrece de nuevo entonces frente a otros protocolos de comunicaci√≥n? Pues b√°sicamente es un protocolo orientado a mejorar la seguridad de la comunicaciones encriptando los datos de modo que intrusos no puedan ver contenido protegido bajo el protocolo.\nHTTPS puede sonar parecido a SSH, ambos son seguros y permiten la comunicaci√≥n, pero la diferencia est√° en que HTTPS est√° pensado para la web y SSH para la shell (l√≠nea de comandos que usa desde un sistema operativo).\nSSH pretende encriptar las comunicaciones entre cliente (dispositivo que se conecta al host) y host (servidor remoto al que accede el cliente)\nLas conexiones SSH est√°n muy presentes en nuestro d√≠a a d√≠a. En el caso de github utilizamos SSH para clonar, hacer push o hacer pull a sus servidores.\nComo funciona la encriptaci√≥n de SSH Existen tres tipos principales de t√©cnicas de encriptaci√≥n usadas por SSH:\nEncriptaci√≥n sim√©trica Encriptaci√≥n asim√©trica Hash Encriptaci√≥n sim√©trica El ordenador A quiere mandarle al ordenador B un mensaje del estilo \u0026ldquo;hola, que tal?\u0026rdquo;, pero el ordenador A no quiere que nadie se entere de lo que est√° diciendo. Entonces utilizar√° una \u0026ldquo;llave\u0026rdquo; para alterar su mensaje y el \u0026ldquo;hola, que tal?\u0026rdquo; pasar√° a ser por ejemplo \u0026ldquo;EK25+5\u0026rdquo;. El ordenador B tambi√©n tiene esa \u0026ldquo;llave\u0026rdquo;, por lo que es capaz de descifrar el mensaje alterando el mensaje cifrado para recuperar el original.\nAs√≠ funciona el cifrado sim√©trico, quien tenga la llave es capaz de descifrar lo que se est√° transfiriendo.\nLa llave que conocen ambas partes de la comunicaci√≥n no puede viajar a trav√©s de la red, ya que un atacante podr√≠a estar espiando y conseguir una copia de la llave, por lo que tambi√©n podr√≠a descifrar la informaci√≥n que enviemos bajo el uso de dicha llave. Para evitar que la llave viaje de forma insegura se utiliza un algoritmo de intercambio de claves. Ser√≠a algo as√≠ como definir un algoritmo para que la llave pueda viajar por la red de forma segura ya que estar√° cifrada y la forma de descrifrarlo solo la conocen ambas partes interesadas en la comunicaci√≥n. Esto ser√° el siguiente punto que tratemos, la encriptaci√≥n asim√©trica.\nEncriptaci√≥n asim√©trica Para la encriptaci√≥n asim√©trica se utilizan dos llaves en ambas partes de la comunicaci√≥n. Cada parte tiene una llave p√∫blica y una llave privada. Las claves p√∫blicas pueden ser compartidas con todo el mundo, no supone un riesgo para nuestra seguridad. Sin embargo, las claves privadas deben permanecer en secreto y no compartirlas con nadie. La clave p√∫blica est√° relacionada con una clave privada en t√©rmino de funcionaliadad, aunque compartir la clave p√∫blica es seguro porque a partir de esta no es posible calcular la clave privada. Esto quiere decir que un mensaje que fue encriptado usando una clave p√∫blica, solo podr√° ser desencriptado utilizando su respestiva clave privada.\nEl ordenador A y el ordenador B intercambian sus claves p√∫blicas. El ordenador A encripta un mensaje utilizando la clave p√∫blica del ordenador B, env√≠a el mensaje y finalmente el ordenador B utiliza su propia clave privada para desencriptar el mensaje\ndiffie hellman key exchange ‚ÄéEl algoritmo de intercambio de claves Diffie Hellman (DH) es un m√©todo para intercambiar de forma segura claves criptogr√°ficas a trav√©s de un canal de comunicaciones p√∫blico. Las claves no se intercambian realmente, se derivan conjuntamente. Lleva el nombre de sus inventores Whitfield Diffie y Martin Hellman.‚Äé Mejora el intercambio de claves que hemos visto anteriormente en la encriptaci√≥n sim√©trica y asim√©trica utilizando c√°lculo matem√°ticos avanzados para que sea pr√°cticamente imposible que un intruso en la comunicaci√≥n sea capaz de descifrar la clave que permite acceder a los recursos.\nEjemplo\n‚ÄéSi Alice y Bob desean comunicarse entre s√≠, primero acuerdan entre ellos un gran n√∫mero primo n y un generador (o base) g (donde 0 \u0026lt; g \u0026lt; n).‚Äé\n‚ÄéAlice elige un entero secreto a (su clave privada) y luego calcula g^a mod n (que es su clave p√∫blica). Bob elige su clave privada b y calcula su clave p√∫blica de la misma manera.‚Äé\n‚ÄéBob conoce b y g^a, por lo que puede calcular (g^a)^b mod n = g^ab mod n. Por lo tanto, tanto Alice como Bob conocen un secreto compartido g^ab mod n. Eva, una oyente maliciosa en la comunicaci√≥n conoce n, g, la clave p√∫blica de Alice (g^a mod n) y la clave p√∫blica de Bob (g^b mod n). Ella es incapaz de calcular el secreto compartido a partir de estos valores, ser√≠a necesario conocer la clave privada.\nHash Con esto ganamos que ning√∫n intermediario malicioso se meta en la comunicaci√≥n y suplante la identidad del host y del cliente aportando su propia clave p√∫lica para as√≠ poder descifrar los mensajes.\nEs una t√©cnica de encriptaci√≥n en la que para la mismta entrada (texto) siempre se produce la misma salida (texto encriptado). Desde el texto encriptado utilizando hash no ser√≠amos capaces de llegar al texto como era en el inicio. Entonces solo la persona que sabe el secreto volver√° a introducir la misma entrada y esta vez el servidor comprobara que se registra el mismo hash que guard√≥ al principio, en caso de ser as√≠, la persona estar√≠a autorizada.\nCon esta t√©nica se requiere una entrada segura, por ejemplo, si hablamos de contrase√±as, una del estilo \u0026ldquo;1234\u0026rdquo; seguramente sea de las primera que prueban los atacantes, sin embargo, recurrir a algo m√°s elaborado como \u0026ldquo;d56fg4583+*dfh347vfh\u0026rdquo; seguro que no ser√° f√°cil de adivinar.\nEjemplo\nEl comando md5sum imprime una suma de comprobaci√≥n de 32 caracteres (128 bits) del archivo dado, utilizando el algoritmo MD5.\nVamos a abrir una terminal UNIX y usaremos el comando md5sum para crear y comparar hashes entre ficheros:\nDos ficheros iguales, mismo hash\n$ cat file1.txt\nhello world\n$ cat file2.txt\nhello world\n$ md5sum file1.txt\n6f5902ac237024bdd0c176cb93063dc4 file1.txt\n$ md5sum file2.txt\n6f5902ac237024bdd0c176cb93063dc4 file2.txt\nDos ficheros distintos, distinto hash:\n$ cat file1.txt\nhello world\n$ cat file2.txt\nbye bye\n$ md5sum file1.txt\n6f5902ac237024bdd0c176cb93063dc4 file1.txt\n$ md5sum file2.txt\nb052b28f8360616ca92f434f497585ff file2.txt\nComprobaci√≥n masiva de hashes:\n$ cat file1.txt\nhello world\n$ cat file2.txt\nbye bye\n$ md5sum file1.txt file2.txt \u0026gt; hashes\n$ md5sum \u0026ndash;check hashes\nfile1.txt: OK\nfile2.txt: OK\n$ echo \u0026ldquo;!\u0026rdquo; \u0026raquo; file2.txt\n$ md5sum \u0026ndash;check hashes\nfile1.txt: OK\nfile2.txt: FAILED\nmd5sum: WARNING: 1 computed checksum did NOT match\nComo configurar claves publicas en un servidor Ubuntu para conectar mediante SSH Usando un proveedor de servidores como pueda ser Digital Ocean, vamos a crear un servidor ubuntu para accederlo v√≠a SSH.\nTras haberlo creado vamos a escribir el siguiente comando en nuestro terminal para conectarnos al servidor que se encuentra en internet:\nssh {user}@{host}\nSiendo user el usuario (cuenta) por defecto que nos ha creado el servidor para acceder y host el servidor al que queremos acceder, en ese campo podremos escribir una direcci√≥n IP o un nombre de dominio.\nVeremos que estamos conectado desde la shell al servidor, por lo que podemos acceder a su sistema de archivos, ejecutar comandos, etc.\nVamos a utlizar RSA, que nos permitir√° garantizar la identificaci√≥n de los usuarios sin necesidad de utlizar una contrase√±a.\nDesde la consola de nuestro ordenador local vamos a generar un par de claves (p√∫blica y privada) para utilizarlas posteriormente con el servidor.\nssh-keygen -C \u0026ldquo;test@gmail.com\u0026rdquo;\n-C Comment Provides a new comment Tras esto nos pedir√° donde queremos las claves. Por defecto lo har√° en la ruta /Users/{your_user}/.ssh/id_rsa si solo presionamos enter, pero podemos especificar nosotros la ruta y el nombre de la clave privada tambi√©n.\nNos iremos al servidor y nos conectaremos v√≠a ssh. Nuestro proveedor de servidor no deber√≠a tener configurado por defecto el acceso mediante SSH solo para determinados usuarios, por lo que en teor√≠a podr√≠amos acceder en este momento con cualquier usuario.\nssh {user}@{host}\nY vamos a crear el folder .ssh en la ruta principal del usuario:\nmkdir .ssh\nDentro de la ruta .ssh crearemos un archivo que se nombre exactamente authorized_keys, en donde pegaremos el contenido generado de la clave p√∫blica generada anteriormente.\nTras haber realizado lo anterior cuando queramos conectarnos al servidor v√≠a ssh veremos que esta vez lo ha intentado mediante la public key pero ha fallado porque no podr√° escoger correctamente la key, la que hemos copiado dentro del servidor\nPara a√±adir la clave que nos interesa al comando ssh, tendremos que ejecutar lo siguiente :\nssh-add ~/.ssh/{your_private_key}\nadds private key identities to the authentication agent\nY ahora s√≠ que si volvemos a conectarnos v√≠a ssh podremos haber accedido al servidor sin necesidad de introducir una contrase√±a, ya que este conoc√≠a nuestra clave p√∫blica y nos ha mando un mensaje de verificaci√≥n de identidad que hemos sabido descrifrar ya que fue cifrado con nuestra clave p√∫blica que solo se puede descifrar con nuestra clave privada.\nPara eliminar las claves que tiene el authentication agent:\nssh-add -D\nPara listar las claves que tiene el authentication agent:\nssh-add -l\nComo configurar SSH en Github Lo primero ser√° abrir la terminal y generar la clave p√∫blica que a√±adiremos posteriomente en Github\nGithub nos recomienda que la clave que generemos sea usando el algoritmo Ed25519\nssh-keygen -t ed25519 -C \u0026ldquo;your_email@example.com\u0026rdquo;\nEn el caso de que el sistema que est√©s usando no permita el algoritmo Ed25519, puedes recurrir al m√©todo m√°s tradicional:\nssh-keygen -t rsa -b 4096 -C \u0026ldquo;your_email@example.com\u0026rdquo;\ned25519 pertenece a una rama de la criptograf√≠a llamada \u0026ldquo;criptograf√≠a de curva el√≠ptica (ECC)\u0026rdquo;. RSA se basa en matem√°ticas bastante sencillas (multiplicaci√≥n de enteros), mientras que ECC procede de una rama de las matem√°ticas mucho m√°s complicada llamada \u0026ldquo;teor√≠a de grupos\u0026rdquo;. En resumen: las claves ECC pueden ser mucho m√°s cortas y ofrecer el mismo nivel de seguridad porque el problema matem√°tico en el que se basan es mucho m√°s complejo.\nPara a√±adir una clave p√∫blica en github vete a https://github.com/settings/keys y a√±√°dela pulsando el bot√≥n verde de New SSH key.\nBonus track Para mover archivos al servidor remoto podemos utilizar el comando rsync, que se usar√≠a de la siguiente forma:\nrsync -av {local_directory} {remote_user}@{remote_host}:{remote_directory}\n-a (archive) It is a quick way of saying you want recursion and want to preserve almost everything -v (verbose) This option increases the amount of information you are given during the transfer Para copiar el contenido de un fichero desde terminal al portapeles podemos ejecutar desde linux:\ncat {your_file.extension} | xsel \u0026ndash;clipboard \u0026ndash;input\nY para pegar el contenido del portapapeles ser√≠a ejecutar lo siguiente:\nxsel \u0026ndash;clipboard \u0026ndash;output\n","date":"2021-11-01T00:00:00Z","image":"https://raulpadilladelgado.github.io/blog/p/ssh-para-el-d%C3%ADa-a-d%C3%ADa/images/descripcion-del-protocolo-ssh.jpg","permalink":"https://raulpadilladelgado.github.io/blog/p/ssh-para-el-d%C3%ADa-a-d%C3%ADa/","title":"SSH para el d√≠a a d√≠a"},{"content":"Java Virtual Machine (JVM) ¬øQue es? La M√°quina Virtual de Java, en ingl√©s Java Virtual Machine (JVM), es un componente dentro de JRE (Java Runtime Environment) necesario para la ejecuci√≥n del c√≥digo desarrollado en Java, es decir, es la m√°quina virtual la que permite ejecutar c√≥digo Java en cualquier sistema operativo o arquitectura. De aqu√≠ que se conozca Java como un lenguaje multiplataforma. JVM interpreta y ejecuta instrucciones expresadas en un c√≥digo m√°quina especial (bytecode), el cual es generado por el compilador de Java (tambi√©n ocurre con los generados por los compiladores de lenguajes como Kotlin y Scala). Dicho de otra forma, es un proceso escrito en C o C++ que se encarga de interpretar el bytecode generado por el compilador y hacerlo funcionar sobre la infraestructura de ejecuci√≥n. Como hay una versi√≥n de la JVM para cada entorno que s√≠ conoce los detalles de ejecuci√≥n de cada sistema, puede utilizar el c√≥digo m√°quina equivalente para cada una de las instrucciones bytecode.\nJava tiene dos componentes principales:\nJava Runtime Environment (JRE): es el entorno de ejecucci√≥n de Java. Incluye la m√°quina virtual (JVM), las librer√≠as b√°sicas del lenguaje y otras herramientas relacionadas. Java Delopment Kit (JDK); adem√°s del JRE, incluye el compilador, el debugger, el empaquetador JAR, herramientas para generar documentaci√≥n, etc Por lo que cuando queremos ejecutar un fichero java ocurre lo siguiente:\nUn fichero example.java se compilar (gracias al compilador del JDK) y se genera un fichero example.class que contiene el bytecode capaz de ser interpretado por la JVM. Durante la ejecuci√≥n del c√≥digo, Class Loader se encarga de llevar los ficheros .class a las JVM que reside en la RAM del ordenador y ByteCode Verifier se encarga de verificar que el c√≥digo en bytecode procede de una compilaci√≥n v√°lida El compilador just in time compila el bytecode a c√≥digo nativo de la m√°quina y se ejecuta directamente En el siguiente apartado veremos m√°s a fondo la definici√≥n de cada uno de estos subsistemas de la JVM.\nEstructura La JVM se descompone en 3 subsistemas:\nClass loader subsystem Cuando una clase Java necesita ser ejecutada, existe un componente llamado Java Class Loader Subsystem que se encarga de cargar, vincular e inicializar de forma din√°mica y en tiempo de ejecuci√≥n las distintas clases en la JVM. Se dice que el proceso es din√°mico porque la carga de los ficheros se hace gradualmente, seg√∫n se necesiten.\nCarga\nExisten a su vez tres tipos de Loaders y cada uno tiene una ruta predefinida desde donde cargar las clases.\nBootstrap/Primordial ClassLoader: es el padre de los loaders y su funci√≥n es cargar las clases principales desde jre/lib/rt.jar, fichero que contiene las clases esenciales del lenguaje Extensi√≥n ClassLoader: delega la carga de clases a su padre (bootstrap) y, en caso fallido, las carga el mismo desde los directorios de extensi√≥n de JRE (jre/lib/ext) System/Application ClassLoader: es responsable de cargar clases espec√≠ficas desde la variable de entorno CLASSPATH o desde la opci√≥n por l√≠nea de comandos -cp. V√≠nculo\nLinking es el proceso de a√±adir los bytecodes cargados de una clase en el Java Runtime System para que pueda ser usado por la JVM. Existen tres paso en el proceso de Linking, aunque el √∫ltimo es opcional.\nVerify: Bytecode Verifier comprueba que el bytecode generado es correcto. En caso de no serlo, se devuelve un errror. Prepare: una vez se ha verificado, se procede a asignar memoria a las variables de las clases y se inicializan con valores por defecto dependiendo de su tipo. Las variables de clases no toman su valor inicial correcto hasta la fase de Initialization. Valores por defecto de variables primitivas:\n‚û°Ô∏è int = 0\n‚û°Ô∏è long = 0L\n‚û°Ô∏è short = (short) 0\n‚û°Ô∏è char = \u0026ldquo;\\u0000\u0026rdquo;\n‚û°Ô∏è byte = (byte) 0\n‚û°Ô∏è boolean = false\n‚û°Ô∏è reference = null\n‚û°Ô∏è float = 0.0f\n‚û°Ô∏è double = 0.0d Resolve: JVM localiza las clases, interfaces, campos y m√©todos referenciados en una tabla llamada constant pool (CP) y determina los valores concretos a partir de su referencia simb√≥lica. Cuando se compila una clase Java, todas las referencias a variables y m√©todos se almacenan en el CP como referencia simb√≥lica. Una referencia simb√≥lica, de forma muy breve, es un string que puede usarse para devolver el objeto actual. El CP es un √°rea de memoria con valores √∫nicos que se almacenan para reducir la redundancia. Para el siguiente ejemplo:\nSystem.err.println(\u0026quot;Test\u0026quot;);\nSystem.out.println(\u0026quot;Test\u0026quot;);\nen el CP solo habr√≠a un objeto, String \u0026ldquo;Test\u0026rdquo; Inicializaci√≥n\nSe encarga de que las variables de clase se inicialicen correctamente, con los valores que el desallorador especific√≥ en el c√≥digo.\nRuntime Data Areas JVM define varias √°reas de datos que se utilizan durante la ejecuci√≥n de un programa y que se podr√≠an dividir en dos grupos. Algunas de estas √°reas se crean al inicializarse la JVM y se destruyen una vez la JVM finaliza (compartidas por todos los hilos). Otras se inicializan cuando el hilo se crea y se destruyen cuando el hilo se ha completado (una por hilo).\nMethod area: es parte de Heap Area. Contiene el esqueleto de la clase (m√©todos, constantes, variables, atributos, constructor, etc) Heap area: fragmento de memoria donde se almacenan los objetos creados (todo lo que se inicialice con el operador new). Si el objeto se borra, el Garbage Collector se encarga de liberar su espacio. Solo hay un Heap Area por JVM, por lo que es un recurso compartido (igual que Method Area) Stack area: fragmento de memoria donde se almacenan las variables locales, par√°metros, resultados intermedios y otros datos. Cada hilo tiene una private JVM stack, creada al mismo tiempo que el hilo. PC register: contiene la direcci√≥n actual de la instrucci√≥n que se est√° ejecutando (una por hilo) Native Method Stack: igual que Stack, pero para m√©todos nativos, normalmente escritor en C o C++. Execution Engine El bytecode que es asignado a las √°reas de datos en la JVM es ejecutado por el Execution Engine, ya que este puede comunicarse con distintas √°reas de memoria de la JVM. El Execution Engine tiene los siguientes componentes.\nInterpreter: es el encargado de ir leyendo el bytecode y ejecutar el c√≥digo nativo correspondiente. Esto afecta considerablemente al rendimiento de la aplicaci√≥n. JIT Compiler: interact√∫a en tiempo de ejecucci√≥n con la JVM para compilar el bytecode a c√≥digo nativo y optimizarlo. Esto permite mejorar el rendimiento del programa. Esto se hace a trav√©s del HotSpot compiler. Garbage Collector: libera zonas de memoria que han dejado de ser referenciadas por un objeto Empaquetar y ejecutar aplicaci√≥n Java Ya hemos visto la parte te√≥rica de como funciona la JVM y ahora toca realizar un ejemplo pr√°ctico.\nPara compilar una app usaremos el javac dentro del directorio bin de nuestra instalaci√≥n\njavac MyApp.java Esto generar archivos .class a partir de nuestro archivo fuente .java. Estos son los archivos que puede ejecutar la m√°quina virtual de Java.\nPara ejecutar una aplicaci√≥n usaremos java que lo podemos encontrar en el directorio bin del JRE o JDK. Para ello, debemos hacer referencia a una clase que contenga un m√©todo est√°tico main, el principal punto de entrada de las aplicaciones en Java. Adem√°s, si forma parte de un paquete debemos escribir la ruta completa desde la base del √°rbol.\njava com.example.myApp.MyApp Java permite empaquetar las aplicaciones y librer√≠as en archivos comprimidos. De esta forma es m√°s sencillo poder reutilizar el c√≥digo a trav√©s de distintas aplicaciones o desplegar nuevas versiones de la aplicaci√≥n. Estos archivos pueden ser:\nJAR: librer√≠as o aplicaciones de escritorio WAR: aplicaciones web jar cf jar-file files-to-package La opci√≥n c indica que se desea crear el archivo y la opci√≥n f especifica el nombre del archivo. Este comando genera un comprimido .jar que contiene todas las clases que indiquemos, incluyendo directorios de forma recursiva. Adem√°s, genera un archivo de manifiesto. Si el archivo de manifiesto especifica el header Main-Class, podremos ejecutar la aplicaci√≥n desde el archivo JAR de la siguiente forma:\njava -jar jar-file Los archivos JAR tambi√©n pueden ser agregados al classpath, de forma que las aplicaciones puedan obtener sus dependencias al explorar dentro de su contenido. Es la principal forma de distribuci√≥n de librer√≠as. Normalmente, cuando descargamos una aplicaci√≥n Java, esta trae sus propios JAR adem√°s de las dependencias.\nGraalVM Hablamos de una Virtual Machine que es una extensi√≥n de la JVM tradicional que permite ejecutar cualquier lenguaje en una √∫nica VM (JavaScript, R, Ruby, Python\u0026hellip;). Soporta modos de ejecucci√≥n tales como la compilaci√≥n ahead-of-time que permite un tiempo de arranque m√°s r√°pido en aplicaciones Java, resultado en ejecutables que ocupan menos memoria.\nüéØ Objetivos\nMejorar el rendimiento de los lenguajes basados en la m√°quina virtual de Java haciendo que tengan un rendimiento similar a los lenguajes nativos Reducir el tiempo de arranque de las aplicaciones de la JVM mediante la compilaci√≥n ahead-of-time (antes de tiempo) con GraalVM Native image Permitir la integraci√≥n de GraalVM en Oracle Database, Node.js, Android/iOS y otros üì∞ Lenguajes y runtimes\nGraalVM JavaScript: runtime de JavaScript (ECMAScript 2019), con soporte para Node.js TruffleRuby: implementaci√≥n de Ruby FastR: implementaci√≥n del lenguaje R üî© Componentes\nGraaVM Compiler: se trata de un compilador JIT para Java GraalVM Native Image: permite la compilcaci√≥n ahead-of-time Truffle Language Implementation Framework: depende de GraalVM SDK y permite implementar otros lenguajes en GraalVM Instrumentation-based Tool Support: soporte para instrumentaci√≥n din√°mica, que es agn√≥stica del lenguaje Una opci√≥n que puede ser interesante, llegando a posibilidad de tener varios lenguajes dentro de un mismo proyecto, y que tiene el suficiente cuerpo como para que sea comentada en otro post del blog.\n","date":"2021-10-29T00:00:00Z","image":"https://raulpadilladelgado.github.io/blog/p/java-virtual-machine/images/jvm.jpg","permalink":"https://raulpadilladelgado.github.io/blog/p/java-virtual-machine/","title":"Java Virtual Machine"},{"content":"Introducci√≥n Recientemente he estado trabajando en un proyecto personal que surge por la necesidad de una funci√≥n espec√≠fica en spotify, que no pod√≠a conseguir a trav√©s de la app oficial de la plataforma. Mi objetivo era poder organizar mis playlist por orden de fecha de estreno de la canci√≥n. Spotify te permite organizarlas por fecha en la que la a√±adiste a la playlist, pero no por el tipo de organizaci√≥n que yo quer√≠a.\nEntonces fue cuando descubr√≠ Sort Your Music, que es una aplicaci√≥n web que te ofrece herramientas para organizar tus playlist de una forma m√°s avanzada.\nGracias a la anterior web me decid√≠ por montar mi propia implementaci√≥n que tenga lo que me gusta y necesito, y montarlo en algo que de un modo r√°pido me permita lanzar mi comando de organizar playlists.\nAhora mismo, el proyecto se trata de una aplicaci√≥n Python sencilla, que hace uso de la librer√≠a spotipy, que nos simplifica la forma en la que interactuamos con la API de Spotify. Al arrancar la aplicaci√≥n, seremos capaces de listar las playlist del usuario y ordenar una determinada playlist por fecha de estreno de las canciones en orden descendente.\nPara ofrecer una interfaz al usuario se ha utilizado Flask, un framework ligero que permite montar un servidor web con pocas l√≠neas de c√≥digo.\nEl repositorio lo puedes encontrar en:\nraulpadilladelgado/toolify (github.com)\nLa aplicaci√≥n web la puedes usar en:\nhttps://toolify-app.herokuapp.com\nSpotify for developers Para que podamos utilizar la API de Spotify necesitamos:\nCrearte una cuenta en Spotify Developers e iniciar sesi√≥n\nNo es necesario crear una cuenta si inicias sesi√≥n con la cuenta que habitualmente usas para Spotify Es hora de ir a nuestro dashboard y crear una nueva APP Una vez creada la APP, es necesario localizar tu client_id y client_secret, pues ser√°n las claves para que podamos realizar operaciones utilizando la API de Spotify. En el README del proyecto se muestra donde se deben incluir estos valores. Definir la ruta de redirecci√≥n. La primera vez que un usuario interactua con la aplicaci√≥n que hemos creado es necesario que se autentifique y que verifique que nos da permiso para alterar cierta informaci√≥n relacionada a sus playlists a un scope determinado. Esta ruta de redirecci√≥n sirve para que una vez se finalice correctamente el proceso de dar acceso, el token generado se guarde. Debemos ir a \u0026ldquo;Edit Settings\u0026rdquo;(vease en la imagen anterior), y tener definido lo siguiente: Ejecutar Toolify Cuando montas el proyecto por primera vez, es necesario instalar SpotyPy pip install -r requirements.txt\nLas claves de la APP de Spotify Developers que hab√≠amos comentado en el apartado anterior, ser√°n introducidas como variables del sistema operativo. TOOLIFY_SECRET_KEY SPOTIFY_REDIRECT_URI SPOTIFY_CLIENT_SECRET SPOTIFY_CLIENT_ID\nFinalmente, puedes arrancar la aplicaci√≥n usando: flask run Siguientes pasos En esta primera iteraci√≥n con el proyecto he ofrecido la posibilidad de ordenar el contenido de una playlist por fecha de estreno de las canciones, entonces surge una pregunta, ¬øcomo explotar el proyecto?\nMe gusta mucho crear mis propias playlists, y para mi el orden es fundamental para que cuando est√© escuchando m√∫sica vayan apareciendo las canciones en una secuencia de mi inter√©s, como puede ser la fecha de estreno de las canciones o el BPM de la canci√≥n si est√°s buscando que las canciones m√°s marchosas est√©n primero. Jugando con como ordenamos las canciones se puede ofrecer una experiencia totalmente distinta.\nEn una playlist no todo es ordenar, a veces se duplican canciones o se introducen versiones editadas de las canciones originales (lo que se conoce como Remix) e interesa solo mantener la √∫ltima versi√≥n. Ser√≠a interesante que Toolify identificase estos casos, que los muestre al usuario para que decida que mantener, y finalmente que la aplicaci√≥n borre lo que no interese.\nPodr√≠amos ser capaces de mostrar al usuario sus estad√≠sticas de uso en spotify, sus cantantes m√°s escuchados, canciones m√°s escuchadas, entre otros datos de inter√©s.\nEsto es todo, ¬°muchas gracias por leer!\n","date":"2021-10-15T00:00:00Z","image":"https://raulpadilladelgado.github.io/blog/p/toolify/images/hqdefault.jpg","permalink":"https://raulpadilladelgado.github.io/blog/p/toolify/","title":"Toolify"},{"content":"Introducci√≥n Este post trata de exponer una serie de buenas pr√°cticas o trucos a la hora de realizar testing de c√≥digo, y forma parte de una serie de cap√≠tulos que pretenden seguir con el prop√≥sito.\nEn esta primera iteraci√≥n la idea es hablemos sobre TDD, programaci√≥n funcional, patrones de dise√±o y estabilidad, todo esto orientado a los tests.\nVamos al laboratorio! üß™\nTDD en nuestros tests Test-Driven Development (TDD) es una pr√°ctica de programaci√≥n que consiste en escribir primero las pruebas, despu√©s escribir el c√≥digo fuente que pase la prueba satisfactoriamente y, por √∫ltimo, refactorizar el c√≥digo escrito.\nCon esta pr√°ctica se consigue entre otras cosas: un c√≥digo m√°s robusto, m√°s seguro, m√°s mantenible y una mayor rapidez en el desarrollo. Adem√°s, logramos realizar pruebas m√°s sencillas, ya que escribimos c√≥digo productivo para nuestros tests, y no al rev√©s. Ganamos en c√≥digo simple y f√°cil de testear.\nPara ver como el TDD mejora nuestros tests veamos un ejemplo siguiendo la pr√°ctica:\nKata fizzbuzz Enlace a la kata: https://www.hackerrank.com/challenges/fizzbuzz/problem\nRecomiendo que el siguiente ejercicio se haga siguiendo la metodolog√≠a TDD.\nTodo comienza por un test que falla porque a√∫n no tenemos implementado que har√° la funci√≥n a testear. Le escribes el m√≠nimo c√≥digo para que cumplamos nuestro test. Refactorizamos con la tranquilidad de que sabremos si estamos cambiando comportamiento en el c√≥digo gracias a la ejecuci√≥n de nuestro test https://raulpadilladelgado.com/wp-content/uploads/2021/07/Untitled20.png B√°sicamente, el problema nos propone lo siguiente:\nPasamos un n√∫mero, y puede ocurrir lo siguiente: - Que sea divisible por tres y devuelva \u0026#34;fizz\u0026#34; - Que sea dividible por cinco y devuelva \u0026#34;buzz\u0026#34; - Que no sea dividible por ninguno de los anteriores y devuelva el mismo n√∫mero - Que sea dividible por tres y por cinco y devuelva \u0026#34;fizzbuzz\u0026#34; Manos a la obra! üë∑üèª\nCaso: Que no sea dividible por ninguno de los anteriores y devuelva el mismo n√∫mero\nTest\n@Test public void return_the_same_number_as_passed(){ assertThat(Fizzbuzz.fizzbuzz(1)).isEqualTo(\u0026#34;1\u0026#34;); } Code\nclass Fizzbuzz{ public static String fizzbuzz(int number){ return String.valueOf(number); } De momento solo tenemos un caso de uso, asi que nos ce√±imos a desarrollar lo m√≠nimo\nCaso: Que sea dividible por tres y devuelva \u0026ldquo;fizz\u0026rdquo;\nTest\n@Test public void return_the_same_number_as_passed(){ assertThat(Fizzbuzz.fizzbuzz(1)).isEqualTo(\u0026#34;1\u0026#34;); } @Test public void return_fizz_if_is_divisible_by_3(){ assertThat(Fizzbuzz.fizzbuzz(3)).isEqualTo(\u0026#34;fizz\u0026#34;); } Code\nclass Fizzbuzz{ public static String fizzbuzz(int number){ if(number % 3 == 0){ return \u0026#34;fizz\u0026#34;; } return String.valueOf(number); } } Progresivamente vamos a√±adiendo l√≥gica para los nuevos casos de uso sin romper los anteriores\nCaso: Que sea dividible por cinco y devuelva \u0026ldquo;buzz\u0026rdquo;\nTest\n@Test public void return_the_same_number_as_passed(){ assertThat(Fizzbuzz.fizzbuzz(1)).isEqualTo(\u0026#34;1\u0026#34;); } @Test public void return_fizz_if_is_divisible_by_3(){ assertThat(Fizzbuzz.fizzbuzz(3)).isEqualTo(\u0026#34;fizz\u0026#34;); } @Test public void return_buzz_if_is_divisible_by_5(){ assertThat(Fizzbuzz.fizzbuzz(5)).isEqualTo(\u0026#34;buzz\u0026#34;); } Code\nclass Fizzbuzz{ public static String fizzbuzz(int number){ if(number % 3 == 0){ return \u0026#34;fizz\u0026#34;; } if(number % 5 == 0){ return \u0026#34;buzz\u0026#34;; } return String.valueOf(number); } } Progresivamente vamos a√±adiendo l√≥gica para los nuevos casos de uso sin romper los anteriores\nCaso: Que sea dividible por tres y por cinco y devuelva \u0026ldquo;fizzbuzz\u0026rdquo;\nTest\n@Test public void return_the_same_number_as_passed(){ assertThat(Fizzbuzz.fizzbuzz(1)).isEqualTo(\u0026#34;1\u0026#34;); } @Test public void return_fizz_if_is_divisible_by_3(){ assertThat(Fizzbuzz.fizzbuzz(3)).isEqualTo(\u0026#34;fizz\u0026#34;); } @Test public void return_buzz_if_is_divisible_by_5(){ assertThat(Fizzbuzz.fizzbuzz(5)).isEqualTo(\u0026#34;buzz\u0026#34;); } @Test public void return_fizzbuzz_if_is_divisible_by_3_and_5(){ assertThat(Fizzbuzz.fizzbuzz(15)).isEqualTo(\u0026#34;fizzbuzz\u0026#34;); } Code\nclass Fizzbuzz{ public static String fizzbuzz(int number){ if (number % 3 == 0 \u0026amp;\u0026amp; number % 5 == 0){ return \u0026#34;fizzbuzz\u0026#34;; } if(number % 3 == 0){ return \u0026#34;fizz\u0026#34;; } if(number % 5 == 0){ return \u0026#34;buzz\u0026#34;; } return String.valueOf(number); } } El ir implementando cada caso poco a poco con la l√≥gica necesario para superar solo ese caso, ha hecho que lleguemos a una soluci√≥n sencilla, y que escala a medida que necesitamos m√°s casos de uso.\nTest m√°s legible, test m√°s comestible üçΩ Programaci√≥n declarativa frente a imperativa Cuando hacemos uso de programaci√≥n declarativa le estamos diciendo al c√≥digo que haga algo, pero no el c√≥mo lo tiene que ser, nosotros solo le pedimos una misi√≥n. Un ejemplo de este tipo de comportamiento es el lenguaje SQL, que por defecto funciona de tal manera. Si queremos buscar un cliente har√≠amos lo siguiente:\nSELECT * FROM clients WHERE name = \u0026#39;name\u0026#39;; Se ve muy f√°cil de leer, sobre todo porque no le indicamos como tiene que conseguir el prop√≥sito, eso son aspectos internos del propio de lenguaje.\nPor el contrario, con programaci√≥n imperativa no le decimos que queremos obtener, sino que nosotros mismo implementamos esa funcionalidad usando un lenguaje como pueda ser java. Siguiendo el ejemplo anterior para buscar un cliente dentro una lista tendr√≠amos lo siguiente usando programaci√≥n imperativa:\nfor (i = 0; i \u0026lt; clients.length(); i++) { Client client = client.get(i); if (client.name.equals(clientToBeFind)){ return client; } } O extrapolado a hacerte un caf√© ser√≠a:\nProgramaci√≥n declarativa\nPrepara un caf√© Programaci√≥n imperativa\nVe a la cocina √âchale agua a la cafetera, cafe y ponla al fuego Espera a que salga el caf√© y tr√°elo El gran pro de usar la programaci√≥n declarativa es la transparencia que te da de lo que est√° ocurriendo, te est√°s abstrayendo de toda complejidad existente. Adem√°s, no solo sabes que est√° pasando en todo momento de una forma m√°s clara, sino que ganas en c√≥digo impoluto, ya que mandar instrucciones a la aplicaci√≥n ser√° como leer un cuento.\nEl paradigma de la programaci√≥n funcional con la declarativa Como mencion√© anteriormente, SQL funciona de tal forma que es declarativo, pero tambi√©n tenemos otros lenguajes como Javascript que aunque no es declarativo, tiene muchas funciones predefinidas que llaman a utilizar la programaci√≥n funcional. En Javascript el modo de iterar listas o arrays puede ser un proceso que sin terminar de ser declarativo del todo, es mucho m√°s amigable que en otros lenguajes. Por ejemplo:\nconst ages = [12,32,32,53] const selectedAges = ages.map(age =\u0026gt; age += 10).filter(age =\u0026gt; age \u0026gt; 40); Como vemos tiene mucho parecido con la programaci√≥n declarativa, ya que seguimos pidiendo cosas sin importar como las haga, como pueda ser el uso de map o filter, pero en el caso de map le tenemos que indicar que realizar con cada elemento de la lista, y en el caso de filter que elementos debe escoger y cu√°les no. No termina de ser declarativo, pero nos permite tener esa limpieza abstray√©ndonos de bucles complicados.\nEste comportamiento de las funciones de javascript responde a que son funciones inmutables, es decir, que no alteran ning√∫n aspecto de la aplicaci√≥n como pueda ser el estado de un atributo de un objeto, una variable global, o lo que sea. Son funciones puras, por lo que siempre que pongamos la misma entrada saldr√° la misma salida. Siempre devuelven el resultado de llamarlas por eso es por lo que funcionan como la programaci√≥n funcional.\nPatrones de dise√±o aplicados a testing El uso de patrones de dise√±o en c√≥digo productivo se hace con la finalidad de que nuestro c√≥digo sea m√°s mantenible, escalable, siga unas reglas de dise√±o que busquen organizaci√≥n y otros fines similares. Pero cuando se trata de test, estos no son una excepci√≥n. Nuestras pruebas automatizadas tambi√©n pueden seguir unos patrones de dise√±o con el fin de mejorar la mantenibilidad y legibilidad.\nAhora veremos algunos ejemplos escritos en Kotlin sobre como mejorar la legibilidad y mantenibilidad de nuestros test mediante el uso de build pattern, object mother o named arguments. Vamos a poner en contexto una clase llamada User, en la que tenemos una regla de negocio que para apostar se debe tener una edad m√≠nima.\nTradicional private val minimumAgeToBet = 18 fun canBet(): Boolean { return userAge \u0026gt;= minimumAgeToBet } fun `user can bet with the minimum age`() { val userAge = 22 val user = User(\u0026#34;some name\u0026#34;, userAge) assertTrue(user.canBet()) } En este primer caso hemos creado directamente una instancia de la clase en nuestros test, por lo que cada uno tendr√° la responsabilidad de mantenerse actualizado si la firma de la clase cambia, como por ejemplo que se a√±ada un par√°metro.\nBuilder Pattern fun withAge(age: Int): UserBuilder { userAge = age return this } fun build(): User { return User(userName, userAge) } fun `user can bet with the minimum age`() { val userAge = 22 val user = UserBuilder().withAge(20).build() assertTrue(user.canBet()) } En este caso hemos hecho uso del patr√≥n builder, que implicar tener un Builder encargado de construir nuestra clase e inicializarla a trav√©s de un build().\nEn el constructor habr√° definidos unos valores por defecto para todos los atributos, y proporcionarnos unos setters que sirven para aportar sem√°ntica al test, ya que a la hora de establecer valores solo lo haremos en aquellos atributos que tiene importancia en el test.\nUsando el patr√≥n builder hemos sacado fuera de los test la responsabilidad de crear instancias de las clases, hemos ganado sem√°ntica y hemos hecho m√°s declarativos nuestros tests, ahora muestran de una forma m√°s clara que les interesa.\nEl patr√≥n builder gana al m√©todo tradicional, pero tiene un problema, cuando tengamos muchos atributos a los que definirles un valor vamos a pasarlo un poco mal, veamos otro patr√≥n que nos ser√° a√∫n m√°s √∫til.\nObject mother companion object { fun userWithMinimumAgeToBet(): User { return User(\u0026#34;name\u0026#34;, 22) } } fun `user can bet with the minimum age`() { val user = UserFixtures.userWithMinimumAgeToBet() assertTrue(user.canBet()) } En el √°mbito de test hacemos uso del ObjectMother, que no es m√°s que una clase de factor√≠a que contiene una serie de m√©todos est√°ticos que nos permiten crear una instancia de la clase con mayor sem√°ntica. Hemos indicado el tipo de caso que queremos, sin entrar en detalles de cu√°l tiene que ser el valor exacto, por lo que hemos ganado en sem√°ntica y adem√°s tenemos un factor a nuestro favor y es que si ma√±ana cambia la edad m√≠nima o la forma en la que y en varios de nuestros test llamamos al m√©todo userWithMinimumAgeToBet, solo tendremos que cambiar o a√±adir variables o lo que haga falta en el UserFixtures, nuestro test no necesita ser modificado.\nProgramaci√≥n funcional en nuestros test Ahora voy a exponer un ejemplo real escrito en Kotlin de como el uso de programaci√≥n declarativa junto con el patr√≥n builder han sido una gran ventaja a la hora de desarrollar test que necesitaban realizar muchas aserciones para verificar el estado de registros persistidos en la base de datos.\nPongamos en contexto un contrato que tiene como propiedades:\nEstado Fecha de alta Fecha de baja Servicio contratado Teniendo lo anterior presente, vamos a crear una clase que nos permita construir paso a paso lo que queremos comprobar. Lo que queremos verificar son las columnas de ciertas filas en base de datos, o lo que es lo mismo, queremos revisar la informaci√≥n almacenada para un pedido, por lo que cuando produzcamos una instancia de la clase que nos har√° las aserciones le pasaremos el ID en cuesti√≥n. Por otro lado, iniciaremos un mapa en el que la clave del mapa ser√° la columna en la tabla de base de datos y el valor del mapa ser√° el valor en la tabla de base de datos para dicha columna.\nTendremos m√∫ltiples m√©todos para a√±adir columnas a comprobar, y cada uno de estos m√©todos devuelve la misma instancia de la clase para que podamos ir concatenando llamadas y agregar m√°s columna que comprobar.\nFinalmente, la √∫ltima llamada que realizaremos ser√° al m√©todo que har√° las aserciones.\nclass OrderAssertion(private val orderId: Long, private val connection: DBConnection) { private val fieldsValuesMap: MutableMap\u0026lt;String, String\u0026gt; = mutableMapOf() fun hasStatus(status: String): OrderAssertion { fieldsValuesMap[\u0026#34;status\u0026#34;] = status return this } fun hasOrderDate(date: String): OrderAssertion { fieldsValuesMap[\u0026#34;order_date\u0026#34;] = date return this } fun hasProducts(products: String): OrderAssertion { fieldsValuesMap[\u0026#34;products\u0026#34;] = products return this } fun doAssert() { try { assertOrder() } catch (assertionError: AssertionError) { throw assertionError } catch (unexpectedError: Exception) { throw AssertionError(\u0026#34;Unexpected Error inside order assert\u0026#34;, unexpectedError) } } @Throws(Exception::class) private fun assertOrder() { val sql = StringBuilder(500) sql.append(\u0026#34;SELECT id\u0026#34;) for (field in fieldsValuesMap.keys) { sql.append(\u0026#34;, \u0026#34;).append(field) } sql.append(\u0026#34; FROM orders\u0026#34;).append(\u0026#34; WHERE id = \u0026#34;).append(orderId) connection.executeSQL(sql.toString()).use { results -\u0026gt; if (results.moveNext()) { for ((field, expected) in fieldsValuesMap) { val value: String = results.getString(field) assertThat(value) .withFailMessage( \u0026#34;Wrong value for field \u0026#39;%s\u0026#39;. Expected is \u0026#39;%s\u0026#39; but actual was \u0026#39;%s\u0026#39;\u0026#34;, field, expected, value ).isEqualTo(expected) } } else { fail(\u0026#34;Order with ID \u0026#39;%s\u0026#39; not found\u0026#34;, orderId) } } } } Nuestro test quedar√° muy claro y limpio, gracias al trabajo que hemos hecho en esta clase de aserciones que quita toda complejidad innecesaria para nuestro test.\nfun `create a order`() { val orderId = \u0026#34;1234\u0026#34; val status = \u0026#34;in arrival\u0026#34; val orderDate = \u0026#34;2021-05-31 00:00:00\u0026#34; val products = \u0026#34;some products\u0026#34; orderService.makeOrder(orderId, status, products) assertThatOrderWithId(orderId) .hasStatus(status) .hasOrderDate(orderDate) .hasProducts(products) .doAssert() } Como si de un framework se tratara, hemos simplificado y abstra√≠do del test la complejidad de hacer aserciones a la base de datos, y ha quedado un test muy f√°cil de leer. As√≠ es, test legible, test m√°s comestible.\nEstabilidad en nuestros test Como solucionar test que fallan aleatoriamente Un problema que nos podemos encontrar a la hora de hacer test, es que tenemos algunos tests que algunas veces pasan y otras no. Esto se puede deber a que tenemos una bater√≠a de test en la que el orden de ejecuci√≥n influye en el resultado de los mismos. El ejemplo m√°s claro ser√≠a un test que persiste un registro y otro test que intenta recuperar ese mismo registro. Un test no deber√≠a depender de otros para poder funcionar correctamente, por lo que cada test deber√≠a comenzar desde cero y levantar o preparar todo lo que necesite para el caso de uso que est√© probando, sin esperar que sea otro test el que prepare el escenario.\nPor lo que tengo entendido, en JUnit (framework de unit test para JVM) la primera ejecuci√≥n de los test en una m√°quina (tu pc) se hace forma aleatoria, pero despu√©s ejecutar√° los mismos test siempre en el mismo orden. Eso quiere decir que si otra m√°quina ejecuta esos mismos test por primera vez tambi√©n ser√° de manera aleatoria, pero solo una vez, el resto de veces se ejecutar√°n en el mismo orden. Tenemos un modo de indicar usando JUnit que queremos que la ejecuci√≥n de nuestros test sea de modo aleatorio, y as√≠ asegurarnos que ninguno de nuestros test depende de otro. Simplemente, lograremos esta aleatoriedad estableciendo una etiqueta encima del nombre de la clase de test:\n@TestMethodOrder(MethodOrderer.Random::class) internal class SomeTest { @Test fun aTest() { } @Test fun aTest() { } @Test fun aTest() { } } Como forzar tests deterministas Otro punto de error que puede surgir a la hora que realizamos test, es tener aserciones que dependen de variables y que adem√°s tienen mucha tendencia a cambiar. Es decir, si en un test estamos comprobando el retorno de una funci√≥n contra una variable el test pasar√° en ocasiones si y en otras no. Esto se debe a que comparar el resultado contra dicha variable no es la mejor idea, ya que dicha variable estar√° cambiando su valor constantemente y, por tanto, no tendremos un test consistente y estar√° lanz√°ndonos un error cuando puede ser que en realidad la funci√≥n que estamos testeando est√° perfecta. Vamos a ver un ejemplo en Kotlin muy sencillo con una funci√≥n que tiene que comprobar si en este momento actual es de d√≠a:\nPor un lado, el m√©todo check() de la clase MorningChecker que devuelve true o false dependiendo de si es por la ma√±ana o no.\nclass MorningChecker { fun isMorning(): Boolean { val hour: Int = now().hour val startOfMorning = 6 val endOfMorning = 12 return hour in startOfMorning..endOfMorning } } Por otro lado, el test que comprueba que cuando es por la ma√±ana deber√≠a devolver true\nclass MorningCheckerShould { @Test fun `check if is morning`() { val morningChecker = MorningChecker() assertTrue(morningChecker.isMorning()) } } Si estamos lanzando el test entre las 6 y las 12 nos dar√° un resultado correcto, pero en cualquier otro horario este test no pasar√≠a. Nuestro m√©todo isMorning() est√° sacando la variable que determina que hora del d√≠a es usando una librer√≠a que te la proporciona en tiempo real, por lo que cuando vamos al test tambi√©n se usa la fecha real. Vamos a cambiar un poco el panorama para que en vez de usar una variable calculada bas√°ndose en el tiempo real, usemos un par√°metro:\nExtraemos a un par√°metro la hora del d√≠a\nclass MorningChecker { fun isMorning(hour: Int): Boolean { val startOfMorning = 6 val endOfMorning = 12 return hour in startOfMorning..endOfMorning } } Y finalmente en el test le pasamos la hora que queremos comprobar para ese test\nclass MorningCheckerShould { @Test fun `check if is morning`() { val morningChecker = MorningChecker() val actualHour = 8 assertTrue(morningChecker.isMorning(actualHour)) } } Ahora que el test tiene siempre la misma entrada, por ende tendr√° siempre la misma salida. Sin sorpresas, solo lo que esperamos. Puede parecer un caso simple, pero la idea es plasmar que nuestro test no deber√≠a depender nunca de factores variables, que hacen que perdamos el control de lo que pasa y que en ocasiones provoquen que nuestro test no tenga siempre el mismo resultado para la misma entrada.\nEstructura de los test Cuando hablamos de entender un test no solo est√° sobre la mesa su contenido, sino que su contexto tambi√©n no es de utilidad y muy importante que est√© en su lugar correcto. Una buena organizaci√≥n y estructura de los archivos del proyecto es fundamental, pero si aplicamos arquitectura hexagonal vamos un paso m√°s all√°, ya que estaremos separando responsabilidades por capas y estaremos mejorando la mantenibilidad y escalabilidad de nuestro c√≥digo. Pero la arquitectura hexagonal no exclusivamente la podemos aplicar a nuestro source code (c√≥digo productivo), deber√≠amos seguir la misma idea para nuestro test, separ√°ndolos entre test que comprueban aspectos de la aplicaci√≥n, el dominio o la infraestructura. Para aprender ma≈õ sobre arquitectura hexagonal puede ver un post realizado por m√≠:\nhttps://raulpadilladelgado.github.io/blog/p/arquitectura-hexagonal/\n","date":"2021-10-09T00:00:00Z","permalink":"https://raulpadilladelgado.github.io/blog/p/buenas-pr%C3%A1cticas-en-testing-cap.1/","title":"Buenas pr√°cticas en testing (Cap.1)"},{"content":"Introducci√≥n ¬øQue es una regex?\nRegex hace referencia a ‚Äúexpresi√≥n regular‚Äù y se trata de la t√©cnica que nos permite hacer b√∫squedas de una secuencia de caracteres atendiendo a un patr√≥n de b√∫squeda.\nEl uso de expresiones regulares nos puede simplificar y acelerar el proceso de tener que reemplazar varios textos que entre s√≠ cumplen un patr√≥n coincidente. Veamos un ejemplo para que sea m√°s sencillo, supongamos que tenemos un escrito en el que varias personas se est√°n presentando, por ejemplo:\nHola, soy Ra√∫l y tengo 20 a√±os Hola, soy Mar√≠a y tengo 25 a√±os Hola, soy Marcos y tengo 1 a√±os Cuando una persona tenga un a√±o de edad deber√≠amos usar el singular en la palabra ‚Äúa√±os‚Äù, por lo que con una expresi√≥n regular vamos a modificar esa palabra para que nos sirva en ambos casos.\nLa expresi√≥n regular para buscar coincidencias [s]$ Lo que coincide (entre *) Hola, soy Ra√∫l y tengo 20 a√±o**s** Hola, soy Mar√≠a y tengo 25 a√±o**s** Hola, soy Marcos y tengo 1 a√±o**s** La expresi√≥n regular para reemplazar texto ($0) Lo que se reemplaza/a√±ade/quita (entre *) Hola, soy Ra√∫l y tengo 20 a√±o**(s)** Hola, soy Mar√≠a y tengo 25 a√±o**(s)** Hola, soy Marcos y tengo 1 a√±o**(s)** O visto en formato GIF desde el IDE IntelliJ haciendo un reemplazo de texto usando el shortcut\nCtrl + r:\nhttps://grow.leanmind.es/uploads/default/original/1X/c357b028eac2a1448d993bf279fff1363e5b1180.gif Antes de entrar en materia y ver como utilizar esta herramienta de reemplazo de texto, vamos a repasar los tipos de match que podemos usar para construir nuestras expresiones regulares.\nTipos de match Caracteres Characters Legend Regex Example Coincidence Example \\d D√≠gitos del uno al nueve file_\\d\\d file_25 \\w Letra, d√≠gito o barra baja \\w-\\w\\w\\w A-b_1 \\s Espacios, tabuladores, saltos de l√≠nea. a\\sb\\sc a bc \\D Un caracter que no sea un n√∫mero \\D\\D\\D ABC \\W Un caracter que no sea un n√∫mero ni una letra \\W\\W\\W\\W\\W *-+=) \\S Un caracter que no sea un espacio \\S\\S\\S\\S Yoyo . Cualquier caracter excepto salto de l√≠nea .* whatever, man. Escapes a special character .*+? $^/\\ .*+? $^/\\ \\t Tab T\\t\\w{2} T ab \\r Carriage return character see below \\n Line feed character see below \\r\\n Line separator on Windows AB\\r\\nCD ABCD [ ‚Ä¶ ] Uno de los caracteres dentro de los corchetes [AEIOU] One uppercase vowel [ ‚Ä¶ ] Uno de los caracteres dentro de los corchetes T[ao]p Tap or Top [ ‚Ä¶ ] Uno de los caracteres dentro de los corchetes [AB1-5w-z] One of either: A,B,1,2,3,4,5,w,x,y,z - Indicador de rango [a-z] One lowercase letter [x-y] Un caracter dentro del rango de x a y [A-Z]+ GREAT [ -~]+ Characters in the printable section of the ASCII table. [^x] Un caracter que no es una x [^a-z]{3} A1! [^x-y] Un caracter que NO est√° dentro del rango de x a y [^ -~]+ Characters that are not in the printable section of the ASCII table. [\\d\\D] Un caracter que es n√∫merico o no num√©rico [\\d\\D]+ Any characters, inc-luding new lines, which the regular dot doesn‚Äôt match Cuantificadores Characters Legend Regex Example Coincidence Example + Uno o m√°s veces Version \\w-\\w+ Version A-b1_1 {3} Exactamente tres veces \\D{3} ABC {2,4} De dos a cuatro veces \\d{2,4} 156 {3,} Tres o m√°s veces \\w{3,} regex_tutorial * Cero o m√°s veces A_B_C* AAACC ? Una o ninguna vez plurals? plural L√≥gica Characters Legend Regex Example Coincidence Example Alternaci√≥n (tipicamente OR) 22 ( ‚Ä¶ ) Capturar grupos A(nt pple) \\1 Contenido del grupo 1 r(\\w)g\\1x regex \\2 Contenido del grupo 2 (\\d\\d)+(\\d\\d)=\\2+\\1 12+65=65+12 (?: ‚Ä¶ ) Grupo que no coincide A(?:nt pple) Anclajes y l√≠mites Characters Legend Regex Example Coincidence Example ^ Inicio de una l√≠nea ^abc .* abc (line start) $ Final de una l√≠nea .*? the end$ this is the end Modificadores en l√≠nea Characters Legend Regex Example Coincidence Example (?i) no distingue entre may√∫sculas y min√∫sculas (?i)Monday monDAY (?s) Con este modificador el . tambi√©n reconocer√° saltos de l√≠nea (?s)From A.*to Z From Ato Z Herramienta de reemplazo de texto de IntelliJ Vistazo a las opciones En un fichero que contenga texto, combina Ctrl + r para abrir el men√∫ de reemplazo:\nUntitled En la primera fila del men√∫ podemos apreciar:\n:mag: : En primer lugar vemos el icono de una lupa en la que si pulsamos sobre ella veremos el historial de los patrones de b√∫squeda que hemos ido introduciendo\n:ballot_box: : Al lado de la lupa nos encontramos el campo donde introduciremos nuestro patr√≥n de b√∫squeda\n:leftwards_arrow_with_hook: : Seguido tenemos una flecha que si pulsamos sobre ella introduciremos un salto de l√≠nea\nCc: Define si el patr√≥n de b√∫squeda debe distinguir entre may√∫sculas y min√∫sculas o no\nW: ???\n.*: Define si la b√∫squeda ser√° utilizando expresiones regulares o texto normal\nx/x: El contador de resultado de la b√∫squeda\n:arrow_up: : Mover al resultado superior\n:arrow_down: : Mover al resultado inferior\n:stop_button: : Ver los resultado en una ventana de b√∫squeda aparte\n:ballot_box_with_check: : Seleccionar el texto de todas las coincidencias y cerrar herramienta de reemplazo Buscar solo en la selecci√≥n de texto actual\nBuscar solo en la opci√≥n que elijamos (todo el texto, comentarios, etc)\nEn la segunda fila del men√∫ podemos apreciar:\n:mag: : En primer lugar vemos el icono de una lupa en la que si pulsamos sobre ella veremos el historial de los patrones de reemplazo que hemos ido introduciendo\n:ballot_box: : Al lado de la lupa nos encontramos el campo donde introduciremos nuestro patr√≥n de reemplazo\n:leftwards_arrow_with_hook: : Seguido tenemos una flecha que si pulsamos sobre ella introduciremos un salto de l√≠nea\nA'A: La activamos si queremos reemplazar texto manteniendo las may√∫sculas y min√∫sculas tal como las encontramos\nReplace: Reemplazar la ocurrencia seleccionada\nReplace All: Reemplazar todas las ocurrencias\nExclude: Excluir de ser reemplazada la ocurrencia seleccionada\nReemplazar texto usando Regex Reemplazo directo: Se trata de introducir directamente el texto que queremos se reemplaze con el que tenemos en cada coincidencia. https://grow.leanmind.es/uploads/default/original/1X/24dc9862f013d27cc7ed63081fe87a99b69f4974.gif Reemplazo usando √∫nico grupo: Cuando escribimos expresiones regulares sin agruparlas, es decir, sin introducirlas dentro de unos parentesis. A pesar de que en este caso no hemos agrupado dentro de nuestra expresi√≥n regular, tenemos un grupo al que podemos referirnos ($0) y se trata de cada coincidencia entera. https://grow.leanmind.es/uploads/default/original/1X/ab6ebcb9c14078a528e77d0ca5306f5adcd4ee92.gif Reemplazo usando grupos definidos: Cuando agrupamos dentro de nuestra expresi√≥n regular podemos realizar reemplazos de textos m√°s avanzados. Tendremos el grupo $0 que hace referencia a cada coincidencia entera, y despu√©s tendremos $1, $2‚Ä¶, as√≠ por cada grupo creado. https://grow.leanmind.es/uploads/default/original/1X/603c4df89856471e0e58e64d7b48d0244cd8ae0f.gif ","date":"2021-07-01T00:00:00Z","image":"https://raulpadilladelgado.github.io/blog/p/multi-reemplazo-de-texto-usando-regex-en-intellij/images/intellij-idea.png","permalink":"https://raulpadilladelgado.github.io/blog/p/multi-reemplazo-de-texto-usando-regex-en-intellij/","title":"Multi-reemplazo de texto usando Regex en IntelliJ"},{"content":"Introducci√≥n Arquitectura de software\nReglas autoimpuestas al definir como dise√±amos software\n¬øQue ganamos entonces imponi√©ndonos este tipo de reglas?\nBuscamos la mantenibilidad: Somos capaces de mantener mejor el c√≥digo gracias a como formamos la arquitectura Buscamos la variabilidad: Somos capaces de reemplazar piezas de nuestra arquitectura sin aparentemente un costo muy grande Buscamos el testing: Somos capaces de testear nuestro c√≥digo de una forma r√°pida, sencilla y eficaz. Buscamos la simplicidad: Somos capaces de tener un c√≥digo sim√©trico, que sea f√°cil de entender. Si entiende un caso de uso, ser√°s capaz de entender cualquier otro, nuestro c√≥digo se vuelve predecible. Esto tambi√©n nos aleja de errores que no queremos cometer:\nEvitar la complejidad accidental: Evitamos la complejidad accidental al no introducir con nuestros desarrollos m√°s complejidad de la que el sistema ya tiene La estructura de directorios en arquitectura hexagonal Las capas superiores conocen las capas inferiores y no al rev√©s:\nNuestro dominio no conoce detalles de implementaci√≥n de la capa de infraestructura, solo define el contrato para que sea la infraestructura quien implemente dicho funcionamiento.\nLa aplicaci√≥n conoce el dominio a modo de poder presentar la informaci√≥n para que otros la consuman, en este caso, sera la capa de infraestructura quien use la aplicaci√≥n para realizar las operaciones pertinentes.\nLa infraestructura son detalles de implementaci√≥n, como puede ser una base de datos, y deber√≠a poder cambiarse un tipo de infraestructura por otra sin afectar al funcionamiento base de la aplicaci√≥n y el dominio.\nApplication service vs Domain service Servicios de aplicaci√≥n Como podemos ver en la imagen, los servicios de aplicaci√≥n son el punto de entrada de nuestra aplicaci√≥n. Desde el controlador ya sea de tipo API o l√≠nea de comandos, se llama al servici√≥n de aplicaci√≥n para que este se encarge de realizar las operaciones pertinentes, como pueda ser:\nSolicita operaciones al sistema de persistencia. Dichas operaciones comienzan y finalizan en los servicios de aplicaci√≥n. Publicar eventos de dominio Son el inicio de un caso de uso de nuestro aplicaci√≥n.\nUn Servicio de aplicaci√≥n instancia un Servicio de dominio para evitar la duplicidad de c√≥digo.\nServicios de dominio Son el resultado de agrupar l√≥gica de negocio que podremos reutilizar desde los servicios de aplicaci√≥n. Imaginemos que tenemos dos casos de uso en nuestra aplicaci√≥n:\nObtener una playlist en base a su identificador Modificar el nombre de una playlist ¬øQue comparten ambos casos?\nNecesitan ir al repositorio de playlists a buscar la playlist dado un identificador Lanzar una excepci√≥n de dominio tipo PlaylistNotFound en el caso de que no encuentre la playlist Retornar la playlist en caso de encontrarla Entonces extraeremos a un Servicio de dominio dicho compartimiento com√∫n que tendr√≠an nuestros dos casos de uso (dos servicios de aplicaci√≥n).\nSevicios de infraestructura ‚ùå No acoplar la estructura de un contrato con su implementaci√≥n\nUn error muy com√∫n ser√≠a modelar el dominio de tal forma que aunque no est√© acoplado a la infraestructura, si est√© pensando para tener la estructura para alguna implementaci√≥n espec√≠fica. Por ejemplo, en nuestro aplicaci√≥n tenemos un servicio de notificaciones, y desde un principio tenemos claro que en la infraestructura inicial estar√° slack como ese servicio, el error ser√≠a modelar el dominio para que cumpla los requisitos que pide tal implementaci√≥n.\nüíâ Inyectar las dependencias de los adaptores/implementaciones por constructor\nPara poder solventar esto, debemos modelar el dominio pensando en que sea lo m√°s abstracto posible, sin influirle con nada, y en el caso de necesitar par√°metros espec√≠ficos para la implementaci√≥n, lo har√≠amos mediante su constructor. El contructor nunca lo definiremos en la interface, ir√° en sus implementaciones, y entonces ser√° la infraestructura la que se encarge de conocer el dominio y de como acoplarse a el.\nüß™ Usamos implementaciones fake de servicios para nuestros test\nUsaremos implementaciones fake para poder testear sin tener que ejecutar el c√≥digo real que tenemos en la infraestructura. Estar√≠amos evitando tambi√©n tener que falsear el comportamiento de un servicio existente, algo que se puede complicar al tratar de mockear las dependencias y funcionamiento de esa implementaci√≥n.\nTesting en arquitectura hexagonal Testing capa de aplicaci√≥n y dominio (test unitario) Los test unitarios son los que usaremos para comprobar que la l√≥gica de negocio de nuestros casos de uso (capa de aplicaci√≥n) y modelos o servicios de dominio se comportan como esperamos. Caracter√≠sticas principales:\nEl objetivo de estos tests es el de¬†validar que la implementaci√≥n de nuestra l√≥gica de negocio es correcta. Son los test m√°s r√°pidos de ejecutar. En estos tests falsearemos la implementaci√≥n a usar de todo componente de infraestructura. Es decir, all√° donde definamos un puerto en nuestros casos de uso, inyectaremos un doble de test para que no hagan operaciones de entrada/salida pero poder validar la interacci√≥n del dominio con estos componentes. Importante falsear la interface de dominio y no el cliente final para evitar incurrir en¬†el anti-patr√≥n de Infrastructure Mocking. El test unitario ser√° independiente del punto de entrada. Desde el momento en el que encapsulamos nuestros casos de uso en servicios de aplicaci√≥n para poderlos reaprovechar desde m√∫ltiples puntos de entrada (controlador API HTTP o CLI), el test unitario invocar√° directamente al caso de uso para desacoplarse tambi√©n del controlador. Al ser los m√°s r√°pidos de ejecutar y estar centrados en la l√≥gica de negocio, es en estos test donde ubicamos las¬†comprobaciones m√°s exhaustivas¬†en cuanto a las distintas ramificaciones de nuestros casos de uso. Gracias a que nuestro dominio no conoce detalles de implementaci√≥n de la capa de infraestructura, solo define el contrato para que sea la infraestructura quien implemente dicho funcionamiento, tenemos la posibilidad de crear implementaciones espec√≠ficas para nuestros test. Supongamos que tenemos un servicio que necesita un repositorio para persistir en base de datos, dado que no estamos acoplados a una implementaci√≥n espec√≠fica, en nuestros test podr√≠as definir una nueva implementaci√≥n que permita testear solo el comportamiento de la capa de aplicaci√≥n y de dominio, ya que en este caso no necesitar√≠amos testear infraestructura en este tipo de test unitario.\nTesting capa de infraestructura Un tipo de test donde el objeto de test es alguna implementaci√≥n de uno de nuestros puertos. Es decir, en el caso del test unitario, habr√≠amos falseado mediante un doble (PlaylistRepositoryFake) de test la interface de dominio PlaylistRepository, mientras que en el test de integraci√≥n lo que haremos ser√° justamente testear la implementaci√≥n de PlaylistRepositoryPgsql para validar que se comporta como esperamos.\n@Test public void it_should_save_a_playlist() { repository().save(\u0026#34;Hello, I am a playlist\u0026#34;); } @Test public function it_should_check_if_exists_a_playlist() { String playlist = \u0026#34;Hello, I am a playlist\u0026#34;; repository().save(playlist); assertThat(repository().search($playlist)).isTrue(); } Test de aceptaci√≥n Simulan ser un cliente de nuestra aplicaci√≥n. Entrar√°n en juego todas las implementaciones reales para comprobar que todo el flujo y la integraci√≥n con la infraestructura se producen satisfactoriamente. Con lo cu√°l, las caracter√≠sticas principales ser√≠an:\nEl objetivo de estos tests es el de¬†asegurar que la aplicaci√≥n funciona correctamente¬†y el flujo completo de las peticiones se puede realizar satisfactoriamente. Son los test m√°s lentos¬†de ejecutar¬†ya que tienen un alcance mayor y s√≠ ejecutan operaciones de entrada/salida como inserts en base de datos ya que usan las implementaciones reales de estos componentes. Aportan mayor valor¬†debido al alcance que tienen (nos asegura que absolutamente todo est√° ejecutandose como esperamos) En nuestro caso, al implementar una API HTTP,¬†simularemos peticiones HTTP¬†y comprobaremos que las respuestas tienen el c√≥digo HTTP y el contenido del cuerpo esperados. Al ser los test m√°s lentos de ejecutar,¬†s√≥lo¬†implementaremos una peque√±a muestra de las distintas ramificaciones¬†que pueden tomar nuestros casos de uso. Dejando para los test unitarios la responsabilidad de probar cada una de las casu√≠sticas. As√≠ evitaremos incurrir en el¬†anti-patr√≥n de test del cono de helado. ","date":"2021-04-30T00:00:00Z","image":"https://raulpadilladelgado.github.io/blog/images/Untitled18.png","permalink":"https://raulpadilladelgado.github.io/blog/p/arquitectura-hexagonal/","title":"Arquitectura hexagonal"},{"content":"¬øPor qu√© aprender bash? La respuesta corta es porque linux es realmente GNU/Linux. S√≥lo el kernel es linux, pero la colecci√≥n base de utilidades que proporcionan el entorno Unix es proporcionada por GNU y el shell de GNU es bash. Es por esto que bash el shell por defecto que te encontrar√°s en cualquier distribuci√≥n o servidor basado en linux.\nHay muchas shells que se adaptan mejor a los prop√≥sitos o gustos individuales, como pueden ser zsh, pero creo que al ser un estandar es muy positivo dominar la herramienta para tener un desarrollo fluido, c√≥modo y productivo cuando necesites usarla o por si es tu shell de preferencia.\n¬øQue dominar de bash? Shortcuts Tab ‚û°Ô∏è autocompletar comandos\nctrl + r ‚û°Ô∏è buscar en el historial de comandos. Pulsa Enter para ejecutar un comando o pulsa flecha derecha para editar\nctrl + w ‚û°Ô∏è borra la √∫ltima palabra\nctrl + u ‚û°Ô∏è borra hasta inicio de l√≠nea\nctrl + k ‚û°Ô∏è borra hasta final de l√≠nea\nalt + b ‚û°Ô∏è mover cursor a palabra anterior\nalt + f ‚û°Ô∏è mover cursor a palabra posterior\nctrl + a ‚û°Ô∏è mover cursor a principio de l√≠nea\nctrl + e ‚û°Ô∏è mover cursor a final de l√≠nea\nctrl + l ‚û°Ô∏è vaciar terminal, limpiarla\ncd ‚û°Ô∏è ir al directorio principal (tu usuario)\n~ == /home/usuario ‚û°Ô∏è abreviaci√≥n de directorio principal\ncd - ‚û°Ô∏è volver al directorio de trabajo previo\ncd .. ‚û°Ô∏è ir un directorio m√°s arriba\nPuedes encontrar todos los que tienes asignado ejecutando en terminal:\nbind -p Trucos Mi comando es demasiado largo o complejo La soluci√≥n es sencilla, abrirlo en un editor pero hay una forma muy r√°pida de realizarlo\nEn primer lugar define tu editor si no lo hab√≠as hecho export EDITOR=vim Comienza a escribir un comando echo simpleTest Pulsa ctrl + w y despu√©s ctrl + e y autom√°ticamente el comando se abrir√° en tu editor Detener procesos Por nombre completo: killall process\nSeleccionando ventana: xkill\nComandos en background La sintaxis es a√±adir nohup al principio del comando y \u0026amp; al final\nraul@raul-pc:~$ nohup sleep 10 \u0026amp; [1] 4172 raul@raul-pc:~$ nohup: ignoring input and appending output to \u0026#39;nohup.out\u0026#39; ^C raul@raul-pc:~$ ps PID TTY TIME CMD 3615 pts/1 00:00:00 bash 4172 pts/1 00:00:00 sleep 4173 pts/1 00:00:00 ps raul@raul-pc:~$ ps PID TTY TIME CMD 3615 pts/1 00:00:00 bash 4174 pts/1 00:00:00 ps [1]+ Done nohup sleep 10 ¬øCuanto tiempo llevo usando el PC? Utiliza uptime o w que proporciona m√°s informacion que el anterior.\nAbrevia con los alias raul@raul-pc:~$ alias hello=\u0026#34;echo hello world\u0026#34; raul@raul-pc:~$ hello hello world El uso de parentesis Por ejemplo si estamos desarrollando un script y queremos movermos a otro directorio en una sola instrucci√≥n y tras esta seguir donde estabamos podemos a√±adir parentesis a la secuencia que se movia a otro directorio:\n# do something in current dir (cd /some/other/dir \u0026amp;\u0026amp; other-command) # continue in original dir Evitar reproducir un texto raul@raul-pc:~/Desktop$ touch hola.js raul@raul-pc:~/Desktop$ touch hola.html raul@raul-pc:~/Desktop$ mv hola.{js,html} ~/Downloads/ Ver diferencias entre dos archivos diff file1 file2 Redirigir resultados de un comando Guardar salida en archivo\necho test \u0026gt; afile.txt Guardar salida est√°ndar en archivo\necho test 1\u0026gt; afile.txt Guardar error est√°ndar en archivo\necho test 2\u0026gt; afile.txt echo test 2\u0026gt;\u0026amp;1 Ejecutar un comando con los argumentos del anterior raul@raul-pc:~$ touch 4.txt raul@raul-pc:~$ ls !$ ls 4.txt 4.txt raul@raul-pc:~$ Ejecutar scripts al inicio Con systemd\nhttps://juncotic.com/systemd-ejecutando-un-script-al-inicio-de-gnu-linux/\nCon crontab\n#Put into crontab @reboot /home/test/Documentos/scripts/mi-primer-script.sh #Check if crontab is enabled sudo systemctl status cron.service #Enable if is needed sudo systemctl enable cron.service More: https://computernewage.com/2019/03/09/scripting-linux-bash-ejecutar-script-arranque/\nEl PC no se congela del todo Si te pasa que el ordenador se congela al estar usandolo por la ejecucci√≥n de alguna aplicaci√≥n o simplemente porque se ha congelado la sesi√≥n de escritorio actual, todav√≠a existe una v√≠a de escape que no es apagar el PC y volver a encenderlo. Si tienes suerte y el PC no se ha congelado del todo, es decir, solo se ha afectado la parte gr√°fica, puedes seguir estos pasos para restaurar la sesi√≥n en poco tiempo:\nEn primer lugar abriremos la terminal que no est√° asociada a la sesi√≥n gr√°fica, es decir, el cl√°sico Ctrl + Alt + T no nos vale en este caso. En su lugar usaremos Ctrl + Alt + F2 para abrir una terminal, y nos pedir√° que introduzcamos el nombre y la contrase√±a del usuario\nUna vez dentro pasaremos a utilizar el comando htop para acabar con el problema. Si no lo tienes instalado podr√°s hacerlo de forma normal con APT:\nsudo apt install htop Escribimos htop y se nos abrir√° una lista de procesos que est√°n corriendo actualmente en el sistema. Si nuestro problema es una aplicaci√≥n la localizamos y pulsamos F9 (kill) sobre ella. En el men√∫ de la izquierda aparecen muchas opciones, destacaremos dos:\n15 (Sigterm) ‚áí La mayor√≠a de procesos est√°n escuchando por si el sistema les pide que paren su ejecucci√≥n, por lo que deber√≠a ser la primera opci√≥n que probemos\n09 (Sigkill) ‚áí En el caso de que el anterior opci√≥n no nos valga, usaremos esta opci√≥n para forzar el cierre del proceso\nUna vez realizado lo anterior, es momento de volver a la interfaz gr√°fica. Usaremos Ctrl + Alt + F1 para volver a ella.\nReemplazar texto Con el uso del comando sed podemos reemplazar texto sin la necesidad ni el trabajo manual de realizarlo en un editor de texto. Un ejemplo de como usarlo podr√≠a ser:\nEste ejemplo muestra el primer car√°cter de cada palabra en par√©ntesis:\necho \u0026#34;Bienvenidos al Mundo de los Bits y los Bytes\u0026#34; | sed \u0026#39;s/\\\\(\\\\b[A-Z]\\\\)/\\\\(\\\\1\\\\)/g\u0026#39; Con el resultado:\n(B)ienvenidos(A)l(M)undo de los(B)its y los(B)ytes Si no se lo que hace un comando Tienes un comando con un par de opciones definidas y no sabes que es lo que hace con todas esas opciones, ejemplo: ls -ltrh\nLos comandos sueles traer consigo una opci√≥n --help o -helpo -h que te cuentan todo acerca del comando, tambi√©n puedes recurrir a utilizar otro comando que se llama tldr, que te soltar√° ejemplos muy usados y con breve descripci√≥n para un comando. Pero si aun as√≠ necesitas algo m√°s te voy a exponer una soluci√≥n muy parecida a la opci√≥n --help, pero con una interfaz m√°s atractiva y amigable. Es el caso de explainshell.\nexplainshell.com - match command-line arguments to their help text\nTodo esto y mucho m√°s en\u0026hellip; Recientemente me he encontrado un repositorio que contiene una serie de markdowns (mismo contenido, distintos idiomas) que tratan una serie de utilidades para aprender de la terminal, principalmente de Linux, aunque se tratan tambi√©n aspectos MacOS y Windows. Lo recomiendo mucho porque est√° explicado de una forma sencilla y porque trata una cantidad de herramientas muy √∫tiles que aprender.\njlevy/the-art-of-command-line\n","date":"2021-04-22T00:00:00Z","permalink":"https://raulpadilladelgado.github.io/blog/p/el-arte-de-la-l%C3%ADnea-de-comandos/","title":"El arte de la l√≠nea de comandos"},{"content":" As√≠ncrono \u0026ldquo;Que no tiene lugar en completa correspondencia temporal con otro proceso o con la causa que lo produce.\u0026rdquo;\nRecientemente he estado desarrollando un proyecto basado en Node JS que usaba una librer√≠a externa en la que sus m√©todos devolv√≠an promesas. Sin tener mucha experiencia con lo as√≠ncrono en javascript, para mi la forma m√°s simple de entenderlo y aplicarlo correctamente fue la siguiente:\nSupongamos que tienes una promesa como por ejemplo:\nfunction resolveAfter2Seconds() { return new Promise(resolve =\u0026gt; { setTimeout(() =\u0026gt; { resolve(\u0026#39;resolved\u0026#39;); }, 2000); }); } Hasta que dicha promesa no sea resuelta, es decir, que en el caso anterior se hayan completado los dos segundos, no tendr√≠amos el resultado de dicha promesa (resolved). Lo que implica que cualquier otro m√≥dulo que llame a esta funci√≥n necesita funcionar de forma as√≠ncrona, para poder alterar la correspondencia temporal. Digamos que vamos a obligar al motor de javascript que espere hasta que nuestra promesa sea resuelta.\nEl motor de javascript es s√≠ncrono\nasync function asyncCall() { console.log(\u0026#39;calling\u0026#39;); const result = await resolveAfter2Seconds(); console.log(result); // expected output: \u0026#34;resolved\u0026#34; } Hemos utilizado async para indicar que la funci√≥n tendr√° un comportamiento as√≠ncrono, y await para especificar que esperaremos hasta que la promesa que retorna la funci√≥n llamada sea resuelta.\nFuente consultada: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function\n","date":"2021-04-11T00:00:00Z","permalink":"https://raulpadilladelgado.github.io/blog/p/como-funciona-async-await/","title":"¬øComo funciona async await?"},{"content":"Cuando me incorpor√© en el proyecto de uno de nuestros colaboradores, sent√≠a que mis conocimientos estaban limitados y ejerc√≠a un rol de principiante, donde mi misi√≥n erradicaba en el papel de una esponja, si se me permite la comparaci√≥n. Deb√≠a absorber toda la sabidur√≠a de los compa√±eros con mayor experiencia laboral. Creo que esta sensaci√≥n es algo natural, ya que, para cultivar los conceptos necesarios, se debe estudiar y practicar. En esta fase de asimilaci√≥n de conceptos, cualquier consejo, feedback o ense√±anza es de agradecimiento.\nA medida que avanzaban los d√≠as, aprend√≠ nuevas tecnolog√≠as, metodolog√≠as de dise√±o, formas de hacer test, etc. Era consciente de que obten√≠a conceptos m√°s t√©cnicos, lo que me aport√≥ confianza para intervenir e intentar ayudar dentro de lo posible. Esta nueva sensaci√≥n era fundamental para m√≠, ¬øpor qu√©?, es sencillo. Me sent√≠a parte de algo, de un grupo en el que importaba mi presencia y en el que pod√≠a ayudar. Esto alimenta un ego positivo que surge en lo m√°s hondo, es una forma de automotivaci√≥n que anima a dar lo mejor de ti cada d√≠a.\nTras medio a√±o, noto un avance de mis conocimientos (a pesar de esto, soy consciente de que me queda much√≠simo por aprender), pero he reflexionado acerca de una cualidad que todo desarrollador debe tener, y que, personalmente, tuve que desarrollar para ser m√°s eficaz en el √°mbito laboral. Con esto hago referencia a la constituci√≥n de la personalidad. He hecho pairing con otros compa√±eros, en muchas ocasiones con personas con amplia experiencia, lo que es considerado t√©cnicamente como un Senior developer. Mis ganas de aportar eran insaciables, por lo que flu√≠an en mi cabeza un sinf√≠n de ideas sobre lo que se iba desarrollando, pero por motivos que desconozco, me cohib√≠a el pensar en la vasta experiencia de la otra persona, lo que imped√≠a que mis ideas se dieran a conocer. Cuando fui consciente del valor que estaba dejando escapar, mi prop√≥sito fue firme, deb√≠a aportar cada idea que me surgiera, estuviera seguro o no de la certeza de mi pensamiento. Solo exist√≠an dos caminos posibles y ambos conduc√≠an a la victoria: el primero, pod√≠a estar equivocado, pero mis compa√±eros propondr√≠an una mejor soluci√≥n y yo interiorizar√≠a la lecci√≥n; el segundo, mi idea era cierta y estaba proponiendo algo que pod√≠a contribuir al desarrollo y al equipo. Muchas veces esa ‚Äúpregunta necia‚Äù puede mostrarte lo que estabas obviando o darte una nueva perspectiva que te ayude a comprender el tema en cuesti√≥n.\nEn innumerables ocasiones observ√© en silencio a compa√±eros con mayor experiencia en el sector hablando de temas que desconoc√≠a y esto me produc√≠a pavor, una sensaci√≥n de carencia de conocimiento sobre la materia. Tras un trabajo continuo, analizando todo lo que comentan, eres capaz de aprender valiosas lecciones, no s√≥lo aspectos t√©cnicos, sino el valor que se refleja en sus personalidades. A un ingeniero Senior puedes identificarlo m√°s por sus habilidades blandas que por sus t√©cnicas, son personas sumamente pacientes y amigables. Son m√°s unos gu√≠as que personas con gran conocimiento t√©cnico. Tienen habilidades extraordinarias de liderazgo y versatilidades sumamente √∫tiles.\nDebe tenerse en cuenta en todo momento que en el equipo en el que te integras quiz√°s no seas la figura con m√°s dominio t√©cnico, pero siempre puedes ser m√°s productivo, quien entrega funcionalidades cuidadas gracias a todo el empe√±o, buscando las fallas m√≠nimas. Desde mi perspectiva, una de las habilidades m√°s relevantes cuando inicias este recorrido es la paciencia, porque sin ella resulta complicado aprender, puede llegarse incluso a la frustraci√≥n, sensaci√≥n por la que las ganas escasean. Siempre existe un momento para ti, pero para lograrlo se debe buscar y trabajar con constancia. Otra habilidad es la perseverancia, porque sin ella no puede dominarse nada, es como aprender a montar en bicicleta, te caes y te levantas hasta que lo consigues.\nDespu√©s de comprender esto, siento que aporto m√°s valor, pero lo que es a√∫n m√°s importante, me siento m√°s libre y capaz de todo. El mejor experto tambi√©n fue en su d√≠a un aprendiz y est√° en la cumbre porque en su momento fall√≥, acert√≥, arriesg√≥, ayud√≥ y aprendi√≥. Si tuviese que extraer una moraleja de esto ser√≠a explicando que existen tres tipos de personas en el mundo: los que hacen que las cosas ocurran, los que ven c√≥mo ocurren las cosas y los que se preguntan qu√© ocurri√≥ (N. Butler).\nAhora mi visi√≥n es menos confusa, si hoy no comprendo algo, preguntar√© c√≥mo ocurri√≥ y ser√© yo quien har√° que suceda. Se debe aprovechar cualquier momento de aprendizaje, ya que es fundamental para llegar a conseguir una mejor versi√≥n de nosotros mismos.\nTodos hemos tenido un mentor, esa persona que es tu referencia y no s√≥lo por su conocimiento, sino por ser una persona capaz de transmitir su sabidur√≠a con los dem√°s de una forma inteligente, con paciencia, respeto y sus mejores intenciones en tu aprendizaje. Un gran compa√±ero quiso transmitirme que pod√≠a contar con √©l para cualquier duda o problema en el trabajo, y me cont√≥ unas grandes palabras que nunca olvidar√©. Me habl√≥ sobre las cuatro etapas de la competencia:\nHaces algo mal y no eres consciente de ello, porque a√∫n no te has dado cuenta Haces algo mal, pero te lo han dicho o te has dado cuenta de alguna forma y eres consciente de ello, por lo que ya est√°s preparado para mejorar en ese aspecto. Haces algo bien, has aprendido de tus errores y has mejorado, aunque te requiere un esfuerzo y concentraci√≥n para lograr realizar la tarea correctamente. Haces algo bien, y gracias a tu constancia y perseverancia ya lo realizas sin pensarlo, no necesitas concentrarte, porque dominas lo que haces y para ti es algo cotidiano. En el ciclo vital, recorremos las cuatro etapas. Pasamos de novatos a expertos, es ley de vida, la constancia y el trabajo nos mejora profesionalmente y personalmente. La programaci√≥n no es una excepci√≥n, existen personas con mayor conocimiento que el resto, pero se debe a su trabajo y constancia para lograr dominar el tema en cuesti√≥n. Nadie deber√≠a negarle su ayuda a otra persona, pues el buen mentor hace que otros con menor experiencia pasen por las cuatro etapas de la competencia de una forma eficiente y provechosa.\n","date":"2021-03-26T00:00:00Z","permalink":"https://raulpadilladelgado.github.io/blog/p/la-personalidad-en-un-aprendiz/","title":"La personalidad en un aprendiz"},{"content":"Introducci√≥n Durante mucho tiempo fui usuario de Windows, pero un d√≠a decid√≠ probar Linux y termin√© por elegirlo como mi sistema operativo para trabajar. Llegando a un mundo nuevo para m√≠, decid√≠ probar distintas distribuciones Linux para encontrar cual era la que mejor se adaptaba al uso que que le dar√≠a. Tras ver un curso en CodelyTV, pude aprender que la configuraci√≥n que tediosa que hacemos d√≠a tras d√≠a desde que iniciamos en una m√°quina se puede resumir en la simple ejecucci√≥n de un script, y puedo decir que ojal√° haber conocido est√° pr√°tica tan simple pero que aporta y ayuda tanto a la configuraci√≥n personal.\n¬øQu√© es un dotfile? Las configuraciones espec√≠ficas del usuario se almacenan tradicionalmente en los llamados dotfiles (archivos cuyo nombre comienza con un punto). Es una pr√°ctica com√∫n versionarlos con un sistema de control de versiones como Git para realizar un seguimiento de los cambios y sincronizarlos en varias m√°quinas. Es decir, gracias a esta pr√°ctica podremos pasar a una m√°quina nueva y configurarla a nuestro gusto, tal y como estaba la anterior de una forma muy r√°pida y con el m√≠nimo esfuerzo.\nEn este post estar√© ense√±ando como tener nuestro repositorio centralizado de archivos de configuraci√≥n de nuestra m√°quina. Veremos todas las cosas que podemos automatizar (que yo he descubierto y entendido por el momento) y entre todos aprenderemos como exprimir esta pr√°ctica.\nLa gu√≠a Entendiendo el workflow Como he dicho anteriormente, el objetivo es centralizar todos las configuraciones en un repositorio, as√≠ que el proceso que debemos realizar ahora es el siguiente:\nIdentifica un archivo o carpeta de configuraci√≥n que comienza por un punto en nuestra home y que queremos guardar (usa ls -a para listarlas) Mueve una carpeta o archivo desde la home a la carpeta \u0026ldquo;.dotfiles\u0026rdquo; Crea un enlace simb√≥lico para que la configuraci√≥n pueda ser accedida desde la home pero estando realmente alojada en la subcarpeta \u0026ldquo;.dotfiles\u0026rdquo; (ejemplo: ln -s .dotfiles/.gitconfig $PWD/.gitconfig) Ejemplo\nmv .bashrc .dotfiles ln -s .dotfiles/.bashrc $PWD/.bashrc Resultado .bashrc -\u0026gt; .dotfiles/.bashrc Si necesitas borrar un enlace simb√≥lico porque te has equivocado o la ruta donde lo almacenas ha cambiado, puedes usar el comando unlink : (Ejemplo) unlink .bashrc\nAhora s√≠, automatizemos esto üì¶ El repo He creado un repositorio en Github llamado \u0026ldquo;dotfiles\u0026rdquo;, que posteriormente clonar√© en local en la carpeta \u0026ldquo;.dotfiles\u0026rdquo; que se alojar√° en mi home (la carpeta principal de mi usuario).\ngit clone git@github.com:raulpadilladelgado/dotfiles.git .dotfiles üö´ Exclusi√≥n Pongamos el caso de que en una carpeta queremos versionar varias carpetas, pero hay una que concretamente no queremos tener. Usemos el tan querido .gitignore. Ejemplo:\n.gitignore\nshell/zsh/**/**.zwc shell/zsh/**/**.zwc.old /**/**/private-* üèóÔ∏è Estructura Todo organizado se encuentra mejor y luce mejor. No hay un convenio de carpetas para los dotfiles (aunque puede usar el de CodelyTV) pero puedes aplicar tu habilidad de organizaci√≥n para crear las distintas carpetas para los distintos programas y que quede todo organizado.\n‚öôÔ∏è Scripts Para symlinks\nAntes estuvimos haciendo uso de los symlinks para nuestro prop√≥sito de los dotfiles, pero era un trabajo un muy manual. Para mejorarlo y que se solo la tengamos que realizar una vez, podemos hacer un script que ejecutemos cada vez que cambiemos de m√°quina para poder tener los dotfiles linkeados a nuestra m√°quina de la forma m√°s r√°pida y sencilla posible.\nPara programas\nYa hemos visto como utilizar los dotfiles para guardar nuestros archivos de configuraci√≥n y dem√°s, pero podr√≠amos ir un paso m√°s all√°, teniendo en nuestro proyecto de dotfiles una forma que nos permita instalar todos nuestros programas en un momento.\nOpci√≥n 1 - Importamos una lista de programas que ten√≠amos instalados\nLa idea es poder llevarnos la referencia de los programas que tenemos instalados para despu√©s importarlos.\nExportaci√≥n\nPrimero vamos a sacar la lista de los programas instalados.\n#Para brew (gestor de paquetes de mac) brew bundle dump --file=\u0026#34;$HOMEBREW_BUNDLE_FILE_PATH\u0026#34; --force #Para apt (gestor de paquetes t√≠pico en debian y derivadas) sudo dpkg-query -l | awk \u0026#39;{if ($1 == \u0026#34;ii\u0026#34;) print $2}\u0026#39; \u0026gt; packages_list.txt #Para pip (gestor de paquetes python) pip freeze \u0026gt;\u0026#34;$DOTFILES_PATH/langs/python/requirements.txt\u0026#34; #Para npm (gestor de paquetes de node) ls -1 /usr/local/lib/node_modules | grep -v npm \u0026gt;\u0026#34;$DOTFILES_PATH/langs/js/global_modules.txt\u0026#34; #Para composer Movemos el archivo ~/.composer/composer.json a nuestro proyecto de dotfiles Importaci√≥n\n#Para brew (gestor de paquetes de mac) brew bundle --file=\u0026#34;$HOMEBREW_BUNDLE_FILE_PATH\u0026#34; --force #Para apt (gestor de paquetes t√≠pico en debian y derivadas) sudo xargs -a packages_list.txt apt install #Para pip (gestor de paquetes python) pip install -r \u0026#34;$DOTFILES_PATH/langs/python/requirements.txt\u0026#34; #Para npm (gestor de paquetes de node) xargs -I_ npm install -g \u0026#34;_\u0026#34; \u0026lt;\u0026#34;$DOTFILES_PATH/langs/js/global_modules.txt\u0026#34; #Para composer Hacemos un symlink del ~/.composer/composer.json ¬øUsas paquetes snap?. Este gestor de paquetes que usan las distribuciones de canonical permite la exportaci√≥n e importaci√≥n de los datos de las aplicaciones instaladas. ¬øComo?\nVacia el directorio (para tener solo la √∫ltima copia de seguridad de cada programa): /var/lib/snapd/snapshots\nExportaci√≥n (nos dar√° un ZIP por programa): snap save\nMueve los archivos a tu proyecto: mv /var/lib/snapd/snapshots .dotfiles/apps/snap\nHaz un symlink a la ruta /var/lib/snapd/snapshots\nInstala los snap en la m√°quina nueva (recomendado script): snap install app1 app2 app3\nFinalmente ejecuta la restauraci√≥n (el id es el n√∫mero por el que comienzan todos los archivos zip, deber√≠a ser sencillo porque problamente todos se te hayan exportado con el mismo ID haciendo referencia a que se exportaron en el mismo proceso): snap restore \u0026lt;id\u0026gt;\nAlgunas apps como spotify llegan a pesar 1GB que entiendo que puede ser por temas de cach√© y canciones descargadas, por lo que ser√≠a conveniente reducirlo primero antes de a√±adirlo al proyecto o no incluir algo as√≠. Usar tu propio script de instalaci√≥n es una soluci√≥n pero no te llevar√≠a configuraci√≥n del snap.\nOpci√≥n 2 - Creamos nuestro propio script de instalaci√≥n\nAdem√°s de crear tu propio script, tambi√©n puedes hacer uso de algunos predeterminados como es Alfred o cualquier otro que encuentres y que te sea √∫til. Igualmente la manera de crear el nuestro propio es muy sencilla. Te ejemplifico uno:\n#!/bin/bash #Get ROOT access (only need to specify a password one time) echo \u0026lt;paswword\u0026gt; | sudo -S echo echo \u0026#34;Now you can use sudo without given password\u0026#34; #Install via apt sudo apt install app1 app2 app3 -y #Fix failed installations sudo apt install -f -y #Install via snap sudo snap install app1 app2 app3 Tras tener nuestro script solo nos queda darle permisos de ejecucci√≥n y ejecutarlo.\nMe quiero llevar las bases de datos que tengo configuradas en IntelliJ\nHe este caso he optado por copiar en un archivo txt las conexiones y tambi√©n el archivo donde IntelliJ almacena las claves que recuerda para la configuraci√≥n de una conexi√≥n. ¬øComo lo hice?, muy sencillo:\nPara copiar la configuraci√≥n de una conexi√≥n\nSi tienes varios data sources que quieres guardar, simplemente selecci√≥nalos todos a la vez y elige la misma opci√≥n que lo que har√° ser√° copiar todos a la vez.\nPara llevarte las contrase√±as\nVamos a cambiar como IntelliJ almacena las contrase√±as para que lo haga en un archivo que incluyamos en nuestro dotfile. Nos vamos a:\nFile | Settings | Appearance and behavior | System settings | Passwords y activamos la siguiente opci√≥n\nahora ya podemos a√±adir a nuestro dotfile el archivo que se muestra en el path.\nBusca ejemplos comunes que se apliquen a ti\nCada uno puede tener sus casos personales en los que tiene que guardar unas cosas u otras, pero llegados a este punto hay muchos que son comunes para usuarios de Linux, MacOS o Windows. Las configuraciones de la shell que uses, la configuraci√≥n de git, amazon wer services, scripts para agilizar los symlinks, etc. Seguro que por GitHub puedes encontrar muchos ejemplos como el de CodelyTV que te expliqu√© m√°s arriba. Te puedo ejemplificar uno propio muy sencillo a medida que he ido comprendiendo como trabajar con estos archivos.\nConclusi√≥n Con mi propia experiencia te puedo decir que lo mejor es que el proyecto debe vaya evolucionando a tus necesidades haciendo que crezca a medida que lo necesitas, de esta manera tendr√°s el control y no se volver√° un caos. No intentes a√±adir demasiado ya sea visto en otras plantillas o dem√°s si no lo comprendes.\n","date":"2021-01-09T00:00:00Z","permalink":"https://raulpadilladelgado.github.io/blog/p/versiona-tus-dotfiles/","title":"Versiona tus dotfiles"},{"content":"Introducci√≥n Los principio SOLID son convenciones en cuanto a dise√±o de software que ayudan a conseguir un c√≥digo m√°s mantenible, tolerante a cambios, y testeable.\nTodos los desarrolladores de un equipo deber√≠an tener nociones de dise√±o de software para fomentar la autonom√≠a y agilidad del equipo\nHuir de STUPID, el enemigo de SOLID S ‚Üí Singleton: Hay un objeto que lo contiene todo. No necesita inyecci√≥n de dependencias. Y se encuentra por todo el programa. Tiene demasiadas resposabilidades.\nT ‚Üí Tight Coupling: Fuertemente acoplado. Conoces la implementaci√≥n concreta del repositorio de usuario (un mysql por ejemplo), algo que dificulta el cambio de tipo de base de datos. El c√≥digo no es tolerante a cambios.\nU ‚Üí Untestability: C√≥digo intesteable. Muy visto en los singleton. C√≥digo muy junto sin ning√∫n tipo de inyecci√≥n de dependencias que nos lleva a tener un c√≥digo imposible de testear.\nP ‚Üí Premature Optimization: Realizar mucho m√°s c√≥digo del necesario atendiendo al futuro. Se debe pensar con vistas a futuro pero a ra√≠z de las posibles necesidades, no de un simple \u0026ldquo;por si acaso\u0026rdquo;.\nI ‚Üí Indescriptive Naming: Naming confuso que no refleja intencionalidad o significado alguno.\nD ‚Üí Duplication: Duplicaci√≥n del mismo c√≥digo en muchos lados que necesita de una abstracci√≥n o extracci√≥n a m√©todos o clases que solo tienen una responsabilidad y pueden ser parte de otra clase.\nUML Connotaciones negativas\nUn modelo de diagramas que tiene una metodologia de trabajo en cascada:\nEspecificaci√≥n de requisitos ‚Üí Desarrollo ‚Üí Testing\nUna forma de trabajo muy lineal que no entiende de cambios durante el ciclo de desarrollo (especificaci√≥n de requisitos), derivada de como se desarrollaba software hace tiempo.\nVentajas\nLenguaje de diagramas ilustrativo para nuestros dise√±os de software (clases e interacci√≥n entre ellas) Riguroso: Permite especificar hasta un nivel de detalle suficiente para identificar acoplamiento entre clases y sus relaciones sin ser verboso Agn√≥stico del lenguaje: No entra en detalles de implementaci√≥n si quiera al nivel de qu√© lenguaje de programaci√≥n se est√° usando\n¬øQu√© tipos hay?\nCasos de uso: se busca definir todos los posibles casos de uso (acciones) que pueda hacer un usuario\nSecuencia: Se trata de un diagrama que con el que podremos ver el flujo de nuestra aplicaci√≥n, representando c√≥mo interaccionan las clases (comunicaci√≥n entre objetos)\nClases: Este tipo de diagramas son muy populares y nos permiten ver no solo los atributos y m√©todos de cada clase, sino tambi√©n las diferentes relaciones de herencia, interfaces e implementaciones de estas. ¬øVentajas?:\n‚Üí Diagrama de clases con 4 garabatos para ponernos de acuerdo u obtener feedback de nuestro equipo antes de implementarlo de forma r√°pida\n‚Üí Documentar implementaciones ya existentes para facilitar la revisi√≥n de c√≥digo. Por ejemplo, a la hora de hacer una nueva Pull Request (PR), generar el diagrama desde IntelliJ/PhpStorm con 2 clics para adjuntar una imagen a la descripci√≥n de la PR.\nUML con IntelliJ Con esta herramienta podemos hacer diagramas de clases.\nSeleccionamos las que queremos ‚Üí Click derecho ‚Üí Diagrams ‚Üí Show Diagram\nNos encontraremos unas opciones tal que as√≠:\nCampos Constructor M√©todos Propiedades Inner clases Tambi√©n podemos mediante clic derecho sobre una clase abstracta a√±adir sus implementaciones al esquema:\nOtro truco es a√±adir las clases usando Espacio\nUn resumen r√°pido de lo que podemos hacer sobre diagramas en IntelliJ:\nS (Single responsability principle - SRP) ¬øQue es?\nUna clase = un concepto = una responsabilidad\nO lo que es lo mismo una sola raz√≥n para cambiar\n¬øComo?\nClases que funcionen como servicios con peque√±os objetivos acotados, entendi√©ndose un servicio como un orquestador que conecta nuestros modelos con infraestructura (servicios externos).\n¬øPor qu√©?\nBuscamos la alta cohesi√≥n entre la conexi√≥n entre componentes de nuestro sistema, robustez antes los cambios y evitamos la duplicidad de c√≥digo, ya que conseguiremos piezas m√°s reutilizables.\n¬øQu√© tener en cuenta?\nLos nombres ‚Üí Un nombre muy general como \u0026ldquo;OrderProcessor\u0026rdquo; da lugar a querer reutilizarlo para muchas cosas y acaba teniendo demasiadas funcionalidades, en su lugar busca un nombre m√°s concreto. Cuando respetamos el principio de responsabilidad √∫nica, es m√°s f√°cil introducir modularidad. Enti√©ndase modularidad como la propiedad que permite subdividir una aplicaci√≥n en partes m√°s peque√±as (llamadas m√≥dulos), cada una de las cuales debe ser tan independiente como sea posible de la aplicaci√≥n en s√≠ y de las restantes partes.\nOtros ejemplos Todo empieza en el controller\nCon una aplicaci√≥n basada en una API todo empieza con una petici√≥n a un endpoint. Es por ello que tenemos que empezar a cuidar los detalles desde ah√≠. Un controlador no necesita entender de contruir sentencias SQL, ni mucho menos de interactuar directamente con la base de datos. Un servicio es el encargado de realizar esto de ejecutar l√≥gica de negocio usando infraestructura. Por ello, haz que tu controlador solo reciba llamadas y la redirecione a un servicio dedicado a la causa.\nCuando un servicio y cuando no\nCuando la l√≥gica de negocio no tiene dependencias externas puede ir acoplada al modelo de dominio. Cuando ya existen esas dependencias es mejor tener un servicio externo que se encargue de inyectar por constructor las dependencias que necesite. Esto favorece las testabilidad y la cohesi√≥n.\nO (Open-Closed Principle OCP) El software deber√≠a estar abierto a extensi√≥n y cerrado a modificaci√≥n\nNos acoplamos a la interfaz, no a la implementaci√≥n espec√≠fica, por lo que podremos cambiar en cualquier momento a que objeto \u0026ldquo;medible\u0026rdquo; nos referimos.\nLo mismo podr√≠amos hacer con una clase abstracta que desde un principio defina como se calcula el porcentaje, y sus implementaciones extiendan de alguna manera dicho c√°lculo.\nUna clase abstracta es √∫til cuando las implementaciones van a tener una parte com√∫n que siempre se repite, como un sistema de bonificaciones que tienen una general y otras espec√≠ficas. Si esto no ocurre usaremos interfaces, que permiten desacoplar entre capas, el detalle aparecer√° en las implementaciones.\nL (Liskov Substitution Principle - LSP) Cualquier clase hija de otra, deber√≠a poder reemplazada sin alterar el sistema por otra clase hija de la misma clase\nEjemplo sencillo En este ejemplo el cuadrado extiende del rect√°ngulo, porque a groso modo son lo mismo, pero a la hora de la verdad tienen comportamientos diferentes, por lo que cuando vamos a utilizar los m√©todos de la clase rect√°ngulo en la clase cuadrado, tenemos que hacer unos apa√±os que aunque funcionen y el c√≥digo act√∫e correctamente, no estamos respetando el LSP, ya que la clase hija (cuadrado) necesita una serie de modificaciones en cuanto a comportamiento para poder extender y as√≠ no ser√° posible reemplazar f√°cilmente un cuadrado por otra figura geom√©trica que extienda del rect√°ngulo.\nclass Rectangle { private Integer length; private Integer width; Rectangle(Integer length, Integer width) { this.length = length; this.width = width; } void setLength(Integer length) { this.length = length; } void setWidth(Integer width) { this.width = width; } Integer getArea() { return this.length * this.width; } } final class Square extends Rectangle { Square(Integer lengthAndWidth) { super(lengthAndWidth, lengthAndWidth); } @Override public void setLength(Integer length) { super.setLength(length); super.setWidth(length); } @Override public void setWidth(Integer width) { super.setLength(width); super.setWidth(width); } } final class SquareShould { @Test void not_respect_the_liskov_substitution_principle_breaking_the_rectangle_laws_while_modifying_its_length() { Integer squareLengthAndWidth = 2; Square square = new Square(squareLengthAndWidth); Integer newSquareLength = 4; square.setLength(newSquareLength); Integer expectedAreaTakingIntoAccountRectangleLaws = 8; assertNotEquals(expectedAreaTakingIntoAccountRectangleLaws, square.getArea()); } } Que las subclases respeten el contrato definido en la clase padre es justamente lo que nos permite cumplir con este principio para mantener una correctitud funcional\nI (Interface Segregation Principle - ISP) Ning√∫n cliente deber√≠a verse forzado a depender de m√©todos que no usa\nLas interfaces se debe de desarrollar acorde a las necesidades del cliente que las usa, y no de sus implementaciones.\n‚õî Header Interfaces ‚Üí Una interfaz que ha sido extraida o basada de una clase (por lo que ahora la interfaz es padre de la clase), y que se crea con todos los m√©todos que dicha clase ten√≠a o necesitaba.\n‚úÖ Role Interface ‚Üí Una interfaz que ha sido creada a partir de la definici√≥n previa de un caso de uso del cliente.\nConseguiremos un c√≥digo con bajo acoplamiento estructural\nD (Dependency inversion principle - DIP) M√≥dulos de alto nivel no deber√≠an depender de los de bajo nivel. Ambos deber√≠an depender de abstracciones.\nM√≥dulo ‚Üí Clases\nEj.: Un caso de uso no debe depender de una implementaci√≥n, sino que deber√≠a hacerlo de una abstracci√≥n como ser√≠a la interfaz.\nEste principio busca mucho la inyecci√≥n de dependencias, que ser√≠a el acto de recibir par√°metros en constructor.\nLa finalidad es la substituci√≥n de implementaciones y mejorar la testabilidad de las clases.\n","date":"2020-11-28T00:00:00Z","permalink":"https://raulpadilladelgado.github.io/blog/p/principios-solid/","title":"Principios SOLID"},{"content":"1. JWT Authentication 1.1. ¬øQue es JWT? Dicho de forma sencilla, JWT, es una autenticaci√≥n basada en tokens enviados a las peticiones por cabecera.\nPara m√°s informaci√≥n: https://jwt.io/introduction/\n1.2. ¬øComo funciona JWT? Para obtener el token de acceso, el cliente env√≠a una solicitud de inicio de sesi√≥n al servidor de autenticaci√≥n con el nombre de usuario y la contrase√±a en el cuerpo de la solicitud.¬†El servidor valida el nombre de usuario y la contrase√±a, luego devuelve un token de acceso. El cliente debe almacenar el token de acceso en alg√∫n lugar y debe enviarlo con cada solicitud al servidor en el¬†encabezado de¬†Autorizaci√≥n. Luego, el servidor valida el token de acceso y, si es v√°lido, atiende la solicitud al cliente. 1.3. ¬øComo se implementa JWT? ApplicationUser.java En primer definiremos el modelo\npackage com.raulpadilla.domain; import javax.persistence.*; @Entity @Table(name = \u0026#34;credentials\u0026#34;) public class ApplicationUser { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; private String username; private String password; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } ApplicationUserRepository.java Definimos un repositorio para el modelo creado anteriormente\npackage com.raulpadilla.infrastructure.repository; import com.raulpadilla.domain.ApplicationUser; import org.springframework.data.jpa.repository.JpaRepository; public interface ApplicationUserRepository extends JpaRepository\u0026lt;ApplicationUser, Integer\u0026gt; { ApplicationUser findByUsername(String username); } ApplicationUserService.java Definimos un servicio con opere con el repositorio\npackage com.raulpadilla.infrastructure.service; import com.raulpadilla.domain.ApplicationUser; import com.raulpadilla.infrastructure.repository.ApplicationUserRepository; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import org.springframework.stereotype.Service; @Service public class ApplicationUserService { private ApplicationUserRepository applicationUserRepository; private BCryptPasswordEncoder bCryptPasswordEncoder; public ApplicationUserService(ApplicationUserRepository applicationUserRepository, BCryptPasswordEncoder bCryptPasswordEncoder) { this.applicationUserRepository = applicationUserRepository; this.bCryptPasswordEncoder = bCryptPasswordEncoder; } public void save(ApplicationUser applicationUser) { applicationUser.setPassword(bCryptPasswordEncoder.encode(applicationUser.getPassword())); applicationUserRepository.save(applicationUser); } } SecurityConstants.java Una serie de constantes que usaremos m√°s adelante cuando configuremos Spring Security y el posterior login JWT.\npackage com.raulpadilla.infrastructure.security; public class SecurityConstants { public static final String SECRET = \u0026#34;SecretKeyToGenJWTs\u0026#34;; public static final long EXPIRATION_TIME = 864_000_000; // 10 days public static final String TOKEN_PREFIX = \u0026#34;Bearer \u0026#34;; public static final String HEADER_STRING = \u0026#34;Authorization\u0026#34;; public static final String SIGN_UP_URL = \u0026#34;/users/sign-up\u0026#34;; public static final String LOGIN_URL = \u0026#34;/login\u0026#34;; } ApplicationUserDetailsService.java Servicio que implementa que el que usa Spring por defecto con el objetivo de definir como se debe comportar el m√©todo que tras verificar que el usuario existe lo pone en el contexto que conoce Spring para saber que el usuario tiene una sesi√≥n iniciada.\npackage com.raulpadilla.infrastructure.service; import com.raulpadilla.domain.ApplicationUser; import com.raulpadilla.infrastructure.repository.ApplicationUserRepository; import org.springframework.scheduling.annotation.Async; import org.springframework.security.core.userdetails.User; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.security.core.userdetails.UsernameNotFoundException; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import org.springframework.stereotype.Service; import static java.util.Collections.emptyList; @Service public class ApplicationUserDetailsService implements UserDetailsService { private ApplicationUserRepository applicationUserRepository; public ApplicationUserDetailsService(ApplicationUserRepository applicationUserRepository, BCryptPasswordEncoder bCryptPasswordEncoder) { this.applicationUserRepository = applicationUserRepository; } @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { ApplicationUser applicationUser = applicationUserRepository.findByUsername(username); if (applicationUser == null) { throw new UsernameNotFoundException(username); } return new User(applicationUser.getUsername(), applicationUser.getPassword(), emptyList()); } } JWTAuthenticationFilter.java El filtro que se encarga de autenticar al usuario tras recibir unas credenciales. El filtro ser√° usado en un archivo de configuraci√≥n de seguridad que definiremos m√°s adelante.\npackage com.raulpadilla.infrastructure.security; import com.auth0.jwt.JWT; import com.fasterxml.jackson.databind.ObjectMapper; import com.raulpadilla.domain.ApplicationUser; import org.springframework.security.authentication.AuthenticationManager; import org.springframework.security.authentication.UsernamePasswordAuthenticationToken; import org.springframework.security.core.Authentication; import org.springframework.security.core.AuthenticationException; import org.springframework.security.core.userdetails.User; import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter; import javax.servlet.FilterChain; import javax.servlet.ServletException; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.util.ArrayList; import java.util.Date; import static com.auth0.jwt.algorithms.Algorithm.HMAC512; import static com.raulpadilla.infrastructure.security.SecurityConstants.*; public class JWTAuthenticationFilter extends UsernamePasswordAuthenticationFilter { private AuthenticationManager authenticationManager; public JWTAuthenticationFilter(AuthenticationManager authenticationManager) { this.authenticationManager = authenticationManager; } @Override public Authentication attemptAuthentication(HttpServletRequest req, HttpServletResponse res) throws AuthenticationException { try { ApplicationUser creds = new ObjectMapper() .readValue(req.getInputStream(), ApplicationUser.class); return authenticationManager.authenticate( new UsernamePasswordAuthenticationToken( creds.getUsername(), creds.getPassword(), new ArrayList\u0026lt;\u0026gt;()) ); } catch (IOException e) { throw new RuntimeException(e); } } @Override protected void successfulAuthentication(HttpServletRequest req, HttpServletResponse res, FilterChain chain, Authentication auth) throws IOException, ServletException { String token = JWT.create() .withSubject(((User) auth.getPrincipal()).getUsername()) .withExpiresAt(new Date(System.currentTimeMillis() + EXPIRATION_TIME)) .sign(HMAC512(SECRET.getBytes())); res.addHeader(HEADER_STRING, TOKEN_PREFIX + token); } } JWTAuthorizationFilter.java Cuando el usuario se ha autenticado correctamente es hora de ver si tiene autorizaci√≥n para acceder a determinados recursos, aqu√≠ entra en juego este filtro. Tambi√©n se usar√° en el archivo de configuraci√≥n definido anteriormente.\npackage com.raulpadilla.infrastructure.security; import com.auth0.jwt.JWT; import com.auth0.jwt.algorithms.Algorithm; import org.springframework.security.authentication.AuthenticationManager; import org.springframework.security.authentication.UsernamePasswordAuthenticationToken; import org.springframework.security.core.context.SecurityContextHolder; import org.springframework.security.web.authentication.www.BasicAuthenticationFilter; import javax.servlet.FilterChain; import javax.servlet.ServletException; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.util.ArrayList; import static com.raulpadilla.infrastructure.security.SecurityConstants.HEADER_STRING; import static com.raulpadilla.infrastructure.security.SecurityConstants.SECRET; import static com.raulpadilla.infrastructure.security.SecurityConstants.TOKEN_PREFIX; public class JWTAuthorizationFilter extends BasicAuthenticationFilter { public JWTAuthorizationFilter(AuthenticationManager authManager) { super(authManager); } @Override protected void doFilterInternal(HttpServletRequest req, HttpServletResponse res, FilterChain chain) throws IOException, ServletException { String header = req.getHeader(HEADER_STRING); if (header == null || !header.startsWith(TOKEN_PREFIX)) { chain.doFilter(req, res); return; } UsernamePasswordAuthenticationToken authentication = getAuthentication(req); SecurityContextHolder.getContext().setAuthentication(authentication); chain.doFilter(req, res); } private UsernamePasswordAuthenticationToken getAuthentication(HttpServletRequest request) { String token = request.getHeader(HEADER_STRING); if (token != null) { // parse the token. String user = JWT.require(Algorithm.HMAC512(SECRET.getBytes())) .build() .verify(token.replace(TOKEN_PREFIX, \u0026#34;\u0026#34;)) .getSubject(); if (user != null) { return new UsernamePasswordAuthenticationToken(user, null, new ArrayList\u0026lt;\u0026gt;()); } return null; } return null; } } WebSecurity.java Finalmente configuramos la seguridad que afecten a nuestras APIs agreg√°ndole los filtro creados anteriormente.\npackage com.raulpadilla.infrastructure.security; import com.raulpadilla.infrastructure.service.ApplicationUserDetailsService; import org.springframework.http.HttpMethod; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.config.http.SessionCreationPolicy; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import org.springframework.web.cors.CorsConfiguration; import org.springframework.web.cors.CorsConfigurationSource; import org.springframework.web.cors.UrlBasedCorsConfigurationSource; import org.springframework.context.annotation.Bean; import java.util.Arrays; import static com.raulpadilla.infrastructure.security.SecurityConstants.LOGIN_URL; import static com.raulpadilla.infrastructure.security.SecurityConstants.SIGN_UP_URL; @EnableWebSecurity public class WebSecurity extends WebSecurityConfigurerAdapter { private ApplicationUserDetailsService userDetailsService; private BCryptPasswordEncoder bCryptPasswordEncoder; public WebSecurity(ApplicationUserDetailsService userDetailsService, BCryptPasswordEncoder bCryptPasswordEncoder) { this.userDetailsService = userDetailsService; this.bCryptPasswordEncoder = bCryptPasswordEncoder; } @Override protected void configure(HttpSecurity http) throws Exception { http.cors().and().csrf().disable().authorizeRequests() .antMatchers(HttpMethod.POST, SIGN_UP_URL).permitAll() .antMatchers(HttpMethod.POST, LOGIN_URL).permitAll() .anyRequest().authenticated() .and() .addFilter(new JWTAuthenticationFilter(authenticationManager())) .addFilter(new JWTAuthorizationFilter(authenticationManager())) // this disables session creation on Spring Security .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS); } @Override public void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userDetailsService).passwordEncoder(bCryptPasswordEncoder); } @Bean CorsConfigurationSource corsConfigurationSource() { CorsConfiguration configuration = new CorsConfiguration(); configuration.setAllowedOrigins(Arrays.asList(\u0026#34;*\u0026#34;)); configuration.setAllowedMethods(Arrays.asList(\u0026#34;*\u0026#34;)); configuration.setAllowedHeaders(Arrays.asList(\u0026#34;*\u0026#34;)); configuration.setAllowCredentials(true); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(\u0026#34;/**\u0026#34;, configuration); return source; } } ApplicationUserController.java Para probar que todo funciona correctamente creamos el controlador que interact√∫e con el servicio de usuarios\npackage com.raulpadilla.application; import com.raulpadilla.domain.ApplicationUser; import com.raulpadilla.infrastructure.service.ApplicationUserService; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import java.io.IOException; @RestController @RequestMapping(\u0026#34;/users\u0026#34;) public class ApplicationUserController { private final ApplicationUserService applicationUserService; public ApplicationUserController(ApplicationUserService applicationUserService) { this.applicationUserService = applicationUserService; } @PostMapping(\u0026#34;/sign-up\u0026#34;) public void signUp(@RequestBody ApplicationUser applicationUser) throws IOException, InterruptedException { applicationUserService.save(applicationUser); } } Se defini√≥ el m√©todo para crear un usuario, para hacer login usaremos /login que est√° controlado por Spring Security y por eso no tenemos que configurarlo nosotros. Dicha request devolver√° el token JWT que necesitamos enviar a otras peticiones que hagamos para que podamos ser autenticados y autorizados correctamente.\n","date":"2020-10-02T00:00:00Z","permalink":"https://raulpadilladelgado.github.io/blog/p/jwt-auth-en-spring-boot/","title":"JWT Auth en Spring Boot"},{"content":"Diferencias Scrum: Iteraciones de tiempo fijo (Sprints). La pila del producto (conjunto de tareas) tiene que tener al menos el tama√±o de un Sprint. Limita el WIP (WorkInProgress) por iteraci√≥n. No se permiten cambiar las tareas del Sprint, solo el Sprint. Roles de Scrum Master, de Product Owner y del equipo\nKanban:Trabajo continuo. Se arrastran las nuevas tareas por el panel hasta que lleguen a su estado final. Limita el WIP por el flujo de trabajo. Se puede modificar la tarea hasta que entra en flujo No existen roles.\nUso Kanban y lo uso as√≠ Los consejos b√°sicos que he aprendido usando este tipo de workflow:\nEntiende como trabajas y visualizalo Para aumentar el flujo (m√°s cosas en done en menos tiempo) debemos limitar el work in progress. Las cosas se deben terminar por lo que no es necesario que todos trabajemos en algo, si no que todos deberimos trabajar en terminar algo. Menos tarjetas, menos detalle, m√°s enfoque de lo que queremos conseguir, m√°s visualizaci√≥n Se pueden definir clases de servicio para cubrir las necesidades que pueda tener un equipo. Yo he visto algunas para un enfoque concreto debido a la carga de trabajo que acontec√≠a en aquel momento:\nexpedite fixed delivery date standard intangible\nLas √©picas son como un contenedor que contienen historias que por si solas no representan nada a la empresa, hasta que no se termina todo lo asociado a la √©pica no tiene un valor real para el negocio. Una historia que por si sola aporta valor no necesita estar en una √©pica.\nExisten dos formas de interpretar como se empieza a trabajar seg√∫n el tablero:\nTrabajar en pull ‚Üí de derecha a izquierda, de lo m√°s terminado a lo que menos.\nTrabajar en push ‚Üí al rev√©s, cada persona tiene asociado algo y no intenta terminar cualquier otra cosa que est√© m√°s al final.\nComo nuestro objetivo es poder aportar valor a la empresa cuanto antes, la mejor opci√≥n es sin duda trabajar en pull.\nConclusi√≥n El punto clave para decidir cuando recurrir a uno o a otro pasa por entender que para Scrum el prop√≥sito es maximizar el valor entregado, mientras que para Kanban lo importantes es optimizar el flujo de trabajo y aportar valor r√°pidamente.\nSi por alguna raz√≥n no se pueda tener una comunicaci√≥n efectiva en un equipo, lo mejor ser√≠a usar Scrum ya que garantiza el compromiso del equipo y de las personas con las entregas, Si el equipo es capaz de sincronizarse muy bien, no hay ning√∫n problema para usar Kanban y tener un desarrollo fluido.\n","date":"2020-10-02T00:00:00Z","permalink":"https://raulpadilladelgado.github.io/blog/p/scrum-vs-kanban/","title":"Scrum vs Kanban"},{"content":"Recientemente estuve realizando una formaci√≥n que impart√≠a Carlos Ble. Dicha formaci√≥n consist√≠a en aprender trucos y consejos para aplicar a la hora de hacer refactor. Lejos de ser solo una charla, los alumnos estuvimos gran parte del tiempo practicando lo que √≠bamos aprendiendo con cada ejercicio, y ahora yo quiero hablar un poco acerca de ello.\nTras concluir esta formaci√≥n mi perspectiva acerca del refactor cambi√≥ mucho. Generalmente, tendemos a buscar los refactors m√°s complicados, esos que simplifican 20 l√≠neas de c√≥digo en la mitad o casos por el estilo. Hay entender que el refactor no consiste en hacer el c√≥digo lo m√°s peque√±o posible, porque menos c√≥digo no es directamente proporcional con c√≥digo m√°s simple. Estuve viendo muchos ejemplos de que con cambios muy simple como puede ser un cambio de nombre llegas a lograr una mejor sem√°ntica en tu c√≥digo. Los refactor en c√≥digo legacy deben empezarse por algo sencillo, es decir, desde fuera hacia dentro de un m√©todo o una clase.\nNo quiere decir que existen casos para hacer trabajos de refactor m√°s complejos, pero siempre y cuando nos aporten. Al final de este post comparto y repositorio de mi cuenta de GitHub para que pod√°is que ejemplo estuvimos realizando.\nResumir una formaci√≥n de este estilo no es posible ya que hay que estar practicando cada concepto y dedicandole un tiempo para reflexionar acerca de ello para poder interiorizarlo, pero si tuviese que destacar los puntos claves que me llevo de esta formaci√≥n ser√≠an los siguientes:\nIDE\nCon herramientas tan avanzadas como IntelliJ los refactors deben ser lo m√°s autom√°ticos posibles. Los refactors del IDE son completamente seguros y terminan ahorr√°ndote tiempo que si lo hicieses de una forma m√°s manual. M√°s all√° de las ventajas de la herramienta, el porqu√© deber√≠an ser lo m√°s autom√°tico posible responde a la garant√≠a de que en ning√∫n momento el c√≥digo se rompe, que es lo que precisamente un refactor nunca deber√≠a hacer. Inline method o Inline variable ‚Üí Sustituye su valor o funcionamiento en los lugares donde se est√© llamando. Muy √∫til para reemplazar todas las llamadas de un m√©todo viejo por uno nuevo. Introduce parameter object ‚Üí √ötil para cambiar un primitivo de un m√©todo por un objeto que contiene como propiedad dicho primitivo. Wrap return value ‚Üí Para cambiar el retorno de una funci√≥n Introduce funtional parameter ‚Üí Para declarar un par√°metro funcional en la funci√≥n y ejecutar una cosa o otra dependiendo de dicho par√°metro. Encapsulate fields ‚Üí para cambiar la visibilidad de un campo de la clase, para que uno p√∫blico se vuelva privado. Se ocupar√° de generar los getter y setter que le indiquemos. Pull members up ‚Üí lleva los m√©todos a la clase padre Use interface where is possible ‚Üí Usar√° la clase padre donde sea posible Legacy Code\nUn legacy code puede llegar a ser muy complejo de entender y sobre todo de refactorizar. Lo m√°s importante para √©stas situaciones es disponer de una buena pila de test que prueben la funcionalidad, y tras esto si podemos refactorizar con la garant√≠a de que si por error rompemos algo lo sabremos de inmediato con la ejecucci√≥n de los test y dejaremos el c√≥digo a un estado completamente funcional con un control de versiones. Cuando trabajamos con c√≥digo legacy es muy importante tener cuidado con los cambios que hacemos cuando son a estados de un objeto, asignaciones y condicionales. Son la principal casa de romper un c√≥digo legacy. Con c√≥digo legacy es muy √∫til comprobar la geometr√≠a del c√≥digo. Puedes poner la letra muy peque√±a y ver as√≠ la vista general del c√≥digo, o puedes usar extensiones como esta: CodeGlance Otros\nTodo puede ser testeado con un poco de creatividad. ¬øComo testear que un m√©todo escribe lo correcto en la consola?, podr√≠amos intentar capturar la salida de la consola, pero hay algo mucho m√°s simple para el test como es extender la clase con dicho m√©todo y trucar el comportamiento que escribe en consola por almacenarlo en una variable y comprobar as√≠ esa variable. Para terminar, me gustar√≠a compartir el repositorio donde estuve trabajando los ejercicios de esta formaci√≥n. No es posible ver como se hicieron los refactors autom√°ticos, pero s√≠ el resultado final.\nraulpadilladelgado/Refactor-Java-IntelliJ-1\n","date":"2020-09-27T00:00:00Z","permalink":"https://raulpadilladelgado.github.io/blog/p/taller-refactor-java--intellij/","title":"Taller refactor Java + IntelliJ"},{"content":"Hoy en d√≠a es f√°cil adquirir a un precio asequible un dispositivo con suficiente memoria de almacenamiento como para que no lo llenemos con un uso normal. Pero a√∫n as√≠, es perfectamente comprensible que llegues al punto de necesitar sacar unos megabytes de almacenamiento por alg√∫n lado.\nHoy ofrezco una soluci√≥n que no solo te ayudar√° a lograr m√°s almacenamiento para tu Android, lograr√°s un mejor rendimiento, y lo mejor de todo es que lo amar√°s porque tendr√°s el control sobre lo que est√° instalado en tu dispositivo, solo t√∫ eliges que est√° y que no.\nSi esto te interesa, te animo a que sigas las instrucciones detalladas en mi proyecto de Github.\nraulpadilladelgado/DebloatAndroid\n","date":"2020-09-12T00:00:00Z","permalink":"https://raulpadilladelgado.github.io/blog/p/debloat-android/","title":"Debloat Android"},{"content":"Problema Intentas hacer un pull pero tus cambios locales entran en conflicto con los del repo remoto. La soluci√≥n que usar√≠a ser√≠a hacer un stash de mis cambios locales, que ser√≠a algo as√≠ como dejarlos de lado por el momento, y despu√©s hacer el pull. Finalmente incluir√≠amos los cambios que hab√≠amos dejado de lado.\nExiste una forma de automatizar esto, y lo podr√≠amos hacer mediante la configuraci√≥n de Git, para que cuando hagamos un pull, nos deje de lado nuestros cambios locales y despu√©s sea decisi√≥n nuestra incluirlos o no despu√©s del pull.\nProceso Lo primero es configurar esto en git (tambi√©n aparece la configuraci√≥n para lograr lo mismo cuando hagamos rebase)\ngit config --global pull.rebase true git config --global rebase.autoStash true Despu√©s vendr√≠a el git pull, que nos dir√° que nos ha hecho un autostash.\ngit pull ---------- Created autostash: 094ad5c HEAD is now at d39c25c repo1 - readme First, rewinding head to replay your work on top of it... Fast-forwarded master to 6b6e1d4262fd5bc8d2b974f81222003a6c67fea6. Applying autostash resulted in conflicts. Your changes are safe in the stash. You can run \u0026#34;git stash pop\u0026#34; or \u0026#34;git stash drop\u0026#34; at any time. Para incluir los cambios del stash podemos realizar un git stash pop\nExtra Podemos listar todos los stash disponibles\ngit stash list --------------- stash@{0}: autostash Y realizar un git stash pop de uno concreto\ngit stash pop [--index] ","date":"2020-09-06T00:00:00Z","permalink":"https://raulpadilladelgado.github.io/blog/p/git-autostash/","title":"Git autostash"},{"content":"Revertir √∫ltimo commit Importante: Un --soft borrar√° el √∫ltimo commit pero mantendr√° los cambios que has hecho. Un --hard borrar√° el √∫ltimo commit y desechar√° los cambios que has hecho\nRevertir √∫ltimo commit (local) Con este comando desaparecer√° de tu rama el √∫ltimo commit que has hecho.\ngit reset --hard HEAD~1 Revertir √∫ltimo commit (remoto) Si has llegado a subirlo al repositorio remoto, es tan sencillo como realizar el proceso en local y despu√©s actualizar el repo remoto (push).\ngit reset --hard HEAD~1 git push origin -f Revertir commit espec√≠fico En primer lugar tendremos que ubicarnos en el commit al que queremos volver. Para buscarlo podemos usar git log que nos listar√° la historia de la rama actual (donde apunte el head ahora mismo) y una vez localizado el identificador del commit haremos que master apunte a ese commit:\ngit checkout \u0026lt;commit-id\u0026gt; . üí° Es importante el . al final, ya que indicar√° que queremos apuntar al commit indicado pero dentro la rama actual. Si no fuese tu intenci√≥n no ser√° necesario usarlo.\nFinalmente, tendremos que hacer push de lo cambios para que sean efectivos en el repositorio remoto:\ngit add . git commit -m \u0026#34;Reverting to \u0026lt;commit-id\u0026gt;\u0026#34; git push ","date":"2020-09-05T00:00:00Z","permalink":"https://raulpadilladelgado.github.io/blog/p/revertir-commits-en-git/","title":"Revertir commits en Git"},{"content":"El siguiente ejemplo se ha desarrollado con Spring Boot.\nHacemos ciertos ajustes en applicacion.properties para configurar la conexi√≥n a la DB.\nspring.jpa.database=POSTGRESQL spring.datasource.platform=postgres spring.datasource.url=jdbc:postgresql://localhost:5432/postgres spring.datasource.username=postgres spring.datasource.password=postgres spring.jpa.show-sql=true spring.jpa.generate-ddl=true spring.jpa.hibernate.ddl-auto=create-drop spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true Creamos y arrancamos el contenedor en Docker que use la imagen de PostgreSQL.\ndocker run --name my_postgres -p 5432:5432 -e POSTGRES_PASSWORD=postgres postgres Listo, ya podemos trabajar con nuestra base de datos en local ü•≥\nPara cualquier duda el proyecto se puede consultar aqu√≠: https://github.com/raulpadilladelgado/Local-Database-Docker\n","date":"2020-08-12T00:00:00Z","permalink":"https://raulpadilladelgado.github.io/blog/p/base-de-datos-local-con-docker/","title":"Base de datos local con docker"},{"content":"Introducci√≥n e instalaci√≥n Este post surge por mi deseo de iniciar en el desarrollo de tests de c√≥digo PHP mediante PHPUnit, un acercamiento que sirva para asimilar conceptos b√°sicos. ¬°Empezamos!.\nLo primero que necesitamos es instalar PHPUnit en el proyecto, y √©sto lo realizaremos gracias a composer.\ncomposer require --dev phpunit/phpunit ^latest Tr√°s esto, en nuestra primera clase de test, debemos extender de TestCase, contenido en:\nvendor ‚Üí phpunit ‚Üí framework ahora es momento de hacer la primera aserci√≥n\nuse PHPUnit\\\\Framework\\\\TestCase; class Test extends TestCase { public function test_render() { $welcome = \u0026#34;hola\u0026#34;; $this-\u0026gt;assertEquals($welcome,\u0026#34;hola\u0026#34;); } } Como podemos ver, se ha extendido de la clase TestCase, y se ha realizado una aserci√≥n para comprobar simplemente que hemos realizado bien el proceso de instalar phpunit y de empezar a usarlo bien. Para probar si el test ejecuta correctamente, lo podemos hacer mediante la ayuda del IDE a elecci√≥n, o mediante el siguiente comando en el que se le indica ruta de phpunit, ruta de archivo de test y formato de salida(opcional):\nvendor/bin/phpunit SlugTest.php --color PHPUnit con Laravel Si vamos a trabajar con Laravel, la integraci√≥n de PHPUnit ya viene instalada por defecto. El archivo phpunit.xml de la carpeta vendor, es un archivo de configuraci√≥n en el que ya vienen predefinidas las propiedades como la salida a color que especificabamos antes (\u0026ndash;color), o incluso dos directorios definidos para test (dentro de ) como son Unit y Feature.\nAserciones La idea no es otra que recopilar ciertas aserciones con el fin de ver la forma en que trabaja el framework para realizar pruebas. En todas las pruebas, se ejecutaran m√©todos de aserciones haciendo referencia a \u0026ldquo;$this\u0026rdquo;, que se refiere a la clase actual que extiende de TestCase, por lo que tiene los m√©todos heredados de PHPUnit. Por otro lado, cabe destacar que en cada m√©todo de prueba, se debe usar la nomenclatura \u0026ldquo;test*\u0026rdquo; para que se interprete como un test.\n\u0026lt;?php use PHPUnit\\\\Framework\\\\TestCase; class SimpleTest extends TestCase { /*TRUE OR FALSE*/ public function test_true() { $this-\u0026gt;assertTrue(true); } public function test_false() { $this-\u0026gt;assertFalse(false); } /*EQUALS OR SAME*/ public function test_equals() { $this-\u0026gt;assertEquals(10, \u0026#34;10\u0026#34;); } public function test_not_equals() { $this-\u0026gt;assertNotEquals(10, 20); } public function test_same() { $this-\u0026gt;assertSame(10, 10); } public function test_not_same() { $this-\u0026gt;assertNotSame(10, \u0026#34;10\u0026#34;); } /*TYPES*/ public function test_types() { $this-\u0026gt;assertIsArray([1, 2, 3]); } public function test_empty() { $this-\u0026gt;assertEmpty(\u0026#34;\u0026#34;); $this-\u0026gt;assertEmpty([]); } /*ARRAYS*/ public function test_count() { $this-\u0026gt;assertCount(2, [1, 2]); } public function test_hash_key() { $this-\u0026gt;assertArrayHasKey(\u0026#34;color\u0026#34;, [\u0026#34;color\u0026#34; =\u0026gt; \u0026#34;azul\u0026#34;]); } } ","date":"2020-07-13T00:00:00Z","permalink":"https://raulpadilladelgado.github.io/blog/p/phpunit-basics/","title":"PHPUnit basics"},{"content":"Mi implementaci√≥n para este ejercicio de programaci√≥n se basa en tener una clase \u0026ldquo;Cell\u0026rdquo;, que tendr√° un atributo llamado \u0026ldquo;isAlive\u0026rdquo;(haciendo referencia a si la c√©lula vive o no), y adem√°s otra clase llamada \u0026ldquo;World\u0026rdquo; que tiene un diccionario tipo clave(Integer) valor(Cell).\nEn la clase \u0026ldquo;World\u0026rdquo; existe un m√©todo que cambia \u0026ldquo;de generaci√≥n\u0026rdquo;, que comprueba que las c√©lulas muertas que tengan exactamente tres c√©lulas vecinas vivas(tres posiciones seguidas del diccionario con valor \u0026ldquo;isAlive\u0026rdquo; a true) revivan. Adem√°s, comprueba tambi√©n que una c√©lula viva que tenga dos o tres vecinos, siga con vida, en cambio, la c√©lula que tenga menos de dos o m√°s de tres vecinos, debe morir por \u0026ldquo;sobrepoblaci√≥n o soledad\u0026rdquo;.\nPara entrar m√°s en detalle, comparto repositorio de GitHub con la soluci√≥n que he descrito.\n‚Üí¬†TheGameOfLife¬†‚Üê ","date":"2020-07-06T00:00:00Z","permalink":"https://raulpadilladelgado.github.io/blog/p/kata-el-juego-de-la-vida/","title":"Kata El juego de la vida"},{"content":"Interfaces Es una colecci√≥n de m√©todos abstractos y propiedades constantes. En las interfaces se especifica qu√© se debe hacer pero no su implementaci√≥n. Ser√°n las clases que implementen estas interfaces las que describen la l√≥gica del comportamiento de los m√©todos. Las clases que hereden de la interfaz solo podr√°n hacerlo de ella.\nUn momento muy √∫til en el que declarar una interfaz, puede ser cuando vemos que dos clases tienen el mismo contrato, por ejemplo, tenemos una clase coche y una clase moto, que implementan los mismos m√©todos de formas distintas.\nSu utilidad se encuentra cuando buscamos muchas implementaciones, por lo que si la idea es solo generar una implementaci√≥n, deber√≠amos basarnos en una sola clase. El hecho de estar obligando a pasar primero por la interfaz a la hora de entender el c√≥digo, se hace tedioso cuando el objetivo es s√≥lo entender el comportamiento de una clase.\nOtro aspecto a cuidar, es el nombre que reciba la interfaz. Incluir en los nombres de interfaces el prefijo \u0026ldquo;I\u0026rdquo; o en el de las implementaciones el sufijo \u0026ldquo;Impl\u0026rdquo;, solo muestra un mal nombre que no describe como funciona el sistema. Se debe buscar nombres que cuenten una historia, por lo que si una interfaz se llama \u0026ldquo;Encryptor\u0026rdquo;, su implementaci√≥n deber√≠a usar ese nombre de base, pero a√±adiendo que implementa, como puede ser \u0026ldquo;SimpleEncryptor\u0026rdquo;.\ninterface Encryptor{ String Encrypt(String text); } public class SimpleEncryptor implements Encryptor{ @Override public String Encrypt(String text) { return text.toUpperCase(); } } public class ComplexEncryptor implements Encryptor{ @Override public String Encrypt(String text) { return text.toUpperCase().concat(\u0026#34;_SECRET\u0026#34;); } } Clases abstractas Otra opci√≥n que tenemos, ser√≠a usar una clase abstracta. A diferencia de la interfaz, √©sta si define una base sobre la que trabajar las implementaciones, por lo que la idea de usarla es mejorar dicha clase padre, ya sea a√±adiendo comportamiento o especificando uno nuevo.\nTanto como con las interfaces, como con las clases abstractas los m√©todos suelen definirse como \u0026ldquo;protected\u0026rdquo; para que solo las implementaciones puedan usarlo.\npublic abstract class Encryptor{ String Encrypt(String text){ return text.toUpperCase(); } } public class EncryptorWithOriginalFunctionality extends Encryptor { @Override public String Encrypt(String text){ String original = super.Encrypt(text); return original.concat(\u0026#34;_SECRET\u0026#34;); } } public class EncryptorWithoutOriginalFunctionality extends Encryptor { @Override public String Encrypt(String text){ return text.concat(\u0026#34;_SECRET\u0026#34;); } } Gen√©ricos Cuando queremos aprovechar un m√©todo para que opere con distintos tipos de datos, como puede ser una cadena de texto o un entero, surge la idea de utilizar algo m√°s general como puede la clase Object, ya que dicha ambos tipos de datos son de dicha clase. El problema es que si tenemos una colecci√≥n que contiene diferentes tipos de datos, no obligamos a usar casteo, algo que a la hora de error no nos detalla mucho sobre el porque ocurre el fallo m√°s all√° de no poder realizar un casteo.\npublic class Cache { List\u0026lt;Object\u0026gt; objects = new ArrayList\u0026lt;\u0026gt;(); void addObjects() { objects.add(\u0026#34;a\u0026#34;); objects.add(1); } String getObject() { return (String) objects.get(0); } } @Test void simple_test() { Cache cache = new Cache(); cache.addObjects(); assertThat(cache.getObject()).isEqualTo(\u0026#34;a\u0026#34;); } /*************************************************************************/ public class Cache { List\u0026lt;Object\u0026gt; objects = new ArrayList\u0026lt;\u0026gt;(); void addObjects() { objects.add(\u0026#34;a\u0026#34;); objects.add(1); } String getObject() { return (String) objects.get(1); } } @Test void simple_test() { Cache cache = new Cache(); cache.addObjects(); assertThat(cache.getObject()).isEqualTo(\u0026#34;a\u0026#34;); //no puede realizar el casteo } Otra soluci√≥n ser√≠a decirle a la clase que acepte cualquier tipo de dato, por lo que el programa si ejecutar√≠a en dicho caso, y comprobar√≠amos el fallo en tiempo de compilaci√≥n.\npublic class Cache\u0026lt;T\u0026gt; { List\u0026lt;T\u0026gt; objects = new ArrayList\u0026lt;\u0026gt;(); void addObjects(T object) { objects.add(object); } T getObject(int i) { return objects.get(i); } } @Test void simple_test() { Cache cache = new Cache(); cache.addObjects(\u0026#34;a\u0026#34;); assertThat(cache.getObject(0)).isEqualTo(\u0026#34;a\u0026#34;); } /********************************************************************/ public class Cache\u0026lt;T\u0026gt; { List\u0026lt;T\u0026gt; objects = new ArrayList\u0026lt;\u0026gt;(); void addObjects(T object) { objects.add(object); } T getObject(int i) { return objects.get(i); } //no declaramos ning√∫n casteo } @Test void simple_test() { Cache cache = new Cache(); cache.addObjects(1); assertThat(cache.getObject(0)).isEqualTo(\u0026#34;a\u0026#34;); //como acepta el tipo, el error ocurre por no ser lo mismo que esperamos } ","date":"2020-07-02T00:00:00Z","permalink":"https://raulpadilladelgado.github.io/blog/p/clases-interfaces-y-gen%C3%A9ricos/","title":"Clases, Interfaces y Gen√©ricos"},{"content":"Primitivos y wrappers de primitivos en Java Asignar una variable primitiva usando otra variable primitiva Con los primitivos, cuando asignamos el valor de una variable a el valor de otra variable, simplemente se genera una copia, por lo que la variable original no mutar√° su estado por m√°s que la variable nueva decida cambiar.\npublic class Main { public static void main(String[] args) { int x = 0; int y = x; y=5; System.out.println(x);//x sigue valiendo 0 } } Funciones que operan primitivos Algo similar ocurre cuando se pasa por par√°metro a una funci√≥n un tipo primitivo, pasa a ser una copia, por lo que es una variable nueva dentro de dicho scope.\npublic class Main { public static void main(String[] args) { int x = 0; Numbers numbers = new Numbers(); numbers.integers(x); System.out.println(x);//x sigue valiendo 0 } } class Numbers{ public static void integers(int number){ number = 5; } } Asignar una variable tipo wrapper primitivo usando otra variable del mismo tipo Con los no primitivos, cuando asignamos el valor de una variable a el valor de otra variable, simplemente se genera una copia, por lo que la variable original no mutar√° su estado por m√°s que la variable nueva decida cambiar.\npublic class Main { public static void main(String[] args) { Integer x = 0; Integer y = x; y = 10; System.out.println(x);//x sigue valiendo 0 } } Comparando objetos wrappers (que envuelven primitivos) Comparar los primitivos mediante un simple \u0026ldquo;==\u0026rdquo; es seguro, se va a comportar siempre como esperamos.\npublic class Main { public static void main(String[] args) { int x = 0; int y = x; System.out.println(x == y); //el resultado es true } } El problema surge cuando en lugar de usar los primitivos, usamos la clase correspondiente que lo envuelve y que ofrece m√©todos para operar con √©l. En el siguiente¬†ejemplo, vemos como diferentes creaciones de un String dan diferentes resultados a la hora de comparar.\npublic class Main { public static void main(String[] args) { String s1 = new String(\u0026#34;campusMVP\u0026#34;); String s2 = new String(\u0026#34;campusMVP\u0026#34;); System.out.println(s1 == s2); //Devuelve false /*----------------------------------------------------*/ String s3 = \u0026#34;campusMVP\u0026#34;; String s4 = new String(\u0026#34;campusMVP\u0026#34;); System.out.println(s3 == s4); //Devuelve false /*----------------------------------------------------*/ String s5 = \u0026#34;campusMVP\u0026#34;; String s6 = \u0026#34;campusMVP\u0026#34;; System.out.println(s5 == s6); //Devuelve true } } La comparaci√≥n mediante \u0026ldquo;==\u0026rdquo; no siempre funciona como esperamos, por lo que lo mejor ser√≠a usar en su lugar \u0026ldquo;equals()\u0026rdquo;.\npublic class Main { public static void main(String[] args) { String s1 = new String(\u0026#34;campusMVP\u0026#34;); String s2 = new String(\u0026#34;campusMVP\u0026#34;); System.out.println(s1.equals(s2)); //Devuelve true /*----------------------------------------------------*/ String s3 = \u0026#34;campusMVP\u0026#34;; String s4 = new String(\u0026#34;campusMVP\u0026#34;); System.out.println(s3.equals(s4)); //Devuelve true /*----------------------------------------------------*/ String s5 = \u0026#34;campusMVP\u0026#34;; String s6 = \u0026#34;campusMVP\u0026#34;; System.out.println(s5.equals(s6)); //Devuelve true } } No solo cuenta que es m√°s seguro realizarlo de √©sta forma, adem√°s dejas m√°s clara la intenci√≥n de estar haciendo una comparaci√≥n por el valor del objeto.\nObjetos propios Funciones que operan nuestros objetos Anteriormente, vimos que los primitivos, o las clases que los usan mejor dicho, ejecutan m√©todos que devuelven copias modificadas del original. Cuando tenemos nuestros propios objetos la historia cambia. Seg√∫n como desarrollemos sus m√©todos, podr√° alterar su estado inicial, o simplemente devolver copias tal que lo hacen los primitivos.\nEn el siguiente ejemplo, podemos ver ciertos m√©todos que cambian el estado original del objeto, porque nuestro propio m√©todo en este caso si muta el estado original.\npublic class Main { public static void main(String args[]) { SomeType someType = new SomeType(); SomeType another = new SomeType(); someType.firstMethod(another); // another{ num:5, text:null } System.out.println(another.toString()); } } class SomeType{ public int num; public String text; public void firstMethod(SomeType someType){ someType.num=5; // hace referencia al mismo objeto recibido por par√°metro } @Override public String toString(){ return \u0026#34;{num:\u0026#34; + num + \u0026#34;, \u0026#34; + \u0026#34;text:\u0026#34; + text + \u0026#34;}\u0026#34;; } } En cambio podemos provocar que ocurra algo similar que con los primitivos.\npublic class Main { public static void main(String args[]) { SomeType someType = new SomeType(); SomeType another = new SomeType(); someType.firstMethod(another); // another{ num:0, text:null } System.out.println(another.toString()); } } class SomeType{ public int num; public String text; public void firstMethod(SomeType someType){ someType = new SomeType(); // ya NO hace referencia al mismo objeto recibido por par√°metro someType.num=5; } @Override public String toString(){ return \u0026#34;{num:\u0026#34; + num + \u0026#34;, \u0026#34; + \u0026#34;text:\u0026#34; + text + \u0026#34;}\u0026#34;; } } Funciones que operan colecciones o arrays de nuestros objetos Otro caso m√°s espec√≠fico que debemos tener en cuenta, ser√≠a el hecho de que los arrays de primitivos, si mutan su valor.\npublic class Main { public static void main(String args[]) { SomeType someType = new SomeType(); SomeType another = new SomeType(); someType.firstMethod(another.num); System.out.println(another.num[0]); // 5 } } class SomeType{ public int [] num = new int[5]; public String text; public void firstMethod(int[] num){ num[0] = 5; } } Tipos de funciones command query separator (cqs) Es un principio que nos dice que debemos de diferenciar entre dos tipos de funciones: por un lado, tenemos las \u0026ldquo;querys\u0026rdquo;, que no alteran el estado del sistema\nc = sum(a,b); *//realiza una \u0026quot;pregunta\u0026quot; y asigna la respuesta a una variable.*\n; por otro lado, tenemos las \u0026ldquo;command\u0026rdquo;, que s√≠ alteran el estado del sistema\nsum(a,b); *//internamente, est√° asignando el resultado de la operaci√≥n a alg√∫n campo, por lo que ser√≠a una \u0026quot;orden\u0026quot;.*\nUna vez conocida la diferencia, cabe recordar evitar la mezcla de √©stos dos tipos de funciones, de tal modo que, ni una \u0026ldquo;query\u0026rdquo; debe alterar el estado del sistema, y una \u0026ldquo;command\u0026rdquo; se limita a operar con datos del sistema. Por ejemplo, un value object contiene solo funciones tipo command.\nFunciones puras Son esas funciones que no dependen de informaci√≥n externa para su ejecuci√≥n. Realizar funciones los mas puras posibles, nos garantiza flexibilidad, adem√°s de que esa funci√≥n puede estar en cualquier sitio, y que por cambiarla no romperemos nada. Aqu√≠ vemos un ejemplo, en el que por m√°s que llamemos a la funci√≥n, si siempre es el mismo par√°metro, el resultado ser√° el mismo.\n**class** **SomeType**{ **public** double raizCuadrada(int n){ **return** Math.sqrt(n); }}\n","date":"2020-06-26T00:00:00Z","permalink":"https://raulpadilladelgado.github.io/blog/p/principios-fundamentales-de-los-tipos-de-datos-en-java/","title":"Principios fundamentales de los tipos de datos en Java"},{"content":"Implementations Patterns, de Kent Beck, es un libro sobre programaci√≥n que define buenas pr√°cticas a seguir en el desarrollo de c√≥digo en Java, con el objetivo de tener un c√≥digo legible y del que nos sintamos orgullosos. Se busca mejorar la perspectiva que tenga un programador sobre el sistema que va a tratar, para que entienda que cuando escriba c√≥digo, √©ste debe hablar por si solo, debe ser la respuesta correcta y simple a una pregunta que se haga una persona cuando debe resolver un problema. Podemos decir entonces que el libro trata la responsabilidad que debe asumir un programador para tener un c√≥digo satisfactorio.\nLa programaci√≥n va m√°s all√° de la comunicaci√≥n del hombre con la m√°quina, el programador debe pensar que su trabajo lo van a ver otras personas que tendr√°n que interpretar su c√≥digo, as√≠ mismo como puede ser el mismo quien vea su propio trabajo en un futuro. Para lograr que todo √©sta interpretaci√≥n no sea un tormento, deber√≠amos tener patrones que definan como desarrollamos c√≥digo simple y eficaz.\nPATRONES Todo programador deber√≠a conocer/seguir un conjunto de leyes que de cumplir sus programas como son:\nLa mayor parte del tiempo se dedica a leer, m√°s que a escribir. Nunca hay un \u0026ldquo;termin√©\u0026rdquo;. Se invierte m√°s en modificaciones que en el desarrollo inicial. Se estructuran utilizando un conjunto b√°sico de conceptos de flujo de estado y control. Los lectores necesitan entender los programas en detalle y en concepto. Los patrones tienden un puente entre los principios abstractos y la pr√°ctica. Adem√°s buscan ahorrar tiempo y energ√≠a, ya que se establecen para simplificar enormemente una tarea. Nos ayudan a abordar la toma de decisiones en un problema real. Entonces, los patrones de implementaci√≥n nos ayudan a escribir soluciones razonables para problemas comunes en la programaci√≥n.\nHay que entender que por muchos problemas que cubramos con patrones no podremos cubrir todas las situaciones que surjan en el desarrollo. Tener una lista de patrones es simplemente una teor√≠a que se adapta a cada situaci√≥n y necesidad.\nUNA TEOR√çA DE LA PROGRAMACI√ìN Los valores proporcionan motivaci√≥n, los principios traducen esa motivaci√≥n en acci√≥n, y finalmente son los patrones los que describen como se va a hacer. El estilo de desarrollo de cada programador viene definido a partir de sus valores personales y de los principios que expresen sus patrones de implementaci√≥n.\nTres valores fundamentales son la comunicaci√≥n(un lector puede entenderlo), la simplicidad(eliminar el exceso de complejidad) y la flexibilidad(la forma en que cambian)\nLos principios son ideas m√°s espec√≠ficas de la programaci√≥n, y son la base de los patrones, ya que son los que explican el por qu√© se ha desarrollado determinado patr√≥n.\nLas consecuencias locales definen que si un cambio aqu√≠ puede causar un problema all√° , entonces el costo del cambio aumenta dram√°ticamente. El c√≥digo con consecuencias mayormente locales se comunica de manera efectiva.\nCuando se tiene el mismo c√≥digo en varios lugares, si se cambia una copia del c√≥digo hay que decidir si se cambian o no todas las dem√°s copias. Su cambio ya no es local. Cuantas m√°s copias del c√≥digo, m√°s costar√° el cambio.\nOtro razonamiento del principio de las consecuencias locales es mantener la l√≥gica y los datos juntos. Poner la l√≥gica y los datos sobre los que opera cerca el uno del otro, en el mismo m√©todo si es posible, o en el mismo objeto, o al menos en el mismo paquete.\nLa simetr√≠a en el c√≥digo es donde la misma idea se expresa de la misma manera en todos los lugares donde aparece en el c√≥digo. En el siguiente ejemplo la segunda afirmaci√≥n es m√°s concreta que las dem√°s, por lo que debemos llevarla al mismo nivel de abstraci√≥n.\n*/*BEFORE*/* entrada(); cuenta++; */*AFTER*/* entrada(); increment(); Un √∫ltimo principio es poner juntos la l√≥gica o los datos que cambian a la misma velocidad y separar la l√≥gica o los datos que cambian a velocidades diferentes. Estas tasas de cambio son una forma de simetr√≠a temporal.\nMOTIVATION El mantenimiento es caro porque entender el c√≥digo existente lleva tiempo y es propenso a errores. Hacer cambios es generalmente f√°cil cuando se sabe lo que hay que cambiar. Aprender lo que hace el c√≥digo actual es la parte m√°s costosa. Una vez que los cambios se hacen, necesitan ser probados y desplegados.\nPara intentar reducir el costo general debemos encontrar la forma de obtener beneficios inmediatos al tiempo que se establece un c√≥digo limpio para facilitar el desarrollo futuro, reduciendo as√≠ los gastos de mantenimiento.\nEs por √©sto que podemos decir que es importante tener patrones de implementaci√≥n que nos permitan realizar todo lo anterior de una manera r√°pida, que lo hagamos casi de forma autom√°tica.\nCLASES Los patrones de clase tienen mayor alcance que cualquier otro patr√≥n de implementaci√≥n. Los patrones de dise√±o nos hablan de las relaciones entre clases.\nUsamos clases para agrupar una serie de datos y asociar una l√≥gica a ellos. En una clase, la l√≥gica debe cambiar de forma m√°s lenta que como lo hacen los datos sobre los que opera. Dichos datos cambian a velocidades similares y son operados por la l√≥gica relacionada. Una programaci√≥n efectiva con objetos comprende saber agrupar la l√≥gica en clases y representar sus variaciones en funci√≥n de los datos que usa. Otro aspecto a tener en cuenta es la herencia, para poder definir m√∫ltiples variaciones de una clase padre en varias subclases.\nAunque usar clases presente grandes beneficios para la estructuraci√≥n en nuestro c√≥digo, debemos saber cuando usarlas y cuando no. Es decir, debemos reducir el n√∫mero de clases para lograr reducir la dimensi√≥n del sistema, pero siempre y cuando se respete que las dem√°s clases no se sobrecargan a ra√≠z de realizar dicha reducci√≥n.\n¬øComo podemos comunicar nuestras intecCiones correctamente declarando las clases?. A continuaci√≥n se da una serie de principios que son la respuesta a ello:\nNombre simple de la superclase/interfaz:¬†Un nombre correcto puede llegar a simplificar y mejorar mucho la situaci√≥n. \u0026ldquo;Las clases son el el anclaje central del dise√±o\u0026rdquo;, lo que quiere decir que cuando creemos m√©todo lo haremos en funci√≥n del nombre de la clase, por lo que √©sta primera definici√≥n es crucial para las definiciones que le prosiguen. A veces necesitas seguir adelante con nuevas funciones, tiempo de confianza, frustraci√≥n y tu subconsciente para proporcionar un nombre mejor.La conversaci√≥n es una herramienta que me ayuda constantemente a encontrar mejores nombres. Explicar el prop√≥sito de un objeto a otra persona te lleva a encontrar mejores nombres para lo que est√°s describiendo. Nombre de la subclase:¬†Los nombres de las subclases tienen dos trabajos. Necesitan comunicar c√≥mo son de clase y en qu√© se diferencian. Una vez m√°s, el equilibrio que se debe lograr es entre la longitud y la expresividad. Use esa superclase como base para el nombre de la subclase. Los nombres de clase que son demasiado cortos gravan la memoria a corto plazo del lector. Los grupos de clases cuyos nombres no se relacionan entre s√≠ ser√°n dif√≠ciles de comprender y recordar. Usen los nombres de las clases para contar la historia de su c√≥digo. Interfaz abstracta:¬†Se busca codificar a las interfaces, no a las implementaciones. Esta es otra forma de sugerir que una decisi√≥n de dise√±o no debe ser visible en m√°s lugares de los necesarios. Si la mayor parte de mi c√≥digo s√≥lo sabe que estoy tratando con una colecci√≥n soy libre de cambiar la clase concreta m√°s tarde. Puede ser representado en Java como una interfaz o como una superclase. Pague por las interfaces s√≥lo cuando necesite la flexibilidad que ellas crean.Otro factor econ√≥mico en la introducci√≥n de las interfaces es la imprevisibilidad de los programas inform√°ticos. Nuestra industria parece adicta a la idea de que si dise√±√°ramos bien el software no tendr√≠amos que cambiar nuestros¬†sistemas. Interfaz: Una forma de decir \u0026ldquo;Esto es lo que quiero lograr y m√°s all√° de eso hay detalles que no deber√≠an preocuparme\u0026rdquo; es declarar una interfaz de Java. Tienen algo de la flexibilidad de la herencia m√∫ltiple sin la complejidad y la ambig√ºedad. Las interfaces como clases sin implementaciones deben ser nombradas como si fueran clases. Por ejemplo, para dejar constancia de una interfaz, podr√≠amos declarar la interfaz como \u0026ldquo;IFile\u0026rdquo;, y la clase que la implementa \u0026ldquo;File\u0026rdquo;. Abtenerse de nombres como \u0026ldquo;FileImpl\u0026rdquo;, ya que es una abreviatura. Clase abstracta(superclase): La otra forma de expresar la distinci√≥n entre la interfaz abstracta y la implementaci√≥n concreta en Java es usar una superclase. La superclase es abstracta en el sentido de que puede ser reemplazado en tiempo de ejecuci√≥n con cualquier subclase. Las interfaces abstractas necesitan soportar dos tipos de cambio: cambio en la implementaci√≥n y cambio de la propia interfaz. Las interfaces de Java no soportan bien esta √∫ltima. Cada cambio en una interfaz requiere cambios en todas las implementaciones. Las clases abstractas no sufren esta limitaci√≥n. Siempre que se pueda especificar una implementaci√≥n por defecto, se pueden a√±adir nuevas operaciones a una clase abstracta sin interrumpir a los implementadores existentes. Una limitaci√≥n de las clases abstractas (superclase) es que los implementadores s√≥lo pueden declarar su lealtad a una superclase. Si son necesarias otras vistas de la misma clase, deben ser implementadas por interfaces Java. Interfaz versionada ¬øQu√© haces cuando necesitas cambiar una interfaz pero no puedes? T√≠picamente esto sucede cuando quieres a√±adir operaciones. Ya que a√±adir una operaci√≥n romper√° todos los implementos existentes, no puedes hacer eso. Sin embargo, puedes declarar una nueva interfaz que ampl√≠e la interfaz original y a√±adir la operaci√≥n all√≠. Los usuarios que desean la nueva funcionalidad utilizan la interfaz ampliada mientras que los usuarios existentes permanecen ajenos a la existencia de la nueva interfaz.\nValue Object Este estilo funcional de computaci√≥n nunca cambia ning√∫n estado, s√≥lo crea nuevos valores. Cuando se tiene una situaci√≥n est√°tica (quiz√°s moment√°neamente) sobre la que se quiere hacer afirmaciones o sobre la que se quiere hacer preguntas, entonces el value object es apropiado. Cuando la situaci√≥n cambia con el tiempo,entonces el estado es apropiado.\nSubclase Declarar una subclase es una forma de decir, \u0026ldquo;Estos objetos son como esos excepto\u0026hellip;\u0026rdquo; Si tienes la superclase correcta, crear una subclase puede ser una manera poderosa de programar. Con el m√©todo correcto para anular a la superclase, puedes introducir una variante de un c√°lculo existente con unas pocas l√≠neas de c√≥digo. Como tambi√©n tiene desventajas: si descubres que\nalg√∫n conjunto de variaciones no est√° bien expresado como subclases, tienes que trabajar para desenmara√±ar el c√≥digo antes de poder reestructurarlo; segundo, tienes que entender la superclase antes de que puedas entender la subclase; tercero, los cambios en una superclase son arriesgados, ya que las subclases pueden depender de propiedades sutiles de la implementaci√≥n de la superclase.\nUna clave para lograr subclases √∫tiles es implementar la l√≥gica de la superclase en m√©todos que hagan un solo trabajo, para facilitar la reutilizaci√≥n o cambio en la subclases.\nESTADO Cuando hablamos de estado, nos referimos a esos valores que forman el estado del programa. Cuando usamos POO, √©stos valores son peque√±as piezas encapsuladas en objetos, permiti√©ndonos as√≠ entender mejor que valor hizo cambiar el estado.\nA continuaci√≥n se definen una serie de patrones que afectan al estado:\nAcceso: Hay dos formas de acceder a los valores: acceso a valores almacenados e invocando c√°lculos. Acceder a la memoria es como invocar una funci√≥n que devuelve los valores almacenados actualmente. Invocar una funci√≥n es como leer un lugar de memoria, cuyo contenido simplemente se calcula y no simplemente se devuelve. Dos tipos de acceso: Acceso Directo ‚Üí Cuando pasamos un dato concreto, lo cu√°l aporta una clara expresividad, pero pierde en flexibilidad. Acceso Indirecto ‚Üí Cuando pasamos una variable y el m√©todo se encarga de realizar lo que sea necesario antes de asignar dicho dato, lo cual requiere conocer adem√°s el comportamiento de otro factor, pero ganamos en flexibilidad, pudiendo aplicar las operaciones que queramos. Estado com√∫n: Muchos c√°lculos comparten los mismos elementos de datos aunque los valores sean diferentes. Cuando encuentre un c√°lculo de este tipo, comun√≠quelo declarando los campos de una clase. Estado variante: Otras veces se deben tener diferentes elementos de datos, ya sea porque una clase necesita varias propiedades, en √©ste caso se deben declaran los campos intentando agrupar los comunes en un estado com√∫n. Variables: Datos almacenados que son variantes con el tiempo. Variables locales ‚Üí Accesibles desde donde se declaran hasta el final del bloque. Recopilador: recolecta informaci√≥n para su uso posterior. Contador: una especie de recopilador que recolecta la cuenta de otros objetos. Explicativas: Las que su nombre son definidos para guiar al lector. Reutilizador: Las que se definen para ahorrar al entorno de trabajo el calculo de una variable que siempre tienen el mismo valor. Elementos: Las que usamos cuando queremos decir \u0026ldquo;por cada objeto en √©sta lista\u0026hellip;\u0026rdquo;. Campo: Los atributos que pertenecen y se declaran a un objeto. Ayudante: El campo definido para usar las referencias de otro objeto. Bandera: Los que definen como se va a usar el objeto, y que si tienen m√©todo para alterar su estado adem√°s dicen que el uso puede variar a lo largo de la ejecucci√≥n. Estrategia: Cuando almacenamos la parte variante que puedan tener los m√©todos, proporcionando m√©todos para que cambie. Estado: Son como los estrat√©gicos, pero los de estado van m√°s ligados a la identidad del objeto y su funcionamiento general. Componentes:¬†estos campos contienen propiedades del objeto en cuesti√≥n que no buscan ser como los estrat√©gicos. Par√°metro: es la forma de comunicar a un objeto con otro si no se tienen un campo del objeto en cuesti√≥n declarado. Mediante un m√©todo un objeto recibe informaci√≥n de otro objeto o el objeto en si. Recopiladores: son pasados con el fin de ir a√±adiendo informaci√≥n en √©l. Opcionales: Como cuando tenemos diferentes constructores que reciben distintos n√∫mero de par√°metros, con el fin de pasar solo los datos que queramos o todos. Argumentos variables: Para poder pasar par√°metros sin un n√∫mero determinado de ellos, ya sea mediante una colecci√≥n, o delegando a la funci√≥n que cree una colecci√≥n a partir de todo lo que se le pasa¬†(Class\u0026hellip; classes). Objeto: cuando se pasa un objeto como par√°metro con el fin de reusar c√≥digo en la l√≥gica. Constantes: Datos que son accedidos en muchos sitios, pero que no cambian. Al declararlo as√≠ nos aseguramos que la variable est√° protegida ya que nunca deber√≠a cambiar. Por convenci√≥n deber√≠a escribirse su nombre en may√∫sculas. Nombres de acuerdo a un rol: Definir las variables seg√∫n el rol/funci√≥n que vayan a cumplir. result ‚Üí si guarda el objeto que retorna una funci√≥n for(Person person: people) ‚Üí llamamos a la variable \u0026ldquo;person\u0026rdquo; porque la lista \u0026ldquo;people\u0026rdquo; tiene un conjunto de \u0026ldquo;person\u0026rdquo;. count ‚Üí guarda la cuenta de algo. etc\u0026hellip; COMPORTAMIENTO Se describen una serie de patrones sobre como expresar el comportamiento de un programa:\nFlujo de control: Expresa los c√°lculos como una secuencia de pasos. Java es un miembro de la familia de lenguajes en los que la secuencia de control es un principio organizativo fundamental. Las declaraciones adyacentes se ejecutan una detr√°s de otra. Los condicionales, bucles, excepciones, etc, definen el flujo a seguir del programa. Teniendo √©sto claro podemos decir que cada paso cuenta a la hora de tener un buen producto. Flujo principal: Los programadores generalmente tienen en mente un flujo principal de control para sus programas. El procesamiento comienza aqu√≠ y termina all√≠. Puede haber decisiones y excepciones a lo largo el camino, pero el c√≥mputo tiene un camino a seguir. Pensar desde donde y hac√≠a donde queremos llegar, sumar√° a la hora de tener una mejor idea de como implementar funcionalidad. Mensaje: La programaci√≥n orientada a objetos enriquece el mensaje que transmitimos, ya que para una secuencia de instrucciones se define un mensaje (m√©todo) que abstrae al lector de conocer todos los detalles del funcionamiento, solo necesita aplicar la l√≥gica com√∫n. No solo importa a la hora de leerlo, si no que ser√° un factor fundamental a la hora de poder ampliar el comportamiento actual del programa. Eligiendo el mensaje: Debemos tener cuidado con el nombre que elijamos para el mensaje que queremos transmitir, ya que un mal nombre har√° una mala representaci√≥n de la l√≥gica que estamos abstrayendo. Nombres que sean el resumen o el factor clave de lo que hace la l√≥gica. Mensaje descompuesto: Cuando se tiene una serie de algoritmos complicados, podemos usar un nombre que descomponga cada tarea que cumpla el algoritmo y concatene cada una de ellas para formar un nombre descriptivo que permita al lector ignorar los detalles de implementaci√≥n. 6.¬†Mensaje de reversi√≥n: No solo importa que sea un buen mensaje, adem√°s deber√≠a estar al mismo nivel de abstraci√≥n que los dem√°s mensajes de su √°mbito, por lo que si nuestro mensaje es m√°s complicado que otros mensaje que le proceden o preceden, deber√≠amos buscar la forma de que queden al mismo nivel abstraci√≥n.\nvoid compute() { input(); helper.process(**this**); output();} */******************************************/* compute() { **new** Helper(**this**).compute(); } Helper.compute() { input(); process(); output(); } Mensaje de invitaci√≥n: Cuando queremos transmitir el mensaje de que una clase es solo una idea de funcionamiento y que requiere de especificaciones o subclases, indicamos que la clase es abstracta, por lo que no se puede instanciar, solo mejorar. Mensaje explicativo: Transmitir la intenci√≥n de la l√≥gica en el mensaje mediante un comentario o el nombre de un m√©todo. Flujo excepcional: Si es cierto que un programa siempre tienen un flujo principal, son las clausulas guardas o las excepciones las que crear un flujo alternativo. Clausula guarda: Son condiciones que har√°n que nuestro m√©todo de un salto, ignorando la l√≥gica que venga despu√©s, ya que con √©sto damos a entender que se ha dado una condici√≥n en la que no necesitamos seguir operando. Excepciones: Son condiciones que expresan que no se puede implementar cierta l√≥gica pensada debido a alg√∫n fallo en la computaci√≥n. Podemos crear nuestras propias excepciones para aportar mayor expresividad al c√≥digo, y as√≠ poder manejar mejor √©stas excepciones. Con manejar las excepciones nos referimos a recuperarnos del fallo de tal manera que si un bloque de c√≥digo no se puede ejecutar, hay otro que tomar√° el relevo y que coge como contexto el fallo obtenido que provoc√≥ la excepci√≥n. Adem√°s, tener nuestra propia excepci√≥n, nos da un mayor feedback de porqu√© falla el c√≥digo. M√âTODOS Nuestros programas pueden tener una l√≥gica muy variante, ya que vamos desarrollando un bloque de c√≥digo por funci√≥n que el programa final deba tener. Perfectamente, toda la l√≥gica podr√≠a contenerse en un solo m√©todo, pero para eso usamos m√©todos, para cumplir una tarea espec√≠fica, evitando tener que un m√©todo cumpla m√°s de una tarea. Los beneficios son claros, la legibilidad obtenida al separar la l√≥gica en m√©todos es un gran punto a favor, pero adem√°s entra en juego la expresividad, ya que as√≠ distinguimos partes m√°s importantes o menos importantes.\nLo mejor de los m√©todos es que se entienden por separado, abstraen al lector de tener que leer otras implementaciones que no son necesarias para entender la tarea que est√° cumpliendo un m√©todo. Evitan la repitici√≥n de c√≥digo, ya que varias llamadas a un m√©todo equivale a ejecutar tantas veces un bloque de c√≥digo sin tener que haberlo escrito m√°s que una vez para crear el m√©todo.\nQue nos aporten tantos beneficios no quiere decir que no puedan suponer una desventaja, ya que se debe cuidar su tama√±o, nombre y prop√≥sito. Si haces demasiados m√©todos muy peque√±os, los lectores tendr√°n dificultades para seguir su fragmentada expresi√≥n de ideas. Pocos m√©todos conducen a la duplicaci√≥n y a la consiguiente p√©rdida de flexibilidad.\nA continuaci√≥n se definen una serie de patrones relacionados con los m√©todos:\nM√âTODOS COMPUESTOS Cuando se componen m√©todos a partir de llamadas a otros m√©todos, cada uno debe tener el mismo nivel de abstracci√≥n.\nvoid compute() { input(); flags|= 0x0080; /*FIX: flags();*/ output(); } Una objeci√≥n al uso de muchos peque√±os m√©todos es la penalizaci√≥n por rendimiento impuesta por la invocaci√≥n de todos esos m√©todos.\nSe suele recomendar desarrollar m√©todos estableciendo un l√≠mite de l√≠neas de c√≥digo que ronde entre 5 y 15. Aunque hay que tener en cuenta que no se debe sacrificar la legibilidad o expresividad por la longitud est√°ndar de los m√©todos, ya que por ejemplo un simple espacio en blanco puede llegar a aportar mucho si separa dos estructuras de distinas complejididades, nos aporta expresividad. Un m√©todo se convierte en un obst√°culo cuando me dedico a tratar de entender el c√≥digo en detalle.\nEl truco para elaborar un m√©todo est√° en reconocer cuando tengo conjuntos de detalles relativamente independientes que pueden ser movidos a m√©todos de apoyo.\nREVELAR LA INTENCI√ìN EN EL NOMBRE DEL M√âTODO Los m√©todos deben ser nombrados con el prop√≥sito de que un posible invocador pueda tener en¬†mente porqu√© usa ese m√©todo. Nombre m√©todos para que ayuden a contar la historia.\nVISIBILIDAD DEL M√âTODO Los cuatro niveles de visibilidad -public, package, protected, private- cada uno dice algo diferente sobre sus intenciones para un m√©todo. Si no necesitamos que otros sitios conozcan un m√©todo, la mejor manera de expresarlo es declararlo private. En cuanto a la flexibilidad, debemos tener en cuenta que cuantos m√°s m√©todos privados tengamos m√°s f√°cil sera escalar, ya que no existe c√≥digo m√°s all√° del de la propia clase que depende de √©l, pero si a raiz de √©sto dificultamos demasiado que otras clases que lo necesiten puedan acceder al m√©todo, lo mejor ser√≠a declarar como tipo public, debemos encontrar en balance para cada situaci√≥n.\nPublic ‚Üí Accesible en cualquier paquete o clase. Hacer un m√©todo p√∫blico significa que aceptas la responsabilidad de mantenerlo, ya sea dej√°ndolo¬†sin cambios, o arreglando todas las llamadas si cambia. Protected ‚Üí S√≥lo las clases que hereden de la superclase, podr√°n acceder a m√©todos declarados as√≠. Private ‚Üí S√≥lo ser√° accesible en la misma clase o paquete. Nos aporta una flexibilidad, ya que el cambio se realizar√° solo en √©ste punto y no tendremos que realizarlo en m√∫ltiples sitios como lo har√≠amos como un m√©todo p√∫blico. Revelar lentamente los m√©todos, comenzando con la visibilidad m√°s restrictiva que trabajar y revelarlos cuando sea necesario. Si un m√©todo ya no necesita ser visible, reducir su visibilidad. Declarar los m√©todos finales es similar a elegir su visibilidad. Declarar un m√©todo final establece que aunque no te importa que la gente use este m√©todo, t√∫ no permitir√°s que nadie lo cambie, nos da la seguridad de que nadie romper√° accidentalmente el objeto ya que su valor es invariante. Declarar un m√©todo est√°tico lo hace visible incluso si la persona que llama no tiene el acceso a una instancia de la clase. Los m√©todos est√°ticos est√°n limitados en el sentido de que no pueden depender de ninguna instancia por lo que no son un buen dep√≥sito para la l√≥gica compleja.¬†El buen uso de los m√©todos est√°ticos es como un reemplazo para los constructores.\nOBJETO DE M√âTODO Para crear un objeto de m√©todo, busque un m√©todo largo con muchos par√°metros y variables temporales. Tratar de extraer cualquier parte del m√©todo resultar√≠a en largas listas de par√°metros en subm√©todos dif√≠ciles de nombrar.\nCrear una clase con el nombre del m√©todo. Por ejemplo, complexCalculation() se convierte en¬†ComplexCalculator. Crear un campo en la nueva clase para cada par√°metro, variable local y campo utilizado en el m√©todo. Dale a estos campos los mismos nombres que tienen en elm√©todo original. Crear un constructor que tome como par√°metros los par√°metros del m√©todo de la m√©todo original y los campos del objeto original utilizados por el m√©todo. Copie el m√©todo en un nuevo m√©todo, calculate(), en la nueva clase. Sustituir el cuerpo del m√©todo original por un c√≥digo que cree una instancia de la nueva clase. Por ejemplo: complexCalculation() { new ComplexCalculator().calculate(); } Si los campos fueron establecidos en el m√©todo original, establ√©zcalos despu√©s de los retornos del m√©todo: complexCalculation() { ComplexCalculator calculator = new ComplexCalculator(); calculator.calculate(); mean = calculator.mean; variance = calculator.variance; } Aseg√∫rate de que el c√≥digo refactorizado funcione como el antiguo c√≥digo. El c√≥digo de la nueva clase es f√°cil de refactorizar. Puedes extraer m√©todos y no tener que pasar nunca ning√∫n par√°metro porque todos los datos utilizados por el m√©todo se almacenan en campos. A menudo, una vez que se empiezan a extraer los m√©todos se descubre que algunas variables pueden ser degradadas de los campos a los locales.\nM√âTODO ANULADO O SOBRESCRITO Los m√©todos anulados son una forma clara de expresar una variaci√≥n. Los m√©todos declarados abstractos en un superclase son una clara invitaci√≥n a especializar un c√°lculo, pero cualquier m√©todo no declarado final es un candidato para expresar una variaci√≥n en un c√°lculo existente. Los m√©todos bien compuestos en la superclase proporcionan una multitud de potenciales ganchos en los que puedes colgar tu propio c√≥digo. Si el c√≥digo de la superclase est√° en peque√±os trozos cohesivos, entonces ser√°s capaz de anular m√©todos enteros. Anular un m√©todo no es ninguna de las dos cosas. Puedes ejecutar el c√≥digo de la subclase y el c√≥digo de la superclase invocando super.method();¬†para invocar el m√©todo del mismo nombre.\nM√âTODO SOBRECARGADO Cuando declaras el mismo m√©todo con diferentes tipos de par√°metros, dices \u0026ldquo;Aqu√≠ hay formatos alternativos para los par√°metros de este m√©todo\u0026rdquo;. Los m√©todos sobrecargados alivian al llamante de la responsabilidad de convertir los par√°metros si hay varias formas leg√≠timas de pasando los par√°metros. Una variante de la sobrecarga es usar el mismo nombre de m√©todo con diferentes n√∫mero de par√°metros. El problema con este estilo de sobrecarga es que los lectores que quieran preguntar: \u0026ldquo;¬øQu√© pasa cuando invoco este m√©todo?\u0026rdquo; necesitan leer no s√≥lo el nombre del m√©todo sino tambi√©n la lista de par√°metros antes de que saber lo suficiente para averiguar lo que sucede como resultado de la invocaci√≥n del m√©todo. Si la sobrecarga es complicada, los lectores necesitan entender la sutil sobrecarga reglas de resoluci√≥n para poder determinar est√°ticamente qu√© m√©todo se invocar√° para determinados tipos de argumentos. Los m√©todos sobrecargados deben servir todos para el mismo prop√≥sito, con la variaci√≥n s√≥lo en los tipos de par√°metros. Diferentes tipos de retorno para diferentes sobrecarga dos los m√©todos hacen que la lectura del c√≥digo sea demasiado dif√≠cil. Es mejor encontrar un nuevo nombre para la nueva intenci√≥n. Darle a los diferentes c√°lculos diferentes nombres.\nM√âTODO DE RETORNO El tipo de retorno de un m√©todo se√±ala primero si el m√©todo es un procedimiento que funciona por efecto secundario o una funci√≥n que devuelve un tipo de objeto particular. El tipo de retorno void permite distinguir entre procedimientos y funciones.A veces tu intenci√≥n es que el tipo de retorno sea espec√≠fico, un tipo de objeto concretoo uno de los tipos primitivos. Sin embargo, le gustar√≠a que sus m√©todos fueran tan lo m√°s ampliamente posible, as√≠ que elige el tipo de retorno m√°s abstracto que expresa su intenci√≥n. Esto conserva la flexibilidad para que puedas cambiar la tipo de retorno concreto en caso de que sea necesario en el futuro. Generalizar el tipo de retorno tambi√©n puede ser una forma de ocultar detalles de la implementaci√≥n. Por ejemplo, la devoluci√≥n de una colecci√≥n en lugar deunalista puede animar a los usuarios a no asumir que los elementos est√°n en un orden fijo.\nM√âTODO DE COMENTARIO Expresar la mayor cantidad de informaci√≥n posible a trav√©s de los nombres y la estructura de el c√≥digo. A√±ade comentarios solo para expresar decisiones e informaci√≥n que no es obvia del c√≥digo.Las pruebas automatizadas pueden comunicar informaci√≥n que no encaja de forma natural en comentarios de m√©todo. Automatizado las pruebas tienen muchas ventajas. Escribirlas es un valioso ejercicio de dise√±o, especialmente cuando se hace antes de la aplicaci√≥n. Si las pruebas se realizan, son consistentes con el c√≥digo. Las herramientas de refactorizaci√≥n automatizada pueden ayudar a mantener las pruebas actualizadas a un nivel bajo costo.\nM√âTODO DE AYUDA Grandes m√©todos convertidos en varios m√°s peque√±os, los denominamos \u0026lsquo;helpers\u0026rsquo; son los ayudantes. Su prop√≥sito es hacer que los c√°lculos de mayor complejidad sean m√°s le√≠dos ocultar detalles irrelevantes y darle la oportunidad de expresar su intenci√≥n a trav√©s del nombre del m√©todo.Los ayudantes son t√≠picamente declarados private, pasando a protected si la clase est√° destinada a ser refinada por subclasificaci√≥n. Son √©stos helpers los que llama otro m√©todo que si sea accesible para otras clases, o puede que quizas solo sirvan para apoyar a otro m√©todo private de la clase.\nM√âTODO PARA PRUEBA CON IMPRESION Son m√©todos que definimos sin m√°s funcionalidad que mostrar cierta informaci√≥n √∫til sobre un objeto, como puede ser untoString();para imprimir informaci√≥n sobre propiedades que sirva de debug de la aplicaci√≥n entre otras cosas.\nCOLECCIONES El comportamiento de colecci√≥n sol√≠a ser implementado proporcionando enlaces en la estructura de datos en s√≠ misma: cada p√°gina de un documento tendr√≠a enlaces con la anterior y las siguientes p√°ginas. M√°s recientemente, la moda ha cambiado a usar un objeto separado para la colecci√≥n que relaciona los elementos. Esto permite la flexibilidad de poner el mismo objeto en varias colecciones diferentes sin modificar el objeto.\nMet√°fora Las colecciones mezclan diferentes met√°foras. La primera es la de una variable de valor m√∫ltiple, una variable que se refiere a una colecci√≥n es en realidad una variable que se refiere a varios objetos al mismo tiempo, pero dicha variable no se considera un objeto. Como con todas las variables, puede asignar a una variable de valor m√∫ltiple (a√±adir y quitar elementos), recuperar su valor, y enviar los mensajes variables (con el bucle for). La met√°fora de la variable multivaluada se rompe en Java porque las colecciones son objetos separados con identidad. La segunda met√°fora mezclada en las colecciones es la de los objetos - una colecci√≥n es un objeto. Puedes recuperar una colecci√≥n, pasarla alrededor, probarlo para la igualdad, y enviarle mensajes.¬†As√≠ que, as√≠ como las colecciones son variables de m√∫ltiples valores, tambi√©n son objetos. Otra met√°fora √∫til es pensar en las colecciones como conjuntos matem√°ticos. Una colecci√≥n divide el mundo de los objetos en objetos que est√°n en la colecci√≥n y los objetos que no lo son. Dos operaciones b√°sicas en los conjuntos matem√°ticos est√°n encontrando su cardinalidad (el m√©todo size() de las colecciones) y probando la inclusi√≥n (representada por el m√©todo contains()).\nConceptos El primer concepto expresado por las colecciones es su tama√±o. Los Arrays (que son colecciones primitivas) tienen un tama√±o fijo, establecido cuando se crea el conjunto. La mayor√≠a las colecciones pueden cambiar de tama√±o despu√©s de ser creadas. Un segundo concepto expresado a trav√©s de las colecciones es si el orden de elementos es importante. El orden puede ser el orden en que los elementos se a√±adieron o puede ser proporcionada por alguna influencia externa como la lexicogr√°fica comparaci√≥n. Por √∫ltimo, las consideraciones sobre el rendimiento se comunican mediante la elecci√≥n de colecci√≥n. Si una b√∫squeda lineal es lo suficientemente r√°pida, una colecci√≥n gen√©rica es lo suficientemente buena. Si la colecci√≥n crece demasiado grande, ser√° importante poder probar o acceder elementos por una clave, sugiriendo un conjunto o mapa.\nInterfaces La declaraci√≥n de la interfaz dice al lector sobre la colecci√≥n: si la colecci√≥n est√° en un orden particular, si hay elementos duplicados, y si hay alguna manera de buscar elementos por clave o s√≥lo por iteraci√≥n. Los tipos de interfaces para colecciones se describen a continuaci√≥n:\nArrays: Desafortunadamente, no tienen el mismo protocolo que otras colecciones, por lo que es m√°s dif√≠cil cambiar de un array a una colecci√≥n que de un tipo de colecci√≥n a otro. A diferencia de la mayor√≠a de las colecciones, el tama√±o de un conjunto se fija cuando se crea. Los arrays son m√°s eficientes en el tiempo y el espacio que otras colecciones de simples operaciones. El acceso que tienen los arrays (es decir, elementos[i]) es m√°s de diez veces m√°s r√°pido que el equivalente de ArrayList (elements.get(i)).\nIterable: Declarar una variable Iterable s√≥lo dice que contiene m√∫ltiples valores. Iterable es la base para la construcci√≥n del bucle en Java 5. Cualquier objeto declarado como Iterable puede ser usado en un bucle. Esto se implementa llamando tranquilamente al m√©todo iterator(). Una de las cuestiones que hay que comunicar al utilizar las colecciones es si se espera que los clientes los modifiquen. Desafortunadamente, Iterable y su ayudante, Iterator, no proporcionan ninguna manera de declarar que una colecci√≥n no debe ser modificada. Una vez que tienes un Iterator, puedes invocar su m√©todo remove(), que elimina un elemento del Iterable subyacente.\nCollection: La colecci√≥n hereda de Iterable, pero a√±ade m√©todos para a√±adir, eliminar, buscar y contar los elementos. Declarar una variable o m√©todo como una colecci√≥n deja muchas opciones para una clase de implementaci√≥n. Dejando la declaraci√≥n tan vagamente especificada como sea posible, usted mantiene la libertad de cambiar las clases de implementaci√≥n m√°s tarde sin que el cambio se extienda a trav√©s del c√≥digo.\nList: A la colecci√≥n, la lista a√±ade la idea de que los elementos est√°n en un orden estable. Un elemento puede ser recuperado proporcionando su √≠ndice a la colecci√≥n. Una secuencia estable es importante cuando los elementos de una colecci√≥n interact√∫an entre s√≠.Set: Un conjunto es una colecci√≥n que no contiene duplicados (elementos que informar√≠an que son iguales() entre s√≠).\nSortedSet(conjunto ordenado): SortedSet almacena elementos ordenados pero √∫nicos. A diferencia del orden de una Lista, que est√° relacionado con el orden en que los elementos fueron a√±adidos o por √≠ndices expl√≠citos pasados a add(int, Object), el ordenamiento en un SortedSet es proporcionado por un Comparador. En ausencia de un orden expl√≠cito, se utiliza el \u0026ldquo;orden natural\u0026rdquo; de los elementos. Por ejemplo, los Strings se clasifican en orden lexicogr√°fico.\nMap: La √∫ltima interfaz de recolecci√≥n es Map, que es un h√≠brido de las otras interfaces. El mapa almacena los valores por clave, pero a diferencia de una lista, la clave puede ser cualquier objeto y no s√≥lo un n√∫mero entero. Las claves de un mapa deben ser √∫nicas, aunque los valores puede contener duplicados. Los elementos de un Mapa no est√°n en ning√∫n orden particular. Debido a que Map no es completamente como cualquiera de las otras interfaces de la colecci√≥n, se encuentra sola, sin heredar de ninguno de ellos. Los mapas son dos colecciones en el al mismo tiempo; una colecci√≥n de llaves conectadas a una colecci√≥n de valores.\nImplementaciones Collection\nLa clase predeterminada es ArrayList, pero √©sta puede no darnos el resultado esperado al realizar un contains(object) o un remove(object), ya que en √©ste tipo se permiten duplicados y solo borrar√° el primer resultado encontrado. Lo m√°s seguro y eficaz es usar en su lugar HashSet.\nList\nA√±ade la idea de que los elementos est√°n en un estable orden. Las dos implementaciones de la Lista de uso com√∫n son ArrayList y LinkedList. ArrayList es r√°pido para acceder a los elementos y lento para a√±adir y quitar elementos, mientras que LinkedList es lento para acceder a los elementos y r√°pido para a√±adir y eliminar elementos.\nSet\nHay tres implementaciones principales de Set: HashSet, LinkedHashSet, y TreeSet (querealmente implementa SortedSet). HashSet es el m√°s r√°pido pero sus elementos no est√°n en orden garantizado. Un LinkedHashSet mantiene los elementos en el orden en que fuerona√±adi√≥, pero a costa de una penalizaci√≥n extra del 30% de tiempo por a√±adir y quitarelementos. TreeSet mantiene sus elementos ordenados de acuerdo a un comparadorpero a costa de hacer que la adici√≥n y la eliminaci√≥n de elementos o la prueba de un elemento lleve un tiempo proporcional a n, donde n es el tama√±o de la colecci√≥n.\nMap\nLas implementaciones de Map siguen un patr√≥n similar a las implementaciones deSet. HashMap es el m√°s r√°pido y simple. LinkedHashMap preserva el orden de los elementos,iterando sobre los elementos en el orden en que fueron insertados. TreeMap (en realidad una implementaci√≥n de SortedMap) itera sobre las entradas basadas en el orden delclaves.\nClase Collections B√∫squeda\nLa operaci√≥n indexOf() toma un tiempo proporcional al tama√±o de la lista. Llama a Collections.binarySearch(list, element) para devolver el √≠ndice de un elemento en ellista. Si el elemento no aparece en la lista, se devolver√° un n√∫mero negativo.\nhttps://1.bp.blogspot.com/-44M1-u1RI3I/XvJ7TMZRJFI/AAAAAAAAAOk/Ce_w6BmMBZMK4zUHime84nC22LgaA9W5wCK4BGAsYHg/w400-h266/05E.gif Ordenar\nLas colecciones tambi√©n proporcionan operaciones para cambiar el orden de los elementos de una lista. Reverse(list) invierte el orden de todos los elementos de la lista. Shuffle(list) coloca los elementos en orden aleatorio. Sort(list) y Sort(list, comparator) coloca los elementos enen orden ascendente.\nDESARROLLO DE FRAMEWORKS En √©ste cap√≠tulo, se habla de como cambian los patrones de implementaci√≥n, cuando el fin es desarrollar un framework.\nCAMBIAR LOS FRAMEWORKS SIN AFECTAR A LAS APLICACIONES El dilema fundamental en el desarrollo y mantenimiento de los frameworks es que necesitan evolucionar, pero hay un gran costo por romper el c√≥digo de cliente existente. La actualizaci√≥n del framework perfecta, a√±ade nuevas funciones sin cambiar ninguna de las existentes, aunque √©stas actualizaciones compatibles no siempre son posibles.Cuando desarrollamos un framework la mentalidad debe ser totalmente distinta que cuando realizamos c√≥digo de producto convencional, ya que con una herramienta de √©ste tipo, se debe tener en cuenta que en algunas ocasiones es preferible un bloque de c√≥digo m√°s complejo, pero que es mucho m√°s mantenible y mejorable, sin romper c√≥digo de cliente. A pesar de √©sto, la simplicidad siempre debe estar presente, y considerada siempre que sea posible.\nACTUALIZACIONES INCOMPATIBLES Una actualizaci√≥n que se descompone en pasos m√°s peque√±os, avisa al cliente de que es lo nuevo que viene y el por qu√© debe actualizarse a la nueva API. Un ejemplo de esto son los m√©todos deprecados, funcionan pero avisan de que se espera eliminar en futuras versiones.¬†Los paquetes pueden proporcionar una forma de ofrecer a los clientes un acceso incremental a las actualizaciones. Introduciendo nuevas clases en un nuevo paquete, puedes darles el mismo nombre como las viejas clases. Por ejemplo, si puedo actualizar org.junit.Assert en org.junit.newandimproved.Assert , entonces los clientes s√≥lo tienen que cambiar las declaraciones de importaci√≥n para usar el nueva clase. Cambiar las importaciones es menos arriesgado e intrusivo que cambiar el c√≥digo. Otra estrategia incremental es cambiar la API o la implementaci√≥n, pero no ambas en la misma versi√≥n. √âsta versi√≥n intermedia, asociar√≠a la nueva interfaz con el viejo c√≥digo, o la vieja interfaz con el nuevo c√≥digo, lo que dar√≠a m√°s tiempo para afrontar y adaptarse al cambio. IDEs como Eclipse, ofrecen herramientas automatizadas para actualizar el c√≥digo de cliente, de tal forma que a√±ade archivos y mueve funcionalidad, con el fin de adaptarse a la nueva versi√≥n.¬†Puedes reducir el costo de cambiar el c√≥digo si los clientes pueden cambiar a tu funcionalidad mejorada con una simple operaci√≥n de b√∫squeda/reemplazo. El cambio del nombre de un m√©todo, ser√° m√°s barato para los clientes si dejas los argumentos en el el mismo orden.\nFORMATEANDO UN CAMBIO COMPATIBLE Lo ideal ser√≠a que el c√≥digo de cliente depende lo menor posible del framework, y cuando esto no sea posible (para eso est√° el framework), se debe intentar que la funcionalidad de la que dependa no sea propensa a cambios, algo que se consigue mediante reducir el n√∫mero de detalles visibles y mostrar detalles reveladores que son menos probables de cambiar y entregar funcionalidad √∫til, mientras se mantiene la libertad de cambiar el dise√±o.\nCLASE LIBRERIA Un estilo simple y que considera¬†bastante el futuro de la API es la clase de biblioteca. Representan toda su funcionalidad como llamadas de procedimiento con par√°metros simples, entonces los clientes est√°n bien aislados de futuros cambios. Cuando liberas un nuevo de su clase de biblioteca s√≥lo necesita asegurarse de que todos los m√©todos existentes trabajan igual que antes. La nueva funcionalidad se representa como nueva o nuevas variantes de los procedimientos existentes. La clase Colecciones es un ejemplo de una API representada como una clase de biblioteca. Los clientes la utilizan invocando m√©todos est√°ticos, no instanci√°ndola. Nuevas versiones de las clases de colecci√≥n a√±aden nuevos m√©todos est√°ticos, dejando a los existentes funcionalidad sin cambios.\nOBJETOS Asumiendo que vamos a representar nuestro framework como objeto, existe una tarea m√°s dura que equilibra la simplicidad y la complejidad, la flexibilidad y la especificidad, as√≠ que el framework debe ser a la vez √∫til que √∫til, estable para los clientes y evolutivo para usted. El truco es, en la medida que puedas manejarlo, escribir el framework para que los clientes dependen s√≥lo de detalles que no es probable que cambien.\nESTILO DE USO Los frameworks pueden soportar tres estilos principales de uso: instanciaci√≥n, configuraci√≥n,e implementaci√≥n. Cada estilo ofrece diferentes combinaciones de usabilidad, flexibilidad y estabilidad. Tambi√©n puedes mezclar estos estilos en un solo frameworks para proveer un mejor equilibrio entre la libertad de dise√±o para los desarrolladores y el poder para los clientes. El estilo m√°s simple de uso es la instanciaci√≥n. Cuando quiero un socket de servidor escribo:\nnew ServerSocket()\nUna vez instanciado, funciona invocando m√©todos en √©l. La instanciaci√≥n funciona cuando la √∫nica forma de variaci√≥n que los clientes necesitan es la variaci√≥n de los datos, no la l√≥gica. La configuraci√≥n es un estilo de uso m√°s complejo y flexible en el que el cliente crea objetos usando el framework, pero les pasa sus propios objetos para ser llamados en tiempos determinados. Un TreeSet , por ejemplo, puede ser llamado con un Comparator para permitir una clasificaci√≥n arbitraria de los elementos. La configuraci√≥n es m√°s flexible que la instanciaci√≥n porque puede acomodar las variaciones en la l√≥gica as√≠ como en los datos. Sin embargo, ofrece menos libertad al programador, porque una vez que empiezas a llamar a un objeto del cliente, surge la necesidad de seguir llamando a ese objeto de la misma manera y al mismo tiempo o arriesgarse a romper el c√≥digo del cliente. Cuando los clientes necesitan m√°s formas de enganchar su propia l√≥gica que las proporcionadas por configuraci√≥n, entonces puede ofrecer el uso por implementaci√≥n. En la implementaci√≥n,los clientes crean sus propias clases que son utilizadas por el framework. Siempre y cuando la clase de cliente extienda de una clase del framework o implemente una interfaz, el cliente es libre de incluir cualquier l√≥gica que le guste. JUnit mezcla los cuatro estilos de uso:\nJUnitCore es una clase de biblioteca con un m√©todo de ejecuci√≥n est√°tica(Class\u0026hellip;) para ejecutar todas las pruebas en todas las clases. JUnitCore es tambi√©n instancial, con instancias que proporcionan un control m√°s fino sobre la prueba ejecutando y notificando. Las anotaciones @Test , @Before y @After son una forma de configuraci√≥n donde la prueba los escritores pueden identificar bits de c√≥digo para ser ejecutados en ciertos momentos. La anotaci√≥n @RunWith es una forma de implementaci√≥n, donde los escritores de pruebas que necesitan un comportamiento de prueba no est√°ndar pueden implementar sus propios corredores.\nABSTRACCI√ìN Sobre que forma es mejor para implementar el framework, introduce la cuesti√≥n de si representar las entidades abstractas como una interfaz o una superclase com√∫n. Cada enfoque tiene ventajas y desventajas para los desarrolladores y clientes. Los dos enfoques tampoco son mutuamente excluyentes. Un framework puede ofrecer a los clientes tanto una interfaz como una implementaci√≥n predeterminada de esa interfaz.\nINTERFAZ La gran ventaja de ofrecer a los clientes una interfaz es que las interfaces registran pocos detalles. Los clientes no pueden usar \u0026ldquo;accidentalmente\u0026rdquo; m√°s del framework de lo previsto. Sin embargo, esta protecci√≥n tiene un costo. Mientras las interfaces permanezcan sin cambios est√°n bien, pero introducir un nuevo m√©todo en una interfaz rompen todas las implementaciones cliente de esa interfaz. Una variaci√≥n de las interfaces que proporciona cierta flexibilidad adicional a costa de cierta complejidad son las interfaces versionadas. Si se a√±aden operaciones a un interfaz, rompes el c√≥digo del cliente. Sin embargo, puedes crear una subinterfaz y poner las nuevas operaciones all√≠. Los clientes pueden pasar objetos que se ajusten a la nueva donde se espera la antigua interfaz, pero el c√≥digo existente contin√∫a trabajando como antes.\nSUPERCLASE Las ventajas de este estilo son las inversas a las de las interfaces: las clases pueden especificar m√°s detalles que las interfaces, pero a√±adir una operaci√≥n a una superclase no rompe el c√≥digo existente. A diferencia de las interfaces, con la superclases, las clases de cliente s√≥lo pueden extender una clase del framework. Reducir el m√°ximo el numero de detalles visibles para el cliente, nos garantiza una menor limitaci√≥n en un cambio de dise√±o futuro. Los campos en un framework siempre deben ser privados. Si los clientes necesitan acceso a los datos de los campos, facil√≠tenlo a trav√©s de getters. Examine cuidadosamente sus m√©todos y haga p√∫blicos s√≥lo los m√©todos esenciales o, mejor a√∫n, protegido. Seguir estas reglas permite definir una superclase que expone s√≥lo unos pocos detalles m√°s que la interfaz equivalente pero permite los clientes m√°s flexibilidad para engancharse a su propia l√≥gica. La palabra clave abstract te da una forma de comunicarte con los clientes donde ellos se requieren para llenar la l√≥gica. Proporcionar una aplicaci√≥n razonable por defecto de m√©todos donde sea posible para los clientes la posibilidad de empezar f√°cilmente. La palabra clave final cuando se aplica a una clase evita que los clientes creen subclases, reforzando la instanciaci√≥n o el estilo de configuraci√≥n del uso del framework. Los marcos que se organizan en varios paquetes necesitan una declaraci√≥n de visibilidad que diga, \u0026ldquo;Visible dentro del marco pero no a los clientes\u0026rdquo;. Una soluci√≥n a este problema es separar los paquetes en publico e interno y comunicar la diferencia incluyendo al nombre \u0026ldquo;internal\u0026rdquo; en las rutas de paquetes internos. Los paquetes internos proporcionan un punto intermedio entre revelar y ocultar detalles del marco. Los clientes pueden elegir por s√≠ mismos cu√°nta responsabilidad quieren aceptar para construir encima de partes potencialmente inestables del framework.\nSIN CREACI√ìN La opci√≥n m√°s simple y menos poderosa es prohibir a los clientes crear los objetos de la estructura directamente. Los operadores en un m√©todo de factor√≠a pueden garantizar que los eventos est√°n bien formados. La limitaci√≥n de no permitir que los clientes creen instancias de marco es que impide los usos leg√≠timos de las clases.\nM√âTODO EST√ÅTICO (FACTOR√çA) A√±aden cierta complejidad a la creaci√≥n de objetos para los clientes, pero dejan al desarrollador m√°s libertad para futuros cambios de dise√±o. Si un cliente cre√≥ una lista diciendo ArrayList.create() en lugar de usar un constructor, entonces la clase concreta del objeto devuelto podr√≠a ser cambiada sin que afecta al c√≥digo de cliente. Otra ventaja de las factor√≠as est√°ticas es que te dan la oportunidad de comunicar claramente a los clientes el significado de las variaciones en la construcci√≥n.\nOBJETO DE M√âTODOS EST√ÅTICOS (FACTOR√çA) Tambi√©n puedes representar la creaci√≥n de instancias enviando mensajes a una f√°brica en lugar de invocar un m√©todo est√°tico. Por ejemplo, un CollectionFactory podr√≠a proporcionan m√©todos para crear todos los diferentes tipos de colecciones. Podr√≠a ser usado as√≠:\nCollections.factory().createArrayList()\nUn objeto de f√°brica proporciona incluso m√°s flexibilidad que una m√©todo est√°tico pero es m√°s complejo de leer. Necesitas rastrear la ejecuci√≥n del c√≥digo para ver cuando se crean ciertas clases. Mientras la f√°brica s√≥lo se acceda globalmente, un objeto de f√°brica no proporcionan m√°s flexibilidad que los m√©todos de f√°brica est√°ticos.\n","date":"2020-06-24T00:00:00Z","permalink":"https://raulpadilladelgado.github.io/blog/p/an%C3%A1lisis-del-libro-implementation-patterns/","title":"An√°lisis del libro \"Implementation patterns\""},{"content":" https://upload.wikimedia.org/wikipedia/commons/thumb/e/e9/Decorator_UML_class_diagram.svg/400px-Decorator_UML_class_diagram.svg.png Es un patr√≥n de dise√±o que nos va a permitir agregar funcionalidad a un objeto existente sin cambiar su estructura. Se busca poder a√±adir din√°micamente funcionalidad a un Objeto. Esto nos permite no tener que crear sucesivas clases que hereden de la primera incorporando la nueva funcionalidad, sino otras que la implementan y se asocian a la primera.\nUn gran momento para aplicarlo es cuando tenemos una clase que contiene m√©todos que realizan algo m√°s que l√≥gica de negocio. Dicha l√≥gica no tiene que ver con la intencionalidad del m√©todo, pero si es cierto que necesitamos que √©ste ah√≠. Buscamos el desacople de funcionalidades que no deber√≠an estar realizando ciertos m√©todos de una clase, ya que dichos requisitos responden a una forma de implementaci√≥n que puede variar en el futuro, y el hecho de tenerlo separado en otros m√©todos que a√±aden funcionalidad a uno principal, nos permite cambiar f√°cilmente la funcionalidad, sin tener que realizar el cambio en muchos lugares del c√≥digo, lo que nos aporta una gran mantenibilidad del c√≥digo.\nLa forma t√≠pica de implementar √©ste patr√≥n en Java ser√≠a de la siguiente forma. Existe una interfaz\n**public** **interface** **Vehicle** {**void** **start**();} , la cual implementa la clase que especifica\n**public** **class** **Car** **implements** Vehicle { **public** CarType carType; **public** **Car**(CarType carType) { **this**.carType = carType; } **public** **void** **start**() { System.out.print(\u0026#34;Arrancando\u0026#34;);} } , y la clase abstracta que define como se a√±aden los decoradores a la funcionalidad base.\n**public** **abstract** **class** **Decorator** **implements** Vehicle { **private** Car car; **public** **Decorator**(Car car) { **this**.car = car; } **public** **void** **start**() { car.start();} } Tr√°s √©sto, todos los decoradores que vayamos a realizar, deben extender de la clase abstracta anterior, y llamar al m√©todo base de la clase padre.\npublic class EnergyDecorator extends Decorator { private Car car; public EnergyDecorator(Car car) { super(car); this.car=car; } public void start() { super.start(); if(car.carType==CarType.ELECTRIC){System.out.println(\u0026#34; con energ√≠a el√©ctrica\u0026#34;);} if(car.carType==CarType.WIND){System.out.println(\u0026#34; con energ√≠a e√≥lica\u0026#34;);} } } Para crear los objetos tendr√≠amos una factor√≠a,\npublic class CarFactory { public static void startCar(){ new Car(CarType.DEFAULT).start(); } public static void startEnergySpecificCar(CarType carType) { new EnergyDecorator(new Car(carType)).start(); } } y finalmente lo comprobar√≠amos.\npublic class CarShould { @Test void start_with_default_car() { CarFactory.startCar(); //-\u0026gt; Arrancando } @Test void start_with_electric_car() { CarFactory.startEnergySpecificCar(CarType.ELECTRIC); // -\u0026gt; Arrancando con energ√≠a el√©ctrica } @Test void start_with_wind_car() { CarFactory.startEnergySpecificCar(CarType.WIND); // -\u0026gt; Arrancando con energ√≠a e√≥lica } } ","date":"2020-06-23T00:00:00Z","permalink":"https://raulpadilladelgado.github.io/blog/p/patr%C3%B3n-decorator/","title":"Patr√≥n decorator"},{"content":"Puede darse la situaci√≥n de que en nuestra aplicaci√≥n Java, necesitemos atender peticiones representadas en JSON, transformarlas a objetos, tratar los datos y devolver una respuesta en JSON. Los servicios REST o los Websockets son un buen ejemplo de esto.\nPara resolver este problema podemos implementar \u0026ldquo;a mano\u0026rdquo; la l√≥gica de negocio para serializar y deserializar nuestro JSON, lo que supodr√° un esfuerzo considerable. O podr√≠amos hacer uso de alguna liber√≠a dise√±ada para este prop√≥sito como puede ser Gson.\nGson es una biblioteca de c√≥digo abierto para el lenguaje de programaci√≥n Java que permite la serializaci√≥n y deserializaci√≥n entre objetos Java y su representaci√≥n en notaci√≥n JSON.\nLo primero es a√±adir al pom.xml la¬†dependencia Gson, que la podemos encontrar en Maven Repository.\n**\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;**com.google.code.gson**\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;**gson**\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;**2.8.6**\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;** Ya podr√≠amos empezar a usar dicha librer√≠a. Voy a mostrar lo que fue mi uso de la librer√≠a desarrollando una clase que convert√≠a tanto¬†desde¬†JSON como¬†hacia¬†JSON, en el que el punto fuerte era √©ste √∫ltimo m√©todo, en el que le tuve que especificar por par√°metro sobre que tipo de objeto se iba a realizar la conversi√≥n de un JSON a un objeto espec√≠fico para lograr que la conversi√≥n fuese exitosa. En el otro m√©todo, simplemente le paso el objeto que quiero convertir a JSON.\npublic class JsonUtils { public static String convertToJson(Object object) { Gson gson = new Gson(); return gson.toJson(object); } public static Object convertFromJson(String json,Object object){ Gson gson = new Gson(); return gson.fromJson(json, object.getClass()); } } ","date":"2020-06-18T00:00:00Z","permalink":"https://raulpadilladelgado.github.io/blog/p/domina-los-json-con-gson/","title":"Domina los JSON con GSON"},{"content":"Im√°genes vs Contenedores Para entender claramente ambos conceptos, me ayuda asemejarlos a la programaci√≥n habitual, entendiendo que las im√°genes son como clases y los contenedores como los objetos instanciados de las clases.\nLa imagen contiene la base para crear un contenedor, y √©ste carga la imagen para empezar a funcionar. Una imagen puede ser cargada en todos los contenedores que queramos, igual que un contenedor puede cargar varias im√°genes. Cualquier cambio realizado en sistema de archivos del contenedor no afecta a la imagen, pues la imagen solo se usa para la creaci√≥n del contenedor.\nDocker descarga las im√°genes que invocamos en la consola desde DockerHub.\nGesti√≥n de contenedores /*------------------------------------*/ /*Crear contenedor*/ docker run ubuntu /*------------------------------------*/ /*Crear contenedor en modo interactivo (se controla desde la consola actual) (ubuntu:imagen, bash:comando)*/ docker run -ti ubuntu bash /*------------------------------------*/ /*Crear contenedor en segundo plano*/ docker run -ti -d ubuntu bash /*------------------------------------*/ /*Acceder a contenedor ejecutado en segundo plano*/ docker exec -ti nombreDeContenedor|ID /*------------------------------------*/ /*Crear contenedor que se borra al finalizar su ejecuci√≥n*/ docker run --rm ubuntu bash /*------------------------------------*/ /*Arrancar contenedor*/ docker start nombreDeContenedor|ID /*------------------------------------*/ /*Parar contenedor*/ docker stop nombreDeContenedor|ID /*------------------------------------*/ /*Listar contenedores activos*/ docker ps /*------------------------------------*/ /*Listar contenedores activos e inactivos*/ docker ps -a /*------------------------------------*/ /*Borrar contenedores parados*/ docker container prune -f /*------------------------------------*/ /*Borrar un contenedor*/ docker rm nombreDeContenedor|ID /*------------------------------------*/ Gesti√≥n de im√°genes Docker Build y Dockerfile El comando docker build es el comando que ejecuta las instrucciones del fichero dockerfile.\nArchivo Dockerfile FROM ‚Üí Instrucci√≥n que inicializa el sistema de ficheros a usar.\nRUN ‚Üí Ejecuta un comando dentro del sistema de ficheros.\nWORKDIR ‚Üí Directorio del sistema de ficheros donde se ejecutaran los comandos.\nENV ‚Üí Establecer variables de entorno.\nEXPOSE ‚Üí Puerto en el que se expondr√° la imagen.\nVOLUME ‚Üí Especifica un volumen para nuestro contenedor.\nCOPY ‚Üí Copiar archivo de un directorio en otro.\nENTRYPOINT | CMD ‚Üí El entrypoint recibe el comando de cmd. cmd ser√≠an los argumentos de entrypoint.\nFROM ubuntu:latest RUN apt-get update -y RUN apt-get install -y python-pip python-dev WORKDIR /app ENV DEBUG=True EXPOSE 80 VOLUME /data COPY . /app RUN pip install -r requirements.txt ENTRYPOINT [\u0026#34;python\u0026#34;] CMD [\u0026#34;app.py\u0026#34;] Comandos para im√°genes /*------------------------------------*/ /*Listar imagenes*/ docker images /*------------------------------------*/ /*Descargar imagen a local*/ docker pull ubuntu /*------------------------------------*/ /*Borrar todas las imagenes en local*/ docker images prune --all /*------------------------------------*/ /*Borrar una imagen en local*/ docker rmi nombreDeImagen /*------------------------------------*/ /*Borrar imagenes \u0026#34;basura\u0026#34; (no tiene tag o nombre y no esta referenciada por ning√∫n contenedor)*/ docker images prune -f /*------------------------------------*/ /*Taggear una imagen*/ docker tag nombreDeImagen usuario/ubuntu:0.1.0 /*------------------------------------*/ /*Iniciar sesion en DockerHub*/ docker login /*------------------------------------*/ /*Subir imagen a DockerHub*/ docker push nombreDeImagen /*------------------------------------*/ /*Contruir imagen a partir de receta (fichero Dockerfile) (para el directorio actual)*/ docker build . /*------------------------------------*/ /*DOCKERFILE Para crear imagen siguiendo pasos*/ FROM ubuntu RUN apt-get update RUN apt-get install -y ineutils-ping RUN apt-get install -y nettools /*------------------------------------*/ Docker almacenar√° en cach√© los resultados de la primera compilaci√≥n de un Dockerfile, lo que permitir√° que las compilaciones posteriores ser√°n s√∫per r√°pidas.¬†En cada aparici√≥n de un comando RUN en el Dockerfile, Docker crear√° y confirmar√° una nueva capa en la imagen.\n/******************************************/ /*Comando que se ejecuta al iniciar la imagen en un contenedor*/ CMD echo \u0026#34;hello world\u0026#34; /******************************************/ /*Ejecutar un comando pasado como parametro a la ejucci√≥n de un contenedor*/ docker run --rm test echo \u0026#34;goodbye\u0026#34; /******************************************/ ¬øDiferencia entre CMD y ENTRYPOINT? Con CMD considera que lo que pasemos no debe formar parte de la construcci√≥n, por lo que si otro comando es pasado al contenedor interfiere con lo anterior ser√° sobreescrito, sin embargo con entrypoint se mantendr√≠a, ya que pasa a formar parte de la construcci√≥n del contenedor.\n/******************************************/ /*A√±adir un ENTRYPOINT a un contenedor*/ docke run --rm --entrypoint=\u0026#34;\u0026#34; test bash /******************************************/ /*Informaci√≥n extensa*/ docker container inspect nombreDeContenedor /******************************************/ /*Listar im√°genes*/ docker images ls /******************************************/ /*Borrar volumenes*/ docker volume rm nombreDeVolumen /******************************************/ /*Definir una red, nombre, nombre de host para un contenedor*/ docker run --rm --network=none --name nombreDeContenedor --hostname nombreDeHost /******************************************/ /*Crear una red*/ docker network create test /******************************************/ Docker garantiza el aislamiento de contenedores hac√≠a otros contenedores que est√°n en distintas redes.\nDOCKER COMPOSE Compose es una herramienta para definir y ejecutar aplicaciones multicontenedores en Docker.¬†Utiliza un archivo YAML para configurar los servicios de su aplicaci√≥n. Luego, con un solo comando, crea e inicia todos los servicios desde su configuraci√≥n.\nDefina el entorno de su aplicaci√≥n con un Dockerfile para que pueda reproducirse en cualquier lugar. Defina los servicios que componen su aplicaci√≥n docker-compose.yml para que puedan ejecutarse juntos en un entorno aislado. Ejecutar docker-compose up y compose inicia y ejecuta toda su aplicaci√≥n. Ejemplo de archivo docker-compose.yml\nversion: \u0026#39;2.0\u0026#39; services: web: build: . ports: - \u0026#34;5000:5000\u0026#34; volumes: - .:/code - logvolume01:/var/log links: - redis redis: image: redis volumes: logvolume01: {} Otros comandos docker-compose config ‚Üí verificar que nuestro compose est√° correctamente estructurado\nArrancar servicios con docker compose ‚Üí docker-compose up docker-compose ls ‚Üí listar servicios activos\ndocker-compose exec php bash ‚Üí entrar en servicio activo\ndocker-compose down ‚Üí Stops containers and removes containers, networks, volumes, and images created by up.\n","date":"2020-06-09T00:00:00Z","permalink":"https://raulpadilladelgado.github.io/blog/p/docker-basics/","title":"Docker basics"},{"content":"Recientemente, he realizado una kata en Java, que consist√≠a en implementar un parseador de plantillas.\nExiste un m√©todo que recibe como par√°metros la plantilla (String) a parsear, y un diccionario (Map) con todas las claves que vamos a sustituir en la cadena anterior. Es √©ste m√©todo el encargado de cambiar cada variable en la cadena por cada variable en el diccionario.\nPara el desarrollo del ejercicio, segu√≠ la metodolog√≠a de TDD, por lo que primero expuse una serie de casos en los que se definen como se deber√≠a comportar √©ste parseador testando la salida que devuelve con lo que esperamos, y poco a poco, realizando un test y el c√≥digo justo y necesario para cada caso, fui viendo como llevar casos muy espec√≠ficos hasta casos muy generales, llegando hasta la iteraci√≥n s√≥lo en el momento necesario, para no tener a una soluci√≥n muy complicada desde el principio por intentar precipitarse en generalizar cuando solo necesitamos cubrir un caso espec√≠fico.\nDesarrollar de √©sta forma, me aporta el control del problema, adem√°s, me brinda tanto la seguridad de que estoy creando una soluci√≥n funcional como simple y legible. Gracias a que fue desarrollada en su mayor√≠a en pair programming se pudo exponer una serie de casos de prueba que cubr√≠an muy bien el m√©todo a testear.\nPor aqu√≠ comparto mi desarrollo en la kata mediante un repositorio de GitHub.\nTemplateEngineKata(https://github.com/raulpadilladelgado/TemplateEngineKata)\n","date":"2020-06-09T00:00:00Z","permalink":"https://raulpadilladelgado.github.io/blog/p/kata-template-engine/","title":"Kata template engine"},{"content":" Portada libro INTRODUCCI√ìN \u0026ldquo;Dise√±o √Ågil con TDD\u0026rdquo;, por Carlos Ble, es un libro muy interesante que nos ense√±a como implementar Test-Driven Development en el desarrollo de c√≥digo. Muestra como basar nuestro c√≥digo en los Test que escribimos, y no al rev√©s. A continuaci√≥n comparto mis experiencias leyendo √©ste libro.\n¬øQUE BENEFICIOS NOS APORTA? Se presentan grandes beneficios de codificar de √©sta forma. Se habla de conseguir un c√≥digo simple, que haga lo que necesitamos para cada momento, que cuando falle nos de un correcto y constante feedback de porqu√© eso est√° ocurriendo, as√≠ como un c√≥digo legible y f√°cil de mantener. Obliga a los programadores a pensar primero en cual es la soluci√≥n que quieren conseguir antes de comenzar a implementarla, y como consecuencia llegar a manejar diversas formas de conseguir lo que se desea teniendo en cuenta m√°s casos de uso\nUn programador deber√≠a tener siempre el control del c√≥digo, no tiene porque llevarse sorpresas. Cuando dedicamos tiempo a desarrollar pruebas nos estamos asegurando de que vamos a crear un c√≥digo que implementa lo que cada caso de prueba requiere. Saber cuando va a fallar y por qu√© va a fallar nos da un control sobre el c√≥digo que lo vuelve mantenible y mejorable. Incluso cuando nos esperamos un fallo en la aplicaci√≥n, una prueba realizada con anterioridad nos puede estar diciendo que est√° fallando y por qu√©, por lo que nunca perdemos el sentido de lo que hace nuestra aplicaci√≥n.\nEl ciclo de crear un test aun sin implementar c√≥digo para verlo fallar (rojo), desarrollar el c√≥digo para ese caso de prueba, y finalmente verlo pasar la prueba (verde) nos hace tener ese control de que sabemos lo que est√°n haciendo nuestros m√©todos en todo momento. Cuando sabemos aplicar √©sto y entedemos el porqu√© a√±adir pruebas a nuestros proyectos, tenemos un c√≥digo mantenible, ese que facilita de la vida al programador cuando tiene que arreglar fallos en la aplicaci√≥n. Por otro lado implementar TDD tambi√©n comprende los ciclos de refactorizaci√≥n. Tras ver nuestra prueba en verde, sabemos que tenemos un c√≥digo correcto y funcional, por lo que es el momento perfecto para tratar de transformar el c√≥digo a uno m√°s simple y legible. No se trata de cambiar la funcionalidad del c√≥digo, ya que hemos visto que es correcta, se trata de que haga lo mismo pero con una presentaci√≥n m√°s amigable, que cuando se lea parezca que cuenta una historia f√°cil de seguir.\nUn punto positivo de aplicar TDD es que vamos implementando s√≥lo que necesitamos en cada momento, por lo que evitamos a√±adir funcionalidades \u0026ldquo;extra\u0026rdquo; que no son necesarios para el estado actual de la aplicaci√≥n, una pr√°ctica que llegar a complicar mucho el c√≥digo as√≠ como su compresi√≥n y el control sobre √©l.\n¬øCOMO DEBEMOS TESTEAR? Para nuestros test usamos BDD (Desarrollo guiado por el comportamiento), que nos dice que nuestro test debe seguir el patr√≥n Given-When-Then(Preparaci√≥n, ejecuci√≥n y validaci√≥n):\nGiven ‚Üí Dado unos elementos\u0026hellip; When ‚Üí \u0026hellip;realiza √©sto\u0026hellip; Then ‚Üí \u0026hellip;y espero que ocurra lo siguiente. Gracias a BDD, nuestros test tienen una estructura clara, sencilla y concreta, cuentan una historia. Una persona que no sepa programar deber√≠a entender que pretende hacer el test, por lo que buscamos el menor numero de l√≠neas posibles en cada bloque. Para lograr que nuestro bloque \u0026lsquo;Then\u0026rsquo; compruebe varios factores pero que aparezca en una sola l√≠nea, podemos crear nuestra propia aserci√≥n:\n/*Llamada*/ assertThatList(list).isExactly(10, 20) /*Implementaci√≥n*/ fun assertThatList(list: List\u0026lt;Number\u0026gt;) : ListMatchers { return ListMatchers(list) } class ListMatchers(val actualList: List\u0026lt;Number\u0026gt;) { fun isExactly(vararg items: Number){ assertThat(items.size).isEqualTo(actualList.size) for(i in items.indices){ assertThat(items[i]).isEqualTo(actualList[i]) } } } Los nombres de los test deben tener un nombre significativo que puede formar un juego de palabras con el nombre de la clase para formar una frase con sentido y que aclare la intenci√≥n del test. Deben ser m√°s abstractos que su contenido, esto es no dar detalle de la implementaci√≥n.\nTenemos la opci√≥n de crear un m√©todo decorado con la anotaci√≥n @Before, que significa que el framework ejecutar√° ese m√©todo justo antes de cada uno de los test. Si hay N test, se ejecutar√°\nN veces. Est√° pensado as√≠ para garantizar que los test no se afecten unos a los otros.Cuando recurrimos a debug para encontrar un error en nuestro test, estamos perdiendo el control del flujo del programa, por lo que la mejor soluci√≥n es buscar una soluci√≥n alternativa a lo que estamos haciendo que si comprendamos y que no de lugar a errores inesperados.En la misi√≥n de refactorizar nuestro gran aliado son los IDE, que realizan de forma autom√°tica las transformaciones como extraer variables, y que el punto fuerte de todo esto es evitar el error humano. No que es que sea una simple ayuda realizar refactorizaci√≥n autom√°tica, es que es lo aconsejable, ya que nos garantiza que un cambio realizado en una clase se efectuar√° en los dem√°s sitios donde est√© referenciado, algo fundamental para romper nuestro c√≥digo.Por mucha cobertura de c√≥digo que obtengamos realizando test a nuestras l√≠neas de c√≥digo, no nos garantiza una efectividad del 100%. Para solventar √©sto, el testeo autom√°tico se debe complementar con testeo exploratorio, ese tipo de pruebas que realizamos manualmente y que prueban la aplicaci√≥n por completo como si se tratase del usuario final. Cuando aplicamos TDD no buscamos reeemplazar las pruebas manuales, solo tratamos de tener que hacerlo lo menor posible cuando algo se puede automatizar facilmente para as√≠ no perder tiempo y dinero en algo repetitivo.\nIncluso en el testeo exploratorio se pueden automatizar algunas partes. Para lograr √©sto tenemos los test basado en propiedades, que no definen datos concretos, si no que en su lugar se definen propiedades o casos que debe cumplir el c√≥digo que se va a probar, como el caso de que el resultado de una suma debe ser mayor que cualquiera de sus sumandos. Las herramientas que ofrecen este tipo de automatizaci√≥n generan un gran n√∫mero de combinaciones complejas con el fin de probar todos los posibles caminos llegando a casos extremos en los que un programador no puede estar pensando.\nPRINCIPIOS NECESARIOS La premisa de la prioridad de transformaci√≥n (TPP) es un factor fundamental para realizar TDD, y nos habla de implementar el c√≥digo m√°s sencillo para un test que est√° en rojo, escribir c√≥digo solo para que dicho test pase, sin generalizar para otros casos. El porqu√© hacerlo as√≠ se debe a que te obliga a ir pensando todos los casos e ir implementando poco a poco lo que necesites, sin tener que a√±adir m√°s de lo que puedes llegar a necesitar, o de a√±adir cosas que no comprendes porque todav√≠a no has elaborado un caso de prueba para cierta funcionalidad. Cada test en verde debe producir una generalizaci√≥n en el c√≥digo para otro caso de prueba nuevo. La clave para entender bien √©ste concepto es ver que un problema se descompone a su vez en muchos subproblemas que son los que vamos a ir resolviendo poco a poco, desde lo m√°s sencillo, a lo m√°s complicado.\nEl principio de menor sorpresa, nos cuenta que el c√≥digo debe hacer en todo momento lo que espera que haga, esto es, una funci√≥n debe hacer lo que intuitivamente se espera al interpretar su nombre, par√°metros, etc. Sin tener que entrar a ver como est√° implementada se debe tener la idea de que es lo que hace. Si una funci√≥n hace lo que su nombre indica pero adem√°s otras cosas por detr√°s que no van a acorde con la misi√≥n de dicha funci√≥n, es un c√≥digo que genera sorpresas y que no deseamos tener. Para evitar que una funci√≥n realice m√°s cosas de las que le corresponden podemos recurrir a la separaci√≥n de responsabilidades, llevando tal comportamiento a otra funci√≥n que realice solo eso. Adem√°s, es importante tener el mismo nivel de abstracci√≥n en toda la funci√≥n para que ning√∫n bloque parezca mucho m√°s complicado que otro visualmente.\n/*ANTES*/ r.wrap(); s.getText().concat(\u0026#34;! is the best.\u0026#34;); /*DESPU√âS*/ r.wrap(); s.append(\u0026#34;! is the best.\u0026#34;); Para aplicar TPP, nos sirven de ayuda las trasformaciones que propone Robert C. Martin:\n{} ‚Äì\u0026gt; nil: De no haber c√≥digo a devolver nulo. nil -\u0026gt; constant: De nulo a devolver un valor literal. constant -\u0026gt; constant+: De un valor literal simple a uno m√°s complejo. constant -\u0026gt; scalar: De un valor literal a una variable. statement -\u0026gt; statements: A√±adir m√°s l√≠neas de c√≥digo sin condicionales. unconditional -\u0026gt; if: Introducir un condicional scalar -\u0026gt; array: De variable simple a colecci√≥n. array -\u0026gt; container: De colecci√≥n a contenedor. statement -\u0026gt; recursion: Introducir recursi√≥n. if -\u0026gt; while: Convertir condicional en bucle. expression -\u0026gt; function: Reemplazar expresi√≥n con llamada a funci√≥n. variable -\u0026gt; assignment: Mutar el valor de una variable. Algo que puede llegar a resultar chocante para un programador es que le digan que para trabajar correctamente con TDD debe dejar de pensar primero como un programador. ¬øEntonces como debe actuar?, es sencillo, anteriormente he explicado que TDD nos hace ir paso a paso en el desarrollo de c√≥digo para que as√≠ podamos pensar al detalle cada posible caso de prueba de la aplicaci√≥n, entonces podemos decir que el programador que aplica TDD en su modus operandi siempre piensa primero como un analista de negocio que interpreta primero los posibles casos o reglas de negocio, y no como un programador que solo busca codificar cuanto antes la soluci√≥n sin atender a pensar un poco como llegar√° hasta ah√≠.\nPara ilustrar mejor como ser√≠a aplicar TDD desde 0 podemos ver un peque√±o ejemplo de una funci√≥n que comprueba si una contrase√±a dada se considera fuerte o segura.\n/*EL CASO M√ÅS SIMPLE*/ describe(\u0026#39;The password strength validator\u0026#39;, () =\u0026gt; { it(\u0026#39;considers a password to be strong when all requirements are met\u0026#39;, () =\u0026gt; { expect(isStrongPassword(\u0026#34;1234abcdABCD_\u0026#34;)).toBe(true); }); }); /*Y SU SOLUCI√ìN PARA LLEGAR AL VERDE*/ function isStrongPassword(password){ return true; } /******************************************************************************/ /*UN CASO M√ÅS GENERAL*/ it(\u0026#39;fails when the password is too short\u0026#39;, () =\u0026gt; { expect(isStrongPassword(\u0026#34;1aA_\u0026#34;)).toBe(false); }); /*Y SU SOLUCI√ìN PARA LLEGAR AL VERDE*/ function isStrongPassword(password){ return password.length \u0026gt;= 6; } Podemos ver como primero se contempl√≥ el caso m√°s obvio el m√°s simple, que no es otro que la contrase√±a cumpla todos los requisitos y no necesitamos m√°s que devolver un true para que √©sto sea verdad y pase. M√°s adelante ya se referencia un caso en el que la contrase√±a es muy corta y ya necesitamos hacer una comprobaci√≥n para eso, por lo que aplicamos el m√≠nimo c√≥digo para comprobar si la contrase√±a pasada cumple la longitud requerida o no.\nT√âCNICAS DE TESTEO Pongamos el caso de que tenemos una funci√≥n que queremos testear, pero √©sta funci√≥n llama a otra funci√≥n. Nosotros queremos comprobar que la primera funci√≥n funciona, por lo que la llamada a la segunda funci√≥n simplemente est√° ah√≠ porque forma parte de la implementaci√≥n. En un caso en el que ambas funciones realizan algo sencillo no deber√≠a importar demasiado, pero si la segunda funci√≥n realice un comportamiento complejo que requiera de un tiempo de ejecucci√≥n considerable no nos interesa que nuestro test gaste fuerzas en cosas que ya est√°n testadas por otro lado. Cuando realizamos pruebas, podemos recurrir a simular objetos o funciones (Mocks), es decir, ese objeto lo tenemos disponible para usar en nuestro test pudiendo llamar a sus m√©todos, pero al ser una simulaci√≥n no ejecutara los m√©todos realmente, por lo que si el m√©todo realizase llamadas a base de datos o interactuase con el sistema de archivos realmente no lo estar√≠a haciendo. Adem√°s nos ofrece otras ventajas como son simular la entrada de par√°metros, verificar que se llama una funci√≥n, etc.\nLos frameworks de mocks son ideales para poder introducir test en un c√≥digo legado sin caer en el intento. Cuando nos encontramos con √©se c√≥digo de una clase que tiene 20000 l√≠neas y que llama a muchas otras clases o funciones, podemos ir haciendo mock de lo que no necesitamos testear por el momento, por lo que si en un momento determinado solo queremos probar una clase o sus m√©todos la mejor opci√≥n es mockear y ver que simplemente pasa lo correcto a llamadas externas que realiza.\nPara usar √©stos Mocks en Java lo podemos realizar de la siguiente forma:\nPara que nuestra clase de los test pueda usar los m√©todos de Mockito tengo que extender de su clase.Para mockear un objeto basta con usar el m√©todo mock.Tenemos para usar m√©todo de mockitos como \u0026lsquo;when\u0026rsquo; con el cual podemos usar \u0026lsquo;any()\u0026rsquo; para simular que se le pas√≥ lo que ese m√©todo necesita, y si combinamos el \u0026lsquo;when\u0026rsquo; con un \u0026rsquo;thenReturn\u0026rsquo; podemos comprobar que cuando se ejecuta devuelve lo que esperamos, o incluso un \u0026rsquo;thenThrow\u0026rsquo; para cuando lanza una excepci√≥n. Otro m√©todo interesante es \u0026lsquo;verify\u0026rsquo; que comprobar√° que se llama a la funci√≥n de un objeto.\n@ExtendWith(MockitoExtension.class) class RegisterVolunteerActionShould { TemplateService templateService = mock(TemplateService.class); EmailService emailService = mock(EmailService.class); @Test void send_confirmation_email(){ when(templateService.getEmailConfirmationTemplate(any())).thenReturn(new EmailTemplate(template)); verify(emailService).sendEmail(any()); } } Tambi√©n tenemos otro tipo de dobles que son los fakes, que bien puede ser una base de datos en memoria, repositorio en memoria, un servidor de correo que realmente no env√≠a correo. Todo para que tengamos la funcionalidad m√°s parecida o igual al artefacto real pero facilit√°ndonos la vida en los test simplificando la forma en que hace las validaciones.\nERRORES T√çPICOS AL HACER TDD Infravalorar el nombre de los test es una muy mala decisi√≥n. Pensar un buen nombre para nuestro test nos da un mayor conocimiento de lo que estamos haciendo y esperamos, adem√°s de que un test con un buen nombre que nada m√°s leerlo ya sabes que deber√≠a estar haciendo, se convierte en documentaci√≥n viva del proyecto para que no nos perdamos ni nosotros ni futuros desarrolladores que vean nuestro c√≥digo.\nComo tanto cuidamos sus nombres, debemos cuidar su presentaci√≥n. Es fundamental ir aplicando refactor tras ver los verdes para tener test legibles y f√°ciles de mantener. El c√≥digo de nuestros test es tan importante como el de producci√≥n.\nSi tenemos un test en rojo est√° en rojo, no intentemos desviarnos ignorando que eso est√° ah√≠ para no perder la eficacia de nuestra colecci√≥n de test. Debemos arreglar √©sto antes de seguir en el desarrollo del proyecto para garantizar que seguimos cubiertos en lo mayormente posible.\nNuestro test solo busca verificar que se cumple un solo comportamiento del sistema, por lo que intentar meter otro tipo de comportamiento es un error. Solo as√≠ entenderemos mejor cuando falle el por qu√© lo hace, y estaremos teniendo a la vez una documentaci√≥n precisa de como va avanzando nuestro c√≥digo.\nNo necesitamos complejidad ciclom√°tica introduciendo bucles o condicionales en nuestros test, no queremos que nuestro test corra el riesgo de fallar por factores ajenos al comportamiento que est√° testando, as√≠ como no queremos un aumento de su complejidad.\nCONCLUSI√ìN TDD es una forma de codificar, cada cual es libre de seguir su metodolog√≠a preferida, pero los beneficios est√°n ah√≠. Cuando nos acostumbramos a trabajar de √©sta forma y empezamos a ver su gran utilidad podemos desarrollar un c√≥digo honesto, ese c√≥digo que no pretende ser perfecto (porque eso no existe en la programaci√≥n), si no que pretende tener un constante feedback con el desarrollador y ser lo m√°s simple posible. Aprender a usarlo en un d√≠a no es posible, es la pr√°ctica quien har√° de nosotros unos buenos analizadores de c√≥digo que se plantean primero los problemas antes de saltar al estilo kamikaze a la acci√≥n. Para empezar, la mejor forma es realizarlo con katas (ejercicios cortos de programaci√≥n) que nos obliguen a pensar en su soluci√≥n, pudiendo as√≠ practicar desde lo m√°s b√°sico de TDD. El mob programming es perfecto para aprender m√°s r√°pido, vemos las posibles soluciones de otros, sus puntos de vista y los contrastamos con los nuestros para determinar cual ser√° la mejor soluci√≥n o incluso darnos cuenta de a veces hay muchos casos que no se nos pasan por la cabeza.\n","date":"2020-05-11T00:00:00Z","permalink":"https://raulpadilladelgado.github.io/blog/p/an%C3%A1lisis-del-libro-dise%C3%B1o-%C3%A1gil-con-tdd/","title":"An√°lisis del libro \"Dise√±o √°gil con TDD\""},{"content":"En la capa de l√≥gica de nuestra aplicaci√≥n se encuentra el c√≥digo m√°s personal del programador, ese c√≥digo que no necesita basarse en primitivos para cumplir tipos de datos en transferencias porque es otra capa quien lo har√° por √©sta.\nAnteriormente he definido \u0026ldquo;el c√≥digo m√°s personal del trabajador\u0026rdquo;, y me refiero a que la estructura y legibilidad del c√≥digo en √©sta capa depende de como se implemente. Si no se nos exigen primitivos, podemos crear nuestros propios tipos para que cuando se lea el c√≥digo mejoremos la expresividad y legibilidad, en una capa como la que menciono en la que se encuentra el n√∫cleo de la aplicaci√≥n y a su vez el c√≥digo que m√°s desarrollo y razonamiento necesita.\nCon tus propios tipos se te abre un mundo de posibilidades para simplificar tu c√≥digo. En el siguiente ejemplo tenemos una clase que utiliza un String como un texto, y verifica que cuando sea null retorne un String vac√≠o.\npublic String wordWrap(String text, int columnWidth){ if (text==null){ return \u0026#34;\u0026#34;; } } Esta clase no deber√≠a estar haciendo √©stas comprobaciones, su misi√≥n es √∫nica, solo deber√≠a implementar la funci√≥n para la que fue pensada, por lo que refactorizando lo anterior podemos crear nuestro propio tipo delegando la construcci√≥n a un m√©todo de factor√≠a que llamar√° al constructor y que cuando reciba un null lo transforme a un String vac√≠o. El porqu√© usar un m√©todo de factor√≠a en lugar del constructor como tal se debe a que un constructor solo deber√≠a realizar lo que su nombre indica, construir un objeto, por lo que cualquier otro tipo de implementaci√≥n dentro de √©ste solo conseguir√≠a empeorar la legibilidad en nuestro c√≥digo.\n/*Texto.java*/ public class Texto{ private String texto; private Texto(String texto) {this.texto=texto;} public static Texto crearTexto(String texto){ if (texto==null){texto=\u0026#34;\u0026#34;;} return new Texto(texto); } } /*application.java*/ public String wordWrap(Texto texto, int columnWidth){ } Listo, la clase en cuesti√≥n ya solo tiene que preocuparse de implementar su funcionalidad, ya que hemos llevado el String inicial a nuestro propio tipo \u0026ldquo;Texto\u0026rdquo;, el cu√°l tiene un m√©todo para realizar la anterior comprobaci√≥n, y as√≠ la podemos extraer de \u0026ldquo;application,java\u0026rdquo;.\nHemos creado un Value Object, lo que quiere decir que su estado no mutar√° a lo largo del tiempo no como si lo hace una entidad. Como ya hemos visto, este tipo de objetos nos permiten volver nuestro c√≥digo m√°s legible y bonito, logrando as√≠ que no solo nosotros lo entendamos perfectamente, si no que tambi√©n lo haga una persona que no desarroll√≥ dicho c√≥digo.\nCuando creamos nuestro propios tipos, debemos tener claro que cada clase debe tener una responsabilidad. Una clase que utiliza m√©todos de otra, deber√≠a estar accediendo a √©sta para obtener datos, no para suplantar la identidad y desarrollar un comportamiento que no deber√≠a ser suyo. Estamos hablando de un code smell al que se le denomina Feature Envy. Para verlo m√°s claro, en el siguiente ejemplo:\npublic class Phone { private final String unformattedNumber; public Phone(String unformattedNumber) { this.unformattedNumber = unformattedNumber; } public String getAreaCode() { return unformattedNumber.substring(0,3); } public String getPrefix() { return unformattedNumber.substring(3,6); } public String getNumber() { return unformattedNumber.substring(6,10); } } public class Customer... private Phone mobilePhone; public String getMobilePhoneNumber() { return \u0026#34;(\u0026#34; + mobilePhone.getAreaCode() + \u0026#34;) \u0026#34; + mobilePhone.getPrefix() + \u0026#34;-\u0026#34; + mobilePhone.getNumber(); } tenemos una clase \u0026ldquo;Phone\u0026rdquo; que tiene como propiedad un n√∫mero de tel√©fono (String), y mediante m√©todos se puede acceder a dicha propiedad y extraer el \u0026ldquo;areacode\u0026rdquo;, \u0026ldquo;prefix\u0026rdquo; y \u0026ldquo;number\u0026rdquo;. Por otro lado, la clase \u0026ldquo;Customer\u0026rdquo;, que accede a clase anterior para conseguir un n√∫mero de tel√©fono (String) accediendo a los m√©todos de √©sta para implementar su propia funci√≥n de formatear un n√∫mero de tel√©fono a un estado m√°s legible.\nEs un c√≥digo funcional, pero ¬øno deber√≠a ser la primera clase (Phone) la que desarrolle dicha funcionalidad?, al fin y al cabo es la clase que sabe operar con n√∫meros de tel√©fono, por lo que la segunda clase (Customer) no deber√≠a saber hacer eso ya que su comportamiento es otro. Si arreglamos un poco lo anterior nos queda algo as√≠:\npublic class Phone { private final String unformattedNumber; public Phone(String unformattedNumber) { this.unformattedNumber = unformattedNumber; } public String getMobilePhoneNumber() { return \u0026#34;(\u0026#34; + getAreaCode() + \u0026#34;) \u0026#34; + getPrefix() + \u0026#34;-\u0026#34; + getNumber(); } public String getAreaCode() { return unformattedNumber.substring(0,3); } public String getPrefix() { return unformattedNumber.substring(3,6); } public String getNumber() { return unformattedNumber.substring(6,10); } } public class Customer... private Phone mobilePhone; private String emailAddress; public String dataOfCustomer(){ return mobilePhone.getMobilePhoneNumber() + emailAddress; } Se implement√≥ lo anterior en la primera clase (Phone), por lo que ahora la segunda (Customer) accede a √©ste m√©todo para obtener lo que desea y hemos conseguido que cada clase cumpla con su misi√≥n sin que ninguna se entrometa en el funcionamiento de otro, y no intente implementar cosas que no debe conocer\n","date":"2020-04-21T00:00:00Z","permalink":"https://raulpadilladelgado.github.io/blog/p/evita-primitive-obsession/","title":"Evita primitive obsession"},{"content":"Lombok es una biblioteca Java que nos permite reemplazar las l√≠neas de c√≥digo que creamos para los constructores, getter y setter, entre otros, por unas simple anotaciones, por lo que cuando creamos una clase solo definimos las propiedades y √©sta librer√≠a hace el resto.\nCon una simple anotaci√≥n(@Data), Lombok inyectar√° los m√©todos getter y setter para cada propiedad, adem√°s de un equals, hashCode y toString.\nhttps://1.bp.blogspot.com/\u0026ndash;CYarvynlTU/Xp24u-wh6zI/AAAAAAAAAKE/-pW3SGJ7qokEtPL93HgN911_hjvzZCnnQCLcBGAsYHQ/s400/28ae0b5bfcf57c9972db8ecc6f9df091_f652.png @Getter y Setter Se usan para generar un getter y setter para un atributo espec√≠fico.\n/*BEFORE*/ public boolean isEmployed() { return employed; } public void setEmployed(final boolean employed) { this.employed = employed; } /*AFTER*/ @Getter @Setter private boolean employed; @NonNull Cuando se coloca en un atributo para el que Lombok est√° generando un m√©todo de establecimiento, se generar√° una comprabaci√≥n que dar√° como resultado un NullPointerException, si se proporciona un valor nulo.\n/*BEFORE*/ public class Family{ private List\u0026lt;Person\u0026gt; members; public Family(List\u0026lt;Person\u0026gt; members) { if (members == null) throw new java.lang.NullPointerException(\u0026#34;members\u0026#34;); this.members = members; } public void setMembers(List\u0026lt;Person\u0026gt; members) { if (members == null) throw new java.lang.NullPointerException(\u0026#34;members\u0026#34;); this.members = members; } } /*AFTER*/ @Setter @NonNull private List\u0026lt;Person\u0026gt; members; @ToString Genera una implementaci√≥n del m√©todo toString. Imprimir√° todos los atributos en forma de clave-valor, para todos los campos que no sean est√°ticos. Podemos personalizar su funcionamiento mediante los siguientes par√°metros:\nincludeFieldNames = false ‚Üí No incluye el nombre de los atributos (clave) exclude=\u0026ldquo;nombreDeAtributo\u0026rdquo; ‚Üí No incluye el atributo especificado of ‚Üí Lista de atributos a imprimir callSuper = true ‚Üí Junta el toString de la clase actual con el de la clase de la que extiende /*BEFORE*/ public class Foo extends Bar { private boolean someBoolean = true; private String someStringField; private float someExcludedField; @java.lang.Override public java.lang.String toString() { return \u0026#34;Foo(super=\u0026#34; + super.toString() + \u0026#34;, someBoolean=\u0026#34; + someBoolean + \u0026#34;, someStringField=\u0026#34; + someStringField + \u0026#34;)\u0026#34;; } } /*AFTER*/ @ToString(callSuper=true,exclude=\u0026#34;someExcludedField\u0026#34;) public class Foo extends Bar { private boolean someBoolean = true; private String someStringField; private float someExcludedField; } @EQUALSANDHASHCODE Generar√° una implementaci√≥n de los m√©todos equals y hashCode, para comparar un objeto de la clase con otro. Le podemos especificar una serie de par√°metros:\nexclude=\u0026ldquo;nombreDeAtributo\u0026rdquo; ‚Üí No compara por el atributo especificado of ‚Üí Lista de atributos a comparar callSuper = true ‚Üí Compara tambi√©n por la clase de la que extiende /*BEFORE*/ public class Person extends SentientBeing { enum Gender { /*public static final*/ Male /* = new Gender() */, /*public static final*/ Female /* = new Gender() */; } @NonNull private String name; @NonNull private Gender gender; private String ssn; private String address; private String city; private String state; private String zip; @java.lang.Override public boolean equals(final java.lang.Object o) { if (o == this) return true; if (o == null) return false; if (o.getClass() != this.getClass()) return false; if (!super.equals(o)) return false; final Person other = (Person)o; if (this.name == null ? other.name != null : !this.name.equals(other.name)) return false; if (this.gender == null ? other.gender != null : !this.gender.equals(other.gender)) return false; if (this.ssn == null ? other.ssn != null : !this.ssn.equals(other.ssn)) return false; return true; } @java.lang.Override public int hashCode() { final int PRIME = 31; int result = 1; result = result * PRIME + super.hashCode(); result = result * PRIME + (this.name == null ? 0 : this.name.hashCode()); result = result * PRIME + (this.gender == null ? 0 : this.gender.hashCode()); result = result * PRIME + (this.ssn == null ? 0 : this.ssn.hashCode()); return result; } } /*AFTER*/ @EqualsAndHashCode(callSuper=true,exclude={\u0026#34;address\u0026#34;,\u0026#34;city\u0026#34;,\u0026#34;state\u0026#34;,\u0026#34;zip\u0026#34;}) public class Person extends SentientBeing { enum Gender { Male, Female } @NonNull private String name; @NonNull private Gender gender; private String ssn; private String address; private String city; private String state; private String zip; } @Data Combina la funcionalidad de¬†@ToString, @EqualsAndHashCode, @Getter, y @Setter, todo lo que un Plain Old Java Object (POJO) necesita. Tambi√©n se le pueden especificar par√°metros como:\nstaticConstructor = \u0026ldquo;metodoFactoria\u0026rdquo; ‚Üí El constructor se vuelve privado y se crea un m√©todo factor√≠a con el nombre especificado. /*BEFORE*/ public class Company { private final Person founder; private String name; private List\u0026lt;Person\u0026gt; employees; private Company(final Person founder) { this.founder = founder; } public static Company of(final Person founder) { return new Company(founder); } public Person getFounder() { return founder; } public String getName() { return name; } public void setName(final String name) { this.name = name; } public List\u0026lt;Person\u0026gt; getEmployees() { return employees; } public void setEmployees(final List\u0026lt;Person\u0026gt; employees) { this.employees = employees; } @java.lang.Override public boolean equals(final java.lang.Object o) { if (o == this) return true; if (o == null) return false; if (o.getClass() != this.getClass()) return false; final Company other = (Company)o; if (this.founder == null ? other.founder != null : !this.founder.equals(other.founder)) return false; if (this.name == null ? other.name != null : !this.name.equals(other.name)) return false; if (this.employees == null ? other.employees != null : !this.employees.equals(other.employees)) return false; return true; } @java.lang.Override public int hashCode() { final int PRIME = 31; int result = 1; result = result * PRIME + (this.founder == null ? 0 : this.founder.hashCode()); result = result * PRIME + (this.name == null ? 0 : this.name.hashCode()); result = result * PRIME + (this.employees == null ? 0 : this.employees.hashCode()); return result; } @java.lang.Override public java.lang.String toString() { return \u0026#34;Company(founder=\u0026#34; + founder + \u0026#34;, name=\u0026#34; + name + \u0026#34;, employees=\u0026#34; + employees + \u0026#34;)\u0026#34;; } } /*AFTER*/ @Data(staticConstructor=\u0026#34;of\u0026#34;) public class Company { private final Person founder; private String name; private List\u0026lt;Person\u0026gt; employees; } @Builder Usaremos el patr√≥n Builder sin necesidad de implementar c√≥digo para ello, bastante √∫til tambi√©n en la ejecuci√≥n de test (unit test por ejemplo) en donde debemos crear el objeto con atributos v√°lidos o por defecto.\n@Getter @Builder public class Widget { private final String name; private final int id; } /************************************/ Widget testWidget = Widget.builder() .name(\u0026#34;foo\u0026#34;) .id(1) .build(); assertThat(testWidget.getName()) .isEqualTo(\u0026#34;foo\u0026#34;); assertThat(testWidget.getId()) .isEqualTo(1); ","date":"2020-04-21T00:00:00Z","permalink":"https://raulpadilladelgado.github.io/blog/p/lombok-annotations/","title":"Lombok annotations"},{"content":"Heroku nos va a permitir alojar nuestras aplicaciones en sus servidores, y acceder a √©stas desde un enlace que nos proporcione.\nTras crear una cuenta y descargar la l√≠nea de comandos de Heroku, nos dirigimos a la carpeta donde tengamos nuestro proyecto y ejecutamos lo siguiente:\nIniciar sesi√≥n con heroku heroku login\nInicializar repositorio con Git y primer commit. git init\ngit add .\ngit commit -m \u0026quot;primer commit\u0026quot;\nCrear espacio para nuestra app en servidor de heroku -\u0026gt; autom√°ticamente a√±ade un repositorio remoto \u0026ldquo;heroku\u0026rdquo; el que haremos push para subir nuestro proyecto a ese espacio. heroku apps:create pady-demo-boot\nSubir nuestro proyecto al espacio creado git push heroku master\nAbrir aplicaci√≥n alojada en servidor de heroku heroku open\nNos proporciona un servicio gratuito para gestionar nuestra base de datos Postgresql.\nheroku pg:psql insert into... ","date":"2020-04-17T00:00:00Z","permalink":"https://raulpadilladelgado.github.io/blog/p/deploy-b%C3%A1sico-usando-heroku-y-git/","title":"Deploy b√°sico usando Heroku y Git"},{"content":"Recientemente he estado realizando una kata que consist√≠a en partir una palabra (salto de l√≠nea) acorde a un ancho de columna, algo as√≠ como el funcionamiento de los editores de texto cuando se establece el ajuste de l√≠nea. La idea consist√≠a en ajustar la palabras, y a su vez tantas veces el resto de √©sta palabra como para que la longitud del texto en cada l√≠nea no supere el ancho de columna. Un ejercicio que da mucho que pensar y del cual pude experimentar como ir buscando poco a poco un patr√≥n que se repite en el c√≥digo para llevarlo hac√≠a un bucle o una recursividad que haga lo que necesitamos para partir la palabra cuantas veces se necesite, y que controlamos en todo momento su funcionamiento sin necesidad de depurar y asegurando que va cumpliendo los test que proponemos.\nEntrada (Texto, Ancho de columna)\n\u0026ldquo;Hola Mundo\u0026rdquo;, 6\nSalida\n\u0026ldquo;Hola/nMundo\u0026rdquo;\nEsto fue un ejemplo sencillo que se trataba. Para conocer m√°s a fondo adjunto repositorio en GitHub:\n‚¨áÔ∏è ‚¨áÔ∏è ‚¨áÔ∏è ‚¨áÔ∏è ‚¨áÔ∏è ‚¨áÔ∏è ‚¨áÔ∏è ‚¨áÔ∏è ‚¨áÔ∏è ‚¨áÔ∏è\nRepositorio Pr√°ctica Word Wrap\n","date":"2020-04-17T00:00:00Z","permalink":"https://raulpadilladelgado.github.io/blog/p/kata-word-wrap/","title":"Kata Word Wrap"},{"content":"Pongamos el ejemplo de que creamos una clase \u0026ldquo;Texto\u0026rdquo; y queremos admitir para su atributo \u0026ldquo;texto\u0026rdquo; los valores nulos como String vac√≠os, podr√≠amos implementar √©sta funcionalidad en el constructor, algo que quedar√≠a as√≠:\npublic Texto(String texto){ if(texto==null){texto=\u0026#34;\u0026#34;;} this.texto=texto; } Es perfectamente funcional, pero para conseguir un c√≥digo en el que cada componente haga lo que se espera de √©l, lo mejor ser√≠a delegar √©sta comprobaci√≥n a un m√©todo de factor√≠a, un m√©todo est√°tico que llame al constructor, estableciendo el constructor privado.\nprivate Texto(String texto){this.texto=texto;} public static Texto crearTexto(String texto){ if(texto==null){return \u0026#34;\u0026#34;;} return texto; } Con el c√≥digo anterior nuestro constructor queda m√°s limpio y hace solo lo que deber√≠a hacer.\nEn el caso de que nuestro sistema no aceptar√° los valores nulos como String vac√≠os, pod√≠amos haber codificado que retorne una excepci√≥n en lugar de cambiar ese par√°metro pasado a la funci√≥n. Un constructor que retorna una excepci√≥n es algo que ning√∫n programador espera cuando llama a un constructor, este es otro gran ejemplo de que la mejor implementaci√≥n ser√≠a delegar este retorno de excepci√≥n en un m√©todo de factor√≠a.\nEn IntelliJ, podemos hacemos un refactor autom√°tico de √©sto con el comando \u0026ldquo;Replace constructor with factory method\u0026rdquo; del men√∫ de refactorizaci√≥n.\n","date":"2020-04-17T00:00:00Z","permalink":"https://raulpadilladelgado.github.io/blog/p/reemplazar-constructores-por-m%C3%A9todos-de-factor%C3%ADa/","title":"Reemplazar constructores por m√©todos de factor√≠a"},{"content":"Inicio Arrancando con un proyecto Para crear un proyecto de una forma r√°pida y sencilla he encontrado Spring Initializr. Es muy simple, basta con elegir lenguaje, versi√≥n y otras configuraciones, como los metadatos del proyecto, y finalmente las dependencias del proyecto Spring que usaremos.\nSi elegimos \u0026ldquo;generar\u0026rdquo; nos descarga un archivo zip que cual contiene el proyecto creado ya preparado para empezar a trabajar con √©l.\nEstructura de un proyecto En el archivo pom.xml tenemos la configuraci√≥n que realizamos en Spring Initializr.\nEn src ‚Üí main ‚Üí Java ‚Üí com.example.demo, tenemos una clase DemoApplication que tiene un m√©todo main con algo de c√≥digo, que nos servir√° para comprobar que todo est√° bien y que nuestro proyecto est√° preparado para ser usado.\nEn src ‚Üí main ‚Üí Resources, tenemos dos carpetas para guardar archivos para nuestra aplicaci√≥n web, como plantillas.\nInyecci√≥n de dependencias Repositorios Por convenci√≥n para guardar datos se usan los repositorios. A la clase que definamos como repositorio le a√±adimos la anotaci√≥n \u0026ldquo;@Repository\u0026rdquo; para que el framework entienda que se usara dicha clase como la capa de repositorio.\n@Repository public class PersonaRepositoryImpl implements PersonaRepository { private static Logger LOG = LoggerFactory.getLogger(PruebaSpringBootApplication.class); @Override public void registrar(String nombre) { LOG.info(\u0026#34;SE REGISTRO A \u0026#34;+ nombre); } } Servicios Es la capa de l√≥gica de negocio. La clase debe llevar la anotaci√≥n \u0026ldquo;@Service\u0026rdquo; para indicar que funcionar√° como la capa de negocio. Si ponemos el ejemplo de que √©ste servicio act√∫a sobre un repositorio, podemos crear una instancia del repositorio con la etiqueta \u0026ldquo;@Autowired\u0026rdquo;, para que sea el propio Spring quien se encargue de crear una instancia de la clase.\n@Service public class PersonaServiceImpl implements PersonaService { @Autowired private PersonaRepository repo; @Override public void registrar(String nombre) { repo.registrar(nombre); } } Qualifier Para tener varias implementaciones de una interfaz usaremos la etiqueta \u0026ldquo;@Qualifier\u0026rdquo;. En √©ste ejemplo tenemos dos tipos de personas (repositorios), y despu√©s desde un servicio accederemos a uno de los repos con la misma anotaci√≥n.\n@Repository @Qualifier(\u0026#34;persona1\u0026#34;) public class PersonaRepositoryImpl implements PersonaRepository { private static Logger LOG = LoggerFactory.getLogger(PruebaSpringBootApplication.class); @Override public void registrar(String nombre) { LOG.info(\u0026#34;SE REGISTRO A \u0026#34;+ nombre); } } /**************************************************************************************/ @Repository @Qualifier(\u0026#34;persona2\u0026#34;) public class PersonaRepositoryImpl2 implements PersonaRepository { private static Logger LOG = LoggerFactory.getLogger(PruebaSpringBootApplication.class); @Override public void registrar(String nombre) { LOG.info(\u0026#34;SE REGISTRO A \u0026#34;+ nombre + \u0026#34;(persona2)\u0026#34;); } } /**************************************************************************************/ @Service public class PersonaServiceImpl implements PersonaService { @Autowired @Qualifier(\u0026#34;persona2\u0026#34;) private PersonaRepository repo; @Override public void registrar(String nombre) { repo.registrar(nombre); } } Spring Data (JPA) Vamos a crear una aplicaci√≥n que se conecte a una base de datos usando JPA, un m√≥dulo que facilita la implementaci√≥n de repositorios basados en JPA. Creamos una carpeta \u0026ldquo;modelos\u0026rdquo; y dentro una clase que definir√° el modelo de nuestra tabla en la BD.\nPersona.java\n@Entity public class Persona { @Id private int idPersona; @Column(name = \u0026#34;nombre\u0026#34;,length = 50) private String nombre; public int getIdPersona() { return idPersona; } public void setIdPersona(int idPersona) { this.idPersona = idPersona; } public String getNombre() { return nombre; } public void setNombre(String nombre) { this.nombre = nombre; } } Despu√©s, creamos dentro de \u0026ldquo;repositorios\u0026rdquo; una interfaz que extienda de \u0026ldquo;JpaRepository\u0026rdquo;.\nIPersonaRepositorio.java\npublic interface IPersonaRepositorio extends JpaRepository\u0026lt;Persona,Integer\u0026gt; { } Es necesario que el archivo application.properties tenga configurado lo siguiente:\nspring.jpa.database=POSTGRESQL spring.jpa.show-sql=true spring.jpa.hibernate.ddl-auto=update spring.datasource.driver-class-name=org.postgresql.Driver spring.datasource.url=jdbc:postgresql://localhost/Welcome spring.datasource.username=postgresql spring.datasource.password=passwword spring.jpa.properties.hibernate.jdbc.lob.non_contextual_creation=true El siguiente paso es crear la base de datos desde pgAdmin 4 (Postgresql), y ejecutar la aplicaci√≥n para que se nos cree la estructura de tablas.\nPara que se nos cree una tabla en la BD y meter datos dentro de √©sta, definiremos nuestro m√©todo para insertar datos a la tabla.\nWelcomeController.java\n@Autowired private IPersonaRepositorio repositorio; @GetMapping(\u0026#34;/welcome\u0026#34;) public String welcome(@RequestParam(name=\u0026#34;name\u0026#34;,required = false,defaultValue = \u0026#34;suso\u0026#34;) String name, Model model) { Persona p = new Persona(); p.setIdPersona((int) repositorio.count()); p.setNombre(name); repositorio.save(p); model.addAttribute(\u0026#34;name\u0026#34;, name); return \u0026#34;welcome\u0026#34;; } Tendremos otro m√©todo que listara todo el contenido de la tabla. Le crearemos una plantilla para mostrar los datos guardados en el modelo.\nWelcomeController.java\n@GetMapping(\u0026#34;/listar\u0026#34;) public String todasLasPersonas(Model model) { model.addAttribute(\u0026#34;personas\u0026#34;,repositorio.findAll()); return \u0026#34;personas\u0026#34;; } Ahora nos queda recorrer en la vista la lista de personas guardadas en el Model.\nPersonas.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34; xmlns:th=\u0026#34;\u0026lt;http://www.thymeleaf.org\u0026gt;\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table\u0026gt; \u0026lt;th:block th:each=\u0026#34;persona : ${personas}\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td th:text=\u0026#34;${persona.idPersona}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;td th:text=\u0026#34;${persona.nombre}\u0026#34;\u0026gt;\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/th:block\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Servicios Rest (CRUD) Se usa para describir cualquier interfaz entre sistemas que utilice directamente HTTP para obtener datos o indicar la ejecuci√≥n de operaciones sobre los datos en cualquier formato (XML, JSON, etc).\nPara crear un controlador que utilice los servicios Rest utilizamos la anotaci√≥n \u0026ldquo;@RestController\u0026rdquo;.\nM√©todo Get Si queremos definir la operaci√≥n get, usaremos \u0026ldquo;@GetMapping\u0026rdquo;.\nM√©todo Post Si queremos definir la operaci√≥n Post, usaremos \u0026ldquo;@PostMapping\u0026rdquo;. Es necesario pasar como par√°metro \u0026ldquo;@RequestBody Objeto o\u0026rdquo;.\nM√©todo Put Si queremos definir la operaci√≥n Put, usaremos \u0026ldquo;@PutMapping\u0026rdquo;. Funciona igual que el Post, pero con la diferencia de que si encuentra un id ya existente la operaci√≥n ser√° una actualizaci√≥n.\nM√©todo Delete Si queremos definir la operaci√≥n Delete, usaremos \u0026ldquo;@DeleteMapping\u0026rdquo;, que llevar como par√°metro el valor (id) que se recoge en la ruta. En el argumento del m√©todo, recogemos el id mediante \u0026ldquo;@PathVariable(id)\u0026rdquo;\nRestDemoController.java\n@RestController public class RestDemoController { @Autowired private IPersonaRepositorio repositorio; @GetMapping public List\u0026lt;Persona\u0026gt; listar(){ return repositorio.findAll(); } @PostMapping public void insertar(@RequestBody Persona persona){ repositorio.save(persona); } @PutMapping public void modificar(@RequestBody Persona persona){ repositorio.save(persona); } @DeleteMapping(value = \u0026#34;/{id}\u0026#34;) public void eliminar(@PathVariable(\u0026#34;id\u0026#34;) Integer id){ repositorio.deleteById(id); } } MVC Thymeleaf Controladores Por un lado tenemos los controladores, anotamos la clase mediante \u0026ldquo;@Controller\u0026rdquo;. Los m√©todos que se desea que funcionen como ruta de nuestra aplicaci√≥n web, debe tener la anotaci√≥n \u0026ldquo;@GetMapping(\u0026lsquo;ruta_a_elegir\u0026rsquo;)\u0026rdquo;.\n@Controller public class MainController { @GetMapping(\u0026#34;/welcome\u0026#34;) public String welcome(@RequestParam(name=\u0026#34;name\u0026#34;,required = false,defaultValue = \u0026#34;suso\u0026#34;) String name, Model model){ model.addAttribute(\u0026#34;name\u0026#34;,name); return \u0026#34;Welcome\u0026#34;; } } Si se pasa par√°metro en la ruta, se recoge mediante \u0026ldquo;@RequestParam\u0026rdquo; en √©ste caso en la variable name(String) y se guarda en la variable model(Model), la cual lo usamos para pasar datos a las vistas.\nVistas Para crear las vistas a√±adimos nuestras p√°ginas html en la carpeta \u0026ldquo;Templates\u0026rdquo;.\nEl controlador debe indicar en el return el nombre de la vista a la que se dirige.\nNecesitamos referenciar en la etiqueta html el motor de plantillas de thymeleaf (xmlns:th=\u0026quot;http://www.thymeleaf.org\u0026quot;). Para incrustar texto en una etiqueta usando dicho motor, usamos \u0026ldquo;th:text\u0026rdquo;, al cual le podemos indicar una variable guardada en el objeto model con \u0026ldquo;${variable}\u0026rdquo;.\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34; xmlns:th=\u0026#34;\u0026lt;http://www.thymeleaf.org\u0026gt;\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p th:text=\u0026#34;\u0026#39;Bienvenido, \u0026#39;+${name}\u0026#34;/\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Spring security √âstas dependencias nos crear√°n autom√°ticamente un login para nuestra aplicaci√≥n web, en el que podemos editar el usuario y contrase√±a de la siguiente manera en el archivo application.properties spring.security.user.name = pady spring.security.user.password= 1234 Es un ejemplo poco pr√°ctico, ya que lo √≥ptimo ser√≠a comprobar los usuarios mediante una base de datos. Creamos la clase usuario y su repositorio.\nUsuario.java\n@Entity public class Usuario { @Id private int id; private String nombre; private String clave; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getNombre() { return nombre; } public void setNombre(String nombre) { this.nombre = nombre; } public String getClave() { return clave; } public void setClave(String clave) { this.clave = clave; } } IUsuarioRepositorio.java\npublic interface IUsuarioRepositorio extends JpaRepository\u0026lt;Usuario,Integer\u0026gt; { } Agregamos nuestro usuario a la tabla\nSpringDataApplicationTests.java\n@Autowired private IUsuarioRepositorio repositorio_usuarios; @Test void crearUsuario() { Usuario usuario = new Usuario(); usuario.setId(0); usuario.setClave(\u0026#34;1234\u0026#34;); usuario.setNombre(\u0026#34;pady\u0026#34;); Usuario actual = repositorio_usuarios.save(usuario); assertEquals(\u0026#34;1234\u0026#34;,actual.getClave()); } Vamos a crear una clase de configuraci√≥n en nuestro proyecto, en la que usaremos un @Bean de Spring para cifrar las contrase√±as que se guardan en la base datos.\nSecurityConfig.java\n@Configuration public class SecurityConfig { @Bean public BCryptPasswordEncoder passwordEncoder(){ BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder(); return bCryptPasswordEncoder; } } Finalmente lo instanciamos en la clase donde interese, y usamos su m√©todo encode.\nSpringDataApplicationTests.java\n@Autowired private BCryptPasswordEncoder encoder; @Test void crearUsuario() { Usuario usuario = new Usuario(); usuario.setId(1); usuario.setClave(encoder.encode(\u0026#34;1234\u0026#34;)); String expected = usuario.getClave(); usuario.setNombre(\u0026#34;pady\u0026#34;); Usuario actual = repositorio_usuarios.save(usuario); assertEquals(expected,actual.getClave()); } Para habilitar @WebSecurity necesitamos que nuestra clase de configuraci√≥n extienda de WebSecurityConfigureAdapter . Sobreescibrimos los m√©todos configure para indicar de donde sacaremos los usuarios a comparar. Pero primero debemos crear una clase UserService que extienda de UserDetailsService , en la cual instanciamos el repositorio de usuarios, y sobrescribimos el m√©todo de la clase extendida. Para configurar el m√©todo de la clase extendida, tenemos que tener un m√©todo que busque por un nombre de usuario, y no por un id, as√≠ que vamos a la interfaz repositorio de usuarios y creamos dicho m√©todo.\nIUsuarioRepositorio.java\npublic interface IUsuarioRepositorio extends JpaRepository\u0026lt;Usuario,Integer\u0026gt; { Usuario findByNombre(String nombre); } UserService.java\n@Service public class UserService implements UserDetailsService { @Autowired private IUsuarioRepositorio repositorio; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { Usuario encontrado = repositorio.findByNombre(username); List\u0026lt;GrantedAuthority\u0026gt; roles = new ArrayList\u0026lt;\u0026gt;(); roles.add(new SimpleGrantedAuthority(\u0026#34;ADMIN\u0026#34;)); UserDetails userDet = new User(encontrado.getNombre(),encontrado.getClave(),roles); return userDet; } } SecurityConfig.java\n@Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private UserService userServiceDetails; @Autowired private BCryptPasswordEncoder bcrypt; @Bean public BCryptPasswordEncoder passwordEncoder(){ BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder(); return bCryptPasswordEncoder; } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userServiceDetails).passwordEncoder(bcrypt); } @Override protected void configure(HttpSecurity http) throws Exception { super.configure(http); } } PROYECTO DE EJEMPLO\n‚¨áÔ∏è ‚¨áÔ∏è ‚¨áÔ∏è ‚¨áÔ∏è ‚¨áÔ∏è ‚¨áÔ∏è\nPruebaSpringBoot\nRESUMEN\nTodo lo necesario para implementar un login mediante JPA, utilizando Postgresql como motor de base de datos.\nDefinir un modelo @Entity public class Usuario { @Id private int id; private String nombre; private String clave; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getNombre() { return nombre; } public void setNombre(String nombre) { this.nombre = nombre; } public String getClave() { return clave; } public void setClave(String clave) { this.clave = clave; } } Crear un repositorio public interface UsuarioRepository extends JpaRepository\u0026lt;Usuario,Integer\u0026gt; { Usuario findByNombre(String nombre); } Servicio de usuarios @Service public class UsuarioService implements UserDetailsService { @Autowired private UsuarioRepository repositorio; @Autowired private BCryptPasswordEncoder encoder; public void crearUsuario() { Usuario usuario = new Usuario(); usuario.setId((int)repositorio.count()+1); usuario.setClave(encoder.encode(\u0026#34;1234\u0026#34;)); usuario.setNombre(\u0026#34;pady\u0026#34;); repositorio.save(usuario); } @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { Usuario encontrado = repositorio.findByNombre(username); List\u0026lt;GrantedAuthority\u0026gt; roles = new ArrayList\u0026lt;\u0026gt;(); roles.add(new SimpleGrantedAuthority(\u0026#34;ADMIN\u0026#34;)); UserDetails userDet = new User(encontrado.getNombre(),encontrado.getClave(),roles); return userDet; } } Security Config @Configuration @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private UsuarioService userServiceDetails; @Autowired private BCryptPasswordEncoder bcrypt; @Bean public BCryptPasswordEncoder passwordEncoder(){ BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder(); return bCryptPasswordEncoder; } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userServiceDetails).passwordEncoder(bcrypt); } @Override protected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .antMatchers(\u0026#34;/\u0026#34;).permitAll() .anyRequest().authenticated() .and() .formLogin() .loginPage(\u0026#34;/login\u0026#34;) .permitAll() .and() .logout() .permitAll(); } } Creaci√≥n de usuarios @SpringBootTest class PracticaSpringBootApplicationTests { @Autowired private UsuarioService servicio; @Test void contextLoads() { servicio.crearUsuario(); } } ","date":"2020-04-17T00:00:00Z","image":"https://raulpadilladelgado.github.io/blog/p/spring-boot-primer-contacto/images/spring-icon.png","permalink":"https://raulpadilladelgado.github.io/blog/p/spring-boot-primer-contacto/","title":"Spring boot, primer contacto"},{"content":"Value object En el modelo Value Object, un objeto se diferencia de otro por su contenido, no por su identidad propia.\nPodemos entender el concepto de Value Object con el ejemplo de las monedas. Aunque cada moneda de 1 euro tiene su propia identidad (un n√∫mero de serie), la econom√≠a funciona porque entiende que una moneda de 1 euro es igual que otra moneda de un euro, ambas valen lo mismo y a efectos pr√°cticos son iguales.\nfunction createCoin() { return { value: 1 } } Los estados en un modelo Value Object son inmutables. Si queremos cambiar una caracter√≠stica, crearemos un nuevo objeto con esa caracter√≠stica, en lugar de ir modificando los estados de un √∫nico objeto. Un objeto que tiene variables de estado y que nunca cambia se llama objeto inmutable. Por lo tanto, utilizar√© el modelo de Value Object cuando tenga sentido crear nuevos objetos en lugar de confiar en un √∫nico objeto e ir cambiando su estado.\nString en JS es un objeto inmutable y lo tratamos como Value Object. Por ello, todos los m√©todos que se aplican sobre string generan un nuevo string y no modifican el original.\nvar string = \u0026#39;Hello‚Äù; string.replace(‚ÄúH‚Äù, ‚Äúx‚Äù); /*xello*/ string /*Hello*/ Entity object Este tipo de objetos se comparan en funci√≥n de su identidad. Son iguales si tienen la misma identidad, sin importar el contenido o valor. Tambi√©n es usual encontrarlos con atributos de identificaci√≥n.\nEn este modelo, el objeto tiene una identidad √∫nica e irrepetible. Adem√°s, el modelo permite que el estado del objeto vaya cambiando a lo largo del tiempo. Por lo tanto, aquello que tiene sentido que mute a lo largo del tiempo, suele implementarse como Entity Object.\nfunction user() { let id = Math.random(); let age = 23; return { getAge: function() { return age; }, birthday: function() { ++age; }, getId: function() { return id; } } } ","date":"2020-04-17T00:00:00Z","permalink":"https://raulpadilladelgado.github.io/blog/p/value-object-vs-entity-object/","title":"Value object VS Entity object"},{"content":"DAO DAO encapsula el acceso a la base de datos. Por lo que cuando la capa de l√≥gica de negocio necesite interactuar con la base de datos, va a hacerlo a trav√©s de la API que le ofrece DAO. Generalmente esta API consiste en m√©todos CRUD (Create, Read, Update y Delete). Entonces por ejemplo cuando la capa de l√≥gica de negocio necesite guardar un dato en la base de datos, va a llamar a un m√©todo create(). Lo que haga este m√©todo, es problema de DAO y depende de como DAO implemente el m√©todo create(), puede que lo implemente de manera que los datos se almacenen en una base de datos relacional como puede que lo implemente de manera que los datos se almacenen en ficheros de texto. Lo importante es que la capa de l√≥gica de negocio no tiene porque saberlo, lo √∫nico que sabe es que el m√©todo create() va a guardar los datos, as√≠ como el m√©todo delete() va a eliminarlos, el m√©todo update() actualizarlos, etc. Pero no tiene idea de como interact√∫a DAO con la base de datos.\nEn una aplicaci√≥n, hay tantos DAOs como modelos. Es decir, en una base de datos relacional, por cada tabla, habr√≠a un DAO.\nDAO consiste b√°sicamente en una clase que es la que interact√∫a con la base de datos. Los m√©todos de esta clase dependen de la aplicaci√≥n y de lo que queramos hacer. Pero generalmente se implementan los m√©todos CRUD para realizar las ‚Äú4 operaciones b√°sicas‚Äù de una base de datos.\nDTO Los DTO (Data Transfer Object) son utilizados por DAO para transportar los datos desde la base de datos hacia la capa de l√≥gica de negocio y viceversa. Por ejemplo, cuando la capa de l√≥gica de negocio llama al m√©todo create(), ¬øqu√© es lo que hace DAO? inserta un nuevo dato‚Ä¶ ¬øpero qu√© dato? el que la capa de l√≥gica de negocio le pase como par√°metro‚Ä¶ ¬øy c√≥mo se lo pasa este dato? bueno, a trav√©s de un DTO.\nTiene como finalidad crear un objeto plano (POJO) con una serie de atributos que puedan ser enviados o recuperados del servidor en una sola invocaci√≥n, de tal forma que un DTO puede contener informaci√≥n de m√∫ltiples fuentes o tablas y concentrarlas en una √∫nica clase simple.\nDado que el objetivo de un DTO es utilizarlo como un objeto de transferencia entre el cliente y el servidor, es importante evitar tener operaciones de negocio o m√©todos que realicen c√°lculos sobre los datos, es por ello que solo deberemos de tener los m√©todos GET y SET de los respectivos atributos del DTO.\nPor ejemplo, si tuvi√©ramos una base de datos relacional con una tabla empleados, con los campos id, nombre y salario. Entonces tendr√≠amos que crear una clase EmpleadoDTO, con los atributos id, nombre y salario, que van a utilizar la capa de negocio y de persistencia para transportar los datos entre las dos capas.\nEntonces cuando la capa de l√≥gica de negocio quiera guardar un dato en la base de datos, va a crear un objeto EmpleadoDTO, a trav√©s de los accessors va a modificar los atributos, y despu√©s se lo va a pasar al m√©todo create() de DAO. Entonces DAO va a leer los datos del DTO, y los va a guardar en la base de datos.\nhttps://1.bp.blogspot.com/-Cv3UY9NZdAU/XpiW6QJBnMI/AAAAAAAAAAw/FAM-NMV9DHEDhCsI94bp7na7KCYQJVN2QCLcBGAsYHQ/s400/dao.png Entidad vs DTO Las entidades son clases que fueron dise√±adas para mapear contra la base de datos, no para ser una vista para una pantalla o servicio determinado. Lo √≥ptimo ser√≠a tener un DTO con todos los datos recogidos de la base de datos, y no modificar la entidad ya que nos llevar√° a una restructuraci√≥n de la base de datos que busca¬†cubrir los requerimientos de transferencia de datos, dejando de lado el verdadero prop√≥sito de la entidad, que es √∫nicamente mapear contra la base de datos\n","date":"2020-04-16T00:00:00Z","permalink":"https://raulpadilladelgado.github.io/blog/p/patrones-de-dise%C3%B1o-dao-y-dto/","title":"Patrones de dise√±o (DAO y DTO)"}]